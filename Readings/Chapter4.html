<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Susan Eileen Fox">
<meta name="dcterms.date" content="2025-08-29">

<title>Chapter 4, Masks and Thresholds</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Chapter4_files/libs/clipboard/clipboard.min.js"></script>
<script src="Chapter4_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Chapter4_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Chapter4_files/libs/quarto-html/popper.min.js"></script>
<script src="Chapter4_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Chapter4_files/libs/quarto-html/anchor.min.js"></script>
<link href="Chapter4_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Chapter4_files/libs/quarto-html/quarto-syntax-highlighting-226bd0f977fa82dfae4534cac220d79a.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Chapter4_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Chapter4_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Chapter4_files/libs/bootstrap/bootstrap-c9dc05ccd9e6568c662515419180efc4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="Chapter4_files/libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="Chapter4_files/libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="Chapter4_files/libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Chapter 4, Masks and Thresholds</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Susan Eileen Fox </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 29, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#masking-images" id="toc-masking-images" class="nav-link active" data-scroll-target="#masking-images"><span class="header-section-number">1</span> Masking images</a>
  <ul class="collapse">
  <li><a href="#three-channel-versus-one-channel-masks" id="toc-three-channel-versus-one-channel-masks" class="nav-link" data-scroll-target="#three-channel-versus-one-channel-masks"><span class="header-section-number">1.1</span> Three-channel versus one-channel masks</a></li>
  <li><a href="#masks-built-from-image-features" id="toc-masks-built-from-image-features" class="nav-link" data-scroll-target="#masks-built-from-image-features"><span class="header-section-number">1.2</span> Masks built from image features</a></li>
  </ul></li>
  <li><a href="#converting-images-from-bgr-to-other-color-representations" id="toc-converting-images-from-bgr-to-other-color-representations" class="nav-link" data-scroll-target="#converting-images-from-bgr-to-other-color-representations"><span class="header-section-number">2</span> Converting images from ‘BGR’ to other color representations</a></li>
  <li><a href="#thresholds-from-grayscale-images" id="toc-thresholds-from-grayscale-images" class="nav-link" data-scroll-target="#thresholds-from-grayscale-images"><span class="header-section-number">3</span> Thresholds from grayscale images</a>
  <ul class="collapse">
  <li><a href="#the-threshold-function" id="toc-the-threshold-function" class="nav-link" data-scroll-target="#the-threshold-function"><span class="header-section-number">3.1</span> The <code>threshold</code> function</a></li>
  <li><a href="#adaptive-threshold" id="toc-adaptive-threshold" class="nav-link" data-scroll-target="#adaptive-threshold"><span class="header-section-number">3.2</span> Adaptive threshold</a></li>
  </ul></li>
  <li><a href="#thresholds-from-color-images" id="toc-thresholds-from-color-images" class="nav-link" data-scroll-target="#thresholds-from-color-images"><span class="header-section-number">4</span> Thresholds from color images</a></li>
  <li><a href="#pseudo-thresholds-with-histograms-and-backprojection" id="toc-pseudo-thresholds-with-histograms-and-backprojection" class="nav-link" data-scroll-target="#pseudo-thresholds-with-histograms-and-backprojection"><span class="header-section-number">5</span> Pseudo-thresholds with histograms and backprojection</a>
  <ul class="collapse">
  <li><a href="#making-a-reference-image-or-roi" id="toc-making-a-reference-image-or-roi" class="nav-link" data-scroll-target="#making-a-reference-image-or-roi"><span class="header-section-number">5.1</span> Making a reference image or ROI</a></li>
  <li><a href="#building-a-histogram-of-hues-from-reference-image" id="toc-building-a-histogram-of-hues-from-reference-image" class="nav-link" data-scroll-target="#building-a-histogram-of-hues-from-reference-image"><span class="header-section-number">5.2</span> Building a histogram of hues from reference image</a></li>
  <li><a href="#computing-the-backprojection" id="toc-computing-the-backprojection" class="nav-link" data-scroll-target="#computing-the-backprojection"><span class="header-section-number">5.3</span> Computing the backprojection</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>In this chapter, we will examine a two basic approaches for <strong>transforming</strong> images: taking in an image, and producing a new, changed image. First we will examine the process of masking an image, using a black-and-white image to determine which pixels to keep in an image. And then we will look at several methods for building <strong>threshold</strong> images, which are typically grayscale or black-and-white, and which separate pixels with certain properties from pixels that lack those properties.</p>
<section id="masking-images" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Masking images</h1>
<p>When we <strong>mask</strong> an image, we cover over portions of the image, allowing only selected portions to be visible. To mask an image, we must first create a <em>mask image</em>: a special image that has only black and white pixels. The black portions of the mask image are where we will cover up the original image, and the white portions are where we will let the original image show through.</p>
<p>One way to picture this process, is to imagine we have a printed photograph of some kind. If we take a black sheet of paper, and cut holes in it, and then lay it over the printed photograph, that is what masking does. The white parts of the mask image are the holes in the black paper.</p>
<p>There are multiple ways of creating masks. The most simple is to just make a black image and then draw on it the regions we can to keep in the original image. The code example below does exactly this, using OpenCV’s drawing functions to create a black and white mask image.</p>
<div id="df18aa85" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> cv2</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a>origImg <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/grandTeton.jpg"</span>)</span>
<span id="cb1-5"><a href="#cb1-5"></a>maskImg <span class="op">=</span> np.zeros(origImg.shape, origImg.dtype)   <span class="co"># Makes a copy the same size and type, but all zeros, so black</span></span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co"># draw a rectangular region on the mask, and a line of circles</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>cv2.rectangle(maskImg, (<span class="dv">75</span>, <span class="dv">320</span>), (<span class="dv">565</span>, <span class="dv">565</span>), (<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span> (<span class="dv">160</span>, <span class="dv">640</span>, <span class="dv">160</span>):</span>
<span id="cb1-10"><a href="#cb1-10"></a>    cv2.circle(maskImg, (x, <span class="dv">160</span>), <span class="dv">50</span>, (<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a>cv2.imshow(<span class="st">"Original"</span>, origImg)</span>
<span id="cb1-13"><a href="#cb1-13"></a>cv2.imshow(<span class="st">"Mask"</span>, maskImg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><a href="#fig-buildMask" class="quarto-xref">Figure&nbsp;1</a> shows the original image and the mask image constructed by the code.</p>
<div id="fig-buildMask" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-buildMask-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/grandTetons.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Original image"><img src="Ch4-Images/grandTetons.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Original image</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/MaskImg.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Mask image with additions"><img src="Ch4-Images/MaskImg.png" class="img-fluid figure-img"></a></p>
<figcaption>Mask image with additions</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-buildMask-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Original image, and mask image with rectangle and circles on it
</figcaption>
</figure>
</div>
<p>To apply the mask to the original image, we will use the OpenCV function <code>bitwise_and</code>. This is an arithmetic function on images. It takes two images the same size and shape, and it combines them using the bitwise and operation. You don’t need to know all the details, just this: <strong>bitwise-and of a color and white returns the color, bitwise-and of a color and black returns black.</strong> This gives us the effect we want: the original colors where the mask was white, and black where the mask was black. Below is a continuation of the script above showing how to apply the mask, and <a href="#fig-maskresult" class="quarto-xref">Figure&nbsp;2</a> shows the result of this operation.</p>
<div id="e8e76ee5" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># apply mask</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>maskedImage <span class="op">=</span> cv2.bitwise_and(origImg, maskImg)</span>
<span id="cb2-3"><a href="#cb2-3"></a>cv2.imshow(<span class="st">"Mask result"</span>, maskedImage)</span>
<span id="cb2-4"><a href="#cb2-4"></a>cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-maskresult" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-maskresult-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="Ch4-Images/MaskResult.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Figure&nbsp;2: Result of applying the mask above to the original image"><img src="Ch4-Images/MaskResult.png" class="img-fluid figure-img" style="width:12cm"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-maskresult-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Result of applying the mask above to the original image
</figcaption>
</figure>
</div>
<section id="three-channel-versus-one-channel-masks" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="three-channel-versus-one-channel-masks"><span class="header-section-number">1.1</span> Three-channel versus one-channel masks</h2>
<p>The mask image above was created as a color image, with three channels. If the only colors in a mask are white or black, we don’t really need all three channels. However, when we have a one-channel mask, applying it to the image is a little bit different.</p>
<p>The script below demonstrates several ideas:</p>
<ul>
<li>How to apply a mask to frames of a video feed</li>
<li>How to apply a one-channel mask to a color image</li>
<li>How to make a square bounce around a window</li>
</ul>
<p>We’ll discuss each of these ideas as they appear in the code below. Be sure to read the annotations on the lines of code before continuing.</p>
<div id="f051a5b1" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="annotated-cell-3"><pre class="sourceCode numberSource python code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-3-1"><a href="#annotated-cell-3-1"></a>vidCap <span class="op">=</span> cv2.VideoCapture(<span class="dv">0</span>)</span>
<span id="annotated-cell-3-2"><a href="#annotated-cell-3-2"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="1">1</button><span id="annotated-cell-3-3" class="code-annotation-target"><a href="#annotated-cell-3-3"></a>sqrX <span class="op">=</span> <span class="dv">50</span></span>
<span id="annotated-cell-3-4"><a href="#annotated-cell-3-4"></a>sqrY <span class="op">=</span> <span class="dv">50</span></span>
<span id="annotated-cell-3-5"><a href="#annotated-cell-3-5"></a>deltaX <span class="op">=</span> <span class="dv">5</span></span>
<span id="annotated-cell-3-6"><a href="#annotated-cell-3-6"></a>deltaY <span class="op">=</span> <span class="dv">5</span></span>
<span id="annotated-cell-3-7"><a href="#annotated-cell-3-7"></a>sqSize <span class="op">=</span> <span class="dv">400</span></span>
<span id="annotated-cell-3-8"><a href="#annotated-cell-3-8"></a></span>
<span id="annotated-cell-3-9"><a href="#annotated-cell-3-9"></a><span class="cf">while</span> <span class="va">True</span>:</span>
<span id="annotated-cell-3-10"><a href="#annotated-cell-3-10"></a>    res, frame <span class="op">=</span> vidCap.read()</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="2">2</button><span id="annotated-cell-3-11" class="code-annotation-target"><a href="#annotated-cell-3-11"></a>    (hgt, wid, dep)<span class="op">=</span> frame.shape</span>
<span id="annotated-cell-3-12"><a href="#annotated-cell-3-12"></a>    </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="3">3</button><span id="annotated-cell-3-13" class="code-annotation-target"><a href="#annotated-cell-3-13"></a>    <span class="co"># make mask a grayscale image (one channel)</span></span>
<span id="annotated-cell-3-14"><a href="#annotated-cell-3-14"></a>    maskIm <span class="op">=</span> np.zeros((hgt, wid), np.uint8)</span>
<span id="annotated-cell-3-15"><a href="#annotated-cell-3-15"></a>    cv2.rectangle(maskIm, (sqrX, sqrY), (sqrX <span class="op">+</span> sqSize, sqrY <span class="op">+</span> sqSize), <span class="dv">255</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="annotated-cell-3-16"><a href="#annotated-cell-3-16"></a>    </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="4">4</button><span id="annotated-cell-3-17" class="code-annotation-target"><a href="#annotated-cell-3-17"></a>    maskedFrame <span class="op">=</span> cv2.bitwise_and(frame, frame, mask<span class="op">=</span>maskIm)</span>
<span id="annotated-cell-3-18"><a href="#annotated-cell-3-18"></a>    </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="5">5</button><span id="annotated-cell-3-19" class="code-annotation-target"><a href="#annotated-cell-3-19"></a>    cv2.imshow(<span class="st">"Moving Mask"</span>, maskedFrame)</span>
<span id="annotated-cell-3-20"><a href="#annotated-cell-3-20"></a>    x <span class="op">=</span> cv2.waitKey(<span class="dv">10</span>)</span>
<span id="annotated-cell-3-21"><a href="#annotated-cell-3-21"></a>    <span class="cf">if</span> x <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="annotated-cell-3-22"><a href="#annotated-cell-3-22"></a>        <span class="cf">if</span> <span class="bu">chr</span>(x) <span class="op">==</span> <span class="st">'q'</span>:</span>
<span id="annotated-cell-3-23"><a href="#annotated-cell-3-23"></a>            <span class="cf">break</span></span>
<span id="annotated-cell-3-24"><a href="#annotated-cell-3-24"></a>    </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="6">6</button><span id="annotated-cell-3-25" class="code-annotation-target"><a href="#annotated-cell-3-25"></a>    <span class="cf">if</span> (sqrX <span class="op">+</span> sqSize <span class="op">&gt;=</span> wid) <span class="kw">or</span> (sqrX <span class="op">&lt;=</span> <span class="dv">0</span>):</span>
<span id="annotated-cell-3-26"><a href="#annotated-cell-3-26"></a>        deltaX <span class="op">=</span> <span class="op">-</span>deltaX</span>
<span id="annotated-cell-3-27"><a href="#annotated-cell-3-27"></a>    <span class="cf">if</span> (sqrY <span class="op">+</span> sqSize <span class="op">&gt;=</span> hgt) <span class="kw">or</span> (sqrY <span class="op">&lt;=</span> <span class="dv">0</span>):</span>
<span id="annotated-cell-3-28"><a href="#annotated-cell-3-28"></a>        deltaY <span class="op">=</span> <span class="op">-</span>deltaY</span>
<span id="annotated-cell-3-29"><a href="#annotated-cell-3-29"></a>    </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="7">7</button><span id="annotated-cell-3-30" class="code-annotation-target"><a href="#annotated-cell-3-30"></a>    sqrX <span class="op">+=</span> deltaX</span>
<span id="annotated-cell-3-31"><a href="#annotated-cell-3-31"></a>    sqrY <span class="op">+=</span> deltaY</span>
<span id="annotated-cell-3-32"><a href="#annotated-cell-3-32"></a></span>
<span id="annotated-cell-3-33"><a href="#annotated-cell-3-33"></a>vidCap.release()</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-3" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="3,4,5,6,7" data-code-annotation="1">Sets up variables to hold the size and position of the mask square, and how fast it will change from one frame to the other</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="11" data-code-annotation="2">Gets the shape of the frame into <code>hgt</code> and <code>wid</code> variables, so we can make a one-channel mask</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="13,14,15" data-code-annotation="3">Creates the mask and draws a white square on it</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="17" data-code-annotation="4">Applies the mask to the frame from the camera feed (or video file), using the <code>mask</code> input</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="19" data-code-annotation="5">Displays the result</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="25,26,27,28" data-code-annotation="6">Changes <code>deltaX</code> and/or <code>deltaY</code> if the square gets to any of the four edges of the picture; causes the square to change the direction it moves</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="7">7</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="30,31" data-code-annotation="7">Updates the position of the square for the next frame, by adding <code>deltaX</code> to <code>sqrX</code> and <code>deltaY</code> to <code>sqrY</code></span>
</dd>
</dl>
</div>
</div>
<p>The first part of the <code>while</code> loop creates the mask with one white square, and applies it to the original image. To understand how one-channel masks can be applied to an image, focus on <strong>line 17</strong>. We cannot just call <code>bitwise_and</code> and pass it the original frame and the mask, because <code>bitwise_and</code> requires that the two images passed to it are the same shape. <em>However,</em> <code>bitwise_and</code> takes an optional input called <code>mask</code>, which specifies a one-channel mask, which is applied to the result of the bitwise-and operation. So we pass the original frame in for both ordinary inputs (bitwise-and applied to two identical images produces the image itself again). And then the mask gets applied in a separate step. <strong>This is cryptic and weird, but it works!</strong></p>
<p>The last idea in this code, making a shape bounce around a window, is just for fun, and to emphasize that for each frame in the video feed, we compute and apply a new mask. The key to moving the square is just to change the position of its upper left (x, y) coordinates, which is done at the end of the <code>while</code> loop. To keep the square from just moving out of view, we need to make it bounce back. This sounds daunting, but is actually easy.</p>
<ul>
<li>If the right edge of the square reaches or exceeds the right edge of the image, then we change the <code>deltaX</code> value to be its negative (it will have been +5, after this it will be -5)</li>
<li>If the left edge of the square reaches or exceeds the left edge of the image, then we change <code>deltaX</code> to be its negative (it will have been -5, –5 = +5)</li>
<li>Similar logic for the top and bottom edges</li>
</ul>
<p><strong>Try this code for yourself.</strong> To fully understand this code, you should experiment with changing the accumulator variables (one at a time) that control the position, size, and movement speed of the square. Or change the rectangle to a circle or an ellipse.</p>
</section>
<section id="masks-built-from-image-features" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="masks-built-from-image-features"><span class="header-section-number">1.2</span> Masks built from image features</h2>
<p>Besides building masks as we have done here, by drawing white shapes on a black image, we can also generate mask images using other image transformations, so that the pixels that are white fit some pattern or criteria. Later in this chapter, we will look at a common way to create these masks: computing threshold images.</p>
</section>
</section>
<section id="converting-images-from-bgr-to-other-color-representations" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Converting images from ‘BGR’ to other color representations</h1>
<p>Some of our image manipulations will require us to change from the normal BGR representation of an image to other forms, including grayscale and HSV. OpenCV gives us one function that can convert between all the implemented color representations: <code>cvtColor</code>. This function takes in an image and a code that tells it which conversion we want, and it returns the converted image. The script below shows how to convert an image to grayscale and to HSV.</p>
<div id="979ef8ab" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>img <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/mushrooms.jpg"</span>)</span>
<span id="cb3-2"><a href="#cb3-2"></a>grayImg <span class="op">=</span> cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span>
<span id="cb3-3"><a href="#cb3-3"></a>hsvImg <span class="op">=</span> cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</span>
<span id="cb3-4"><a href="#cb3-4"></a>cv2.imshow(<span class="st">"Original"</span>, img)</span>
<span id="cb3-5"><a href="#cb3-5"></a>cv2.imshow(<span class="st">"Grayscale"</span>, grayImg)</span>
<span id="cb3-6"><a href="#cb3-6"></a>cv2.imshow(<span class="st">"HSV - weird!"</span>, hsvImg)</span>
<span id="cb3-7"><a href="#cb3-7"></a>cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><a href="#fig-gray" class="quarto-xref">Figure&nbsp;3</a> shows the original image next to the grayscale version. The <code>imshow</code> function recognizes grayscale images, which have only one channel, and can display them correctly.</p>
<div id="fig-gray" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-gray-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/mushrooms.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Original image"><img src="Ch4-Images/mushrooms.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Original image</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/mushGray.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Grayscale version"><img src="Ch4-Images/mushGray.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Grayscale version</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-gray-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: The original mushrooms picture, and its grayscale version
</figcaption>
</figure>
</div>
<p><strong>A warning about HSV:</strong> HSV images have three channels and use <code>np.uint8</code> as the data type, just like BGR ones. To the computer, these image representations look identical! A function that expects a BGR image and is given an HSV one will interpret the hue channel as a blue channel, the saturation channel as a green one, and the value channel as red. The <code>imshow</code> function assumes that an image with three channels is BGR, so if we try to display an HSV image, we get an odd result, as shown in <a href="#fig-HSV" class="quarto-xref">Figure&nbsp;4</a></p>
<div id="fig-HSV" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-HSV-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="Ch4-Images/mushHSV.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Figure&nbsp;4: Attempt to display the HSV version of the mushrooms image with imshow"><img src="Ch4-Images/mushHSV.jpg" class="img-fluid figure-img" style="width:10cm"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-HSV-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Attempt to display the HSV version of the mushrooms image with <code>imshow</code>
</figcaption>
</figure>
</div>
</section>
<section id="thresholds-from-grayscale-images" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Thresholds from grayscale images</h1>
<p>Threshold functions transform images based on the range of grayscale brightness or color values at each pixel. They often produce a black and white image. Threshold images are suitable for use as a mask, but we can also use the threshold image to locate interesting objects in the image.</p>
<section id="the-threshold-function" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="the-threshold-function"><span class="header-section-number">3.1</span> The <code>threshold</code> function</h2>
<p>The simplest threshold function is called just <code>threshold</code>. It operates on grayscale images, and has multiple modes to choose from. It returns a new grayscale or black and white image.</p>
<p>The <code>threshold</code> function takes in four inputs and returns two results. The four inputs include: a source image, a threshold value (between 0 and 255), a maximum value (also between 0 and 255), and a constant that defines which threshold variant to perform. <a href="#tbl-threshmodes" class="quarto-xref">Table&nbsp;1</a> shows the five main variants for this function.</p>
<div id="tbl-threshmodes" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-threshmodes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Five main threshold modes, which create different results, binary thresholding is most common
</figcaption>
<div aria-describedby="tbl-threshmodes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 28%">
<col style="width: 71%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Threshold mode</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>cv2.THRESH_BINARY</code></td>
<td style="text-align: left;">Values above the threshold are set to the maximum value, values less than or equal to the threshold are set to zero</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>cv2.THRESH_BINARY_INV</code></td>
<td style="text-align: left;">Values above the threshold are set to zero, values less than or equal to the threshold are set to the maximum value</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>cv2.THRESH_TRUNC</code></td>
<td style="text-align: left;">Values above the threshold are set to the threshold value, values less than or equal to the threshold are unchanged</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>cv2.THRESH_TOZERO</code></td>
<td style="text-align: left;">Values above the threshold are left unchanged, values less than or equal to the threshold are set to zero</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>cv2.THRESH_TOZERO_INV</code></td>
<td style="text-align: left;">Values above the threshold are set to zero, values less than or equal to the threshold are left unchanged</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>The <code>threshold</code> function returns two values. The first returned value is the threshold value. This may seem odd, but the function has optional add-ons that use particular algorithms to guess at the most useful threshold value. In those cases, we do want the function to tell us the value the algorithm chose. The second returned value is the threshold image itself.</p>
<p>The script below illustrates the <code>threshold</code> function, in all its main variants, on a picture of coins on a red background (found in the <code>Coins</code> folder inside <code>SampleImages</code>). <a href="#fig-threshVariants" class="quarto-xref">Figure&nbsp;5</a> shows the original image, its grayscale counterpart, and then all the five variants.</p>
<div id="1219cad7" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>coinImg <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/Coins/coins6.jpg"</span>)</span>
<span id="cb4-2"><a href="#cb4-2"></a>grayCoin <span class="op">=</span> cv2.cvtColor(coinImg, cv2.COLOR_BGR2GRAY)</span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a>cv2.imshow(<span class="st">"Original"</span>, coinImg)</span>
<span id="cb4-5"><a href="#cb4-5"></a>cv2.imshow(<span class="st">"Gray"</span>, grayCoin)</span>
<span id="cb4-6"><a href="#cb4-6"></a>cv2.waitKey()</span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a>threshModes <span class="op">=</span> [cv2.THRESH_BINARY, cv2.THRESH_BINARY_INV, cv2.THRESH_TRUNC, cv2.THRESH_TOZERO, cv2.THRESH_TOZERO_INV]</span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="cf">for</span> threshMode <span class="kw">in</span> threshModes:</span>
<span id="cb4-10"><a href="#cb4-10"></a>    res, threshIm <span class="op">=</span> cv2.threshold(grayCoin, <span class="dv">128</span>, <span class="dv">255</span>, threshMode)</span>
<span id="cb4-11"><a href="#cb4-11"></a>    cv2.imshow(<span class="st">"Threshed"</span>, threshIm)</span>
<span id="cb4-12"><a href="#cb4-12"></a>    cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-threshVariants" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-threshVariants-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/coins6.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Original image"><img src="Ch4-Images/coins6.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Original image</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/grayCoin.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-8" title="Grayscale version"><img src="Ch4-Images/grayCoin.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Grayscale version</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/threshedBin.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-9" title="Result of threshold with THRESH_BINARY mode"><img src="Ch4-Images/threshedBin.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of threshold with <code>THRESH_BINARY</code> mode</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/threshedBinInv.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-10" title="Result of threshold with THRESH_BINARY_INV mode"><img src="Ch4-Images/threshedBinInv.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of threshold with <code>THRESH_BINARY_INV</code> mode</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/threshedTrunc.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-11" title="Result of threshold with THRESH_TRUNC mode"><img src="Ch4-Images/threshedTrunc.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of threshold with <code>THRESH_TRUNC</code> mode</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/threshedToZero.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-12" title="Result of threshold with THRESH_TOZERO mode"><img src="Ch4-Images/threshedToZero.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of threshold with <code>THRESH_TOZERO</code> mode</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/threshedToZeroInv.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-13" title="Result of threshold with THRESH_TOZERO_INV mode"><img src="Ch4-Images/threshedToZeroInv.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of threshold with <code>THRESH_TOZERO_INV</code> mode</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-threshVariants-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Showing the main variants of the <code>threshold</code> function, all run with threshold value of 128 and max value of 255
</figcaption>
</figure>
</div>
<p>One issue with <code>threshold</code>is determining what the best threshold value is. Algorithms exist that can identify good threshold values for you, and two of them are integrated into the <code>threshold</code> function. The OTSU and Triangle algorithms both build a histogram of the brightness values in a grayscale image. The OTSU algorithm looks for a threshold value that minimizes the variance on each side of the threshold in the histogram. The Triangle algorithm draws a line between the maximum histogram and the minimum one, and finds the point along that line that is maximal distance from values in the histogram, and uses that as the threshold value. (For more information about both algorithms, see <a href="https://en.wikipedia.org/wiki/Otsu%27s_method">OTSU’s Wikipedia page</a>, or <a href="https://stackabuse.com/opencv-thresholding-in-python-with-cv2threshold/">David Landup’s blog on StackAbuse.com</a>).</p>
<p>Below is a variation on the code above that shows how to use OTSU or Triangle, combining it with the binary threshold mode. <a href="#fig-adapt1" class="quarto-xref">Figure&nbsp;6</a> illustrates the results on the coins pictures of each of these algorithms. Note that when we use these algorithms, <code>threshold</code> ignores the input threshold value, and computes its own. It then returns the computed threshold value as its return value.</p>
<div id="227f7220" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>coinImg <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/Coins/coins6.jpg"</span>)</span>
<span id="cb5-2"><a href="#cb5-2"></a>grayCoin <span class="op">=</span> cv2.cvtColor(coinImg, cv2.COLOR_BGR2GRAY)</span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co"># Adaptive threshold with OTSU and Triangle algorithms</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>adaptMode1 <span class="op">=</span> cv2.THRESH_BINARY <span class="op">+</span> cv2.THRESH_OTSU</span>
<span id="cb5-6"><a href="#cb5-6"></a>adaptMode2 <span class="op">=</span> cv2.THRESH_BINARY <span class="op">+</span> cv2.THRESH_TRIANGLE</span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="cf">for</span> tm <span class="kw">in</span> [adaptMode1, adaptMode2]:</span>
<span id="cb5-8"><a href="#cb5-8"></a>    res, threshIm <span class="op">=</span> cv2.threshold(grayCoin, <span class="dv">128</span>, <span class="dv">255</span>, tm)</span>
<span id="cb5-9"><a href="#cb5-9"></a>    <span class="bu">print</span>(res)</span>
<span id="cb5-10"><a href="#cb5-10"></a>    cv2.imshow(<span class="st">"Threshed"</span>, threshIm)</span>
<span id="cb5-11"><a href="#cb5-11"></a>    cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-adapt1" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-adapt1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/threshedBinOTSU161.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-14" title="Result of threshold with THRESH_BINARY + THRESH_OTSU mode, chose threshold value of 161"><img src="Ch4-Images/threshedBinOTSU161.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of threshold with <code>THRESH_BINARY + THRESH_OTSU</code> mode, chose threshold value of 161</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/threshedBinTriangle105.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-15" title="Result of threshold with THRESH_BINARY + THRESH_TRIANBLE mode, chose threshold value of 105"><img src="Ch4-Images/threshedBinTriangle105.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of threshold with <code>THRESH_BINARY + THRESH_TRIANBLE</code> mode, chose threshold value of 105</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-adapt1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Showing the two adaptive modes for the <code>threshold</code> function, usually added to the binary or to-zero threshold modes.
</figcaption>
</figure>
</div>
<p><strong>Think about this:</strong> Of all of these approaches, which work best on this picture? Experiment with this code, trying it on the other coin pictures in <code>SampleImages</code>. Does the same version or the same threshold, work for all pictures?</p>
</section>
<section id="adaptive-threshold" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="adaptive-threshold"><span class="header-section-number">3.2</span> Adaptive threshold</h2>
<p>The <code>adaptiveThreshold</code> function takes things a step further. Rather than just determining one global threshold value, it throws out the idea of a global threshold value altogether. Instead, it computes an individual threshold value at each small patch in the image (this is really a form of <strong>filtering</strong>, which is the next main subject in this chapter!).</p>
<p>The function does the same operation on every overlapping patch in the image. It computes either a plain average or a weighted average of the brightness values in the patch, and subtracts a constant <code>c</code> that we provide. This value is the threshold value for the center pixel of the patch. thus different parts of the image may have very different threshold values.</p>
<p>An input constant selects whether to do a plain average or a <em>Gaussian</em> one. We typically describe an ordinary average as adding up the values in the patch and dividing by the number of values. But we can also think of it as multiplying every value in the patch by one over the number of values (if there are <span class="math inline">\(n\)</span> pixels in a patch, by <span class="math inline">\(1/n\)</span>, and then adding up the results. A Gaussian average is also computed by multiplying every value in the patch by a weight value and then adding the results. However, instead of using the same weight at every position, we choose weights so that they (1) add up to 1.0, and (2) form a Gaussian curve (also called a Normal curve, or a bell curve.). <a href="#fig-gauss" class="quarto-xref">Figure&nbsp;7</a> depicts a typical two-dimensional Gaussian curve. This weights values at the middle of the patch highest, and those at the edge of the patch lowest, in a systematic way.</p>
<div id="fig-gauss" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-gauss-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="Ch4-Images/2dGaussPlot.png" class="lightbox" data-gallery="quarto-lightbox-gallery-16" title="Figure&nbsp;7: Two-dimensional Gaussian curve"><img src="Ch4-Images/2dGaussPlot.png" class="img-fluid figure-img" style="width:10cm"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-gauss-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7: Two-dimensional Gaussian curve
</figcaption>
</figure>
</div>
<p>The <code>adaptiveThreshold</code> function takes six (<strong>6!</strong>) inputs, outlined below:</p>
<ul>
<li>The grayscale image to be processed</li>
<li>The maximum value for the thresholding mode</li>
<li>The adaptive effect, one of <code>cv2.ADAPTIVE_THRESH_MEAN_C</code> or <code>cv2.ADAPTIVE_THRESH_GAUSSIAN_C</code> (see discussion above)</li>
<li>The threshold mode, same ones as the <code>threshold</code> function takes</li>
<li>The size in pixels of the patch to use (use an odd number so that there is always a center pixel)</li>
<li>The value of <code>c</code>, a constant that will be subtracted from the average that is computed to produce the threshold value</li>
</ul>
<p>The code example below loops over different values for the patch size (called <code>bSize</code> because patches are called blocks), and different values for the <code>c</code> constant. We often have to experiment to find the right combination of these values to get the result we want.</p>
<div id="1859e918" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="cf">for</span> bSize <span class="kw">in</span> [<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">11</span>]:</span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="cf">for</span> c <span class="kw">in</span> [<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">20</span>]:</span>
<span id="cb6-3"><a href="#cb6-3"></a>        adaIm1 <span class="op">=</span> cv2.adaptiveThreshold(grayCoin, </span>
<span id="cb6-4"><a href="#cb6-4"></a>                                       <span class="dv">255</span>, </span>
<span id="cb6-5"><a href="#cb6-5"></a>                                       cv2.ADAPTIVE_THRESH_MEAN_C, </span>
<span id="cb6-6"><a href="#cb6-6"></a>                                       cv2.THRESH_BINARY,</span>
<span id="cb6-7"><a href="#cb6-7"></a>                                       bSize,</span>
<span id="cb6-8"><a href="#cb6-8"></a>                                       c)</span>
<span id="cb6-9"><a href="#cb6-9"></a>        adaIm2 <span class="op">=</span> cv2.adaptiveThreshold(grayCoin,</span>
<span id="cb6-10"><a href="#cb6-10"></a>                                       <span class="dv">255</span>, </span>
<span id="cb6-11"><a href="#cb6-11"></a>                                       cv2.ADAPTIVE_THRESH_GAUSSIAN_C, </span>
<span id="cb6-12"><a href="#cb6-12"></a>                                       cv2.THRESH_BINARY,</span>
<span id="cb6-13"><a href="#cb6-13"></a>                                       bSize,</span>
<span id="cb6-14"><a href="#cb6-14"></a>                                       c)</span>
<span id="cb6-15"><a href="#cb6-15"></a>        <span class="bu">print</span>(bSize, c)</span>
<span id="cb6-16"><a href="#cb6-16"></a>        cv2.imshow(<span class="st">"Adaptive Mean_C"</span>, adaIm1)</span>
<span id="cb6-17"><a href="#cb6-17"></a>        cv2.imshow(<span class="st">"Adaptive Gauss_C"</span>, adaIm2)</span>
<span id="cb6-18"><a href="#cb6-18"></a>        cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="border">
<p>Notice how the calls to <code>adaptiveThreshold</code> are formatted, with one input per line. This is a common Python style: if the arguments to a function run too far to the right, rather than just breaking them up wherever, we put one per line, and line them up under the start of the first input.</p>
</div>
<p><a href="#fig-adaptiveThresh" class="quarto-xref">Figure&nbsp;8</a> shows pairs of values, one for the mean, and one for the Gaussian average, for different values of <code>bSize</code> and <code>c</code>.</p>
<div id="fig-adaptiveThresh" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-adaptiveThresh-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshMean3_2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-17" title="Mean, bSize = 3, c = 2"><img src="Ch4-Images/adaptiveThreshold/adaThreshMean3_2.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Mean</code>, <code>bSize</code> = 3, <code>c</code> = 2</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshGauss3_2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-18" title="Gauss, bSize = 3, c = 2"><img src="Ch4-Images/adaptiveThreshold/adaThreshGauss3_2.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Gauss</code>, <code>bSize</code> = 3, <code>c</code> = 2</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshMean3_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-19" title="Mean, bSize = 3, c = 5"><img src="Ch4-Images/adaptiveThreshold/adaThreshMean3_5.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Mean</code>, <code>bSize</code> = 3, <code>c</code> = 5</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshGauss3_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-20" title="Gauss, bSize = 3, c = 5"><img src="Ch4-Images/adaptiveThreshold/adaThreshGauss3_5.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Gauss</code>, <code>bSize</code> = 3, <code>c</code> = 5</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshMean7_2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-21" title="Mean, bSize = 7, c == 2"><img src="Ch4-Images/adaptiveThreshold/adaThreshMean7_2.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Mean</code>, <code>bSize</code> = 7, <code>c</code> == 2</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshGauss7_2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-22" title="Gauss, bSize = 7, c = 2"><img src="Ch4-Images/adaptiveThreshold/adaThreshGauss7_2.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Gauss</code>, <code>bSize</code> = 7, <code>c</code> = 2</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshMean7_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-23" title="Mean, bSize = 7, c = 5"><img src="Ch4-Images/adaptiveThreshold/adaThreshMean7_5.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Mean</code>, <code>bSize</code> = 7, <code>c</code> = 5</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshGauss7_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-24" title="Gauss, bSize = 7, c = 5"><img src="Ch4-Images/adaptiveThreshold/adaThreshGauss7_5.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Gauss</code>, <code>bSize</code> = 7, <code>c</code> = 5</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshMean11_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-25" title="Mean, bSize = 11, c = 5"><img src="Ch4-Images/adaptiveThreshold/adaThreshMean11_5.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Mean</code>, <code>bSize</code> = 11, <code>c</code> = 5</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshGauss11_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-26" title="Gauss, bSize = 11, c = 5"><img src="Ch4-Images/adaptiveThreshold/adaThreshGauss11_5.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Gauss</code>, <code>bSize</code> = 11, <code>c</code> = 5</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshMean11_10.png" class="lightbox" data-gallery="quarto-lightbox-gallery-27" title="Mean, bSize = 11, c = 10"><img src="Ch4-Images/adaptiveThreshold/adaThreshMean11_10.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Mean</code>, <code>bSize</code> = 11, <code>c</code> = 10</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshGauss11_10.png" class="lightbox" data-gallery="quarto-lightbox-gallery-28" title="Gauss, bSize = 11, c = 10"><img src="Ch4-Images/adaptiveThreshold/adaThreshGauss11_10.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Gauss</code>, <code>bSize</code> = 11, <code>c</code> = 10</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-adaptiveThresh-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8: Showing the varying results for <code>adaptiveThreshold</code> given different averaging and values of <code>bSize</code> and <code>x</code>
</figcaption>
</figure>
</div>
</section>
</section>
<section id="thresholds-from-color-images" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Thresholds from color images</h1>
<p>Grayscale as a basis for finding objects in images is limited. We could have a red ball on a green background where they happen to have similar brightness levels. We often want to detect objects by their colors, so there is a threshold function that does just that: <code>inRange</code>. This function takes in a color image, plus two tuples that specify low and high values for each channel, and it returns a threshold image. The returned image is white for pixels where all channel vaues fall within the range we’ve given for that channel.</p>
<p>We can use <code>inRange</code> on BGR images, but BGR color values change in complex ways when the lighting varies: all three channels must increase to produce a brighter version of a given hue, for instance. Instead we will <em>typically</em> convert the image to HSV and then use <code>inRange</code>. If we want to detect a certain color, we can use a narrow range of hue values, but let the saturation and value cover most of the range.</p>
<p><strong>OpenCV adaptation of HSV:</strong> If you look at a color wheel to explore HSV values for colors, you will notice that the hue channel typically ranges from 0 to 359 (degrees around a circl), while the saturation and value channels often range either between 0.0 and 1.0 or betwen 0 and 100. OpenCV wants to use 8-bit unsigned integers to represent HSV channels; those are restricted to 0 to 255. The typical range of hue values will not fit in an 8-bit unsigned integer, and the typical range of saturation and value would use less than half of the range available. Thus, OpenCV implements a variation on the typical HSV representation:</p>
<ul>
<li>OpenCV uses the range from 0 to 180 to represent hues (take the typical hue and divide by 2)</li>
<li>OpenCV maps saturation and value numbers on to the full range from 0 to 255</li>
</ul>
<p>Below is a script that detects a green ball in an image using <code>inRange</code>. It also shows what happens if we try to isolate the ball in the image using <code>threshold</code>, even with the threshold adaptation OTSU in use. Color images just hold more information than grayscale ones.</p>
<div id="62af580a" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>ballImg <span class="op">=</span> cv2.imread(<span class="st">"BallFinding/Green/Green1BG1Mid.jpg"</span>)</span>
<span id="cb7-2"><a href="#cb7-2"></a>grayBall <span class="op">=</span> cv2.cvtColor(ballImg, cv2.COLOR_BGR2GRAY)</span>
<span id="cb7-3"><a href="#cb7-3"></a>hsvBall <span class="op">=</span> cv2.cvtColor(ballImg, cv2.COLOR_BGR2HSV)</span>
<span id="cb7-4"><a href="#cb7-4"></a>threshImg1 <span class="op">=</span> cv2.inRange(hsvBall, (<span class="dv">45</span>, <span class="dv">10</span>, <span class="dv">0</span>), (<span class="dv">65</span>, <span class="dv">255</span>, <span class="dv">255</span>))</span>
<span id="cb7-5"><a href="#cb7-5"></a>res, threshImg2 <span class="op">=</span> cv2.threshold(grayBall, <span class="dv">128</span>,<span class="dv">255</span>, cv2.THRESH_BINARY<span class="op">+</span>cv2.THRESH_OTSU)</span>
<span id="cb7-6"><a href="#cb7-6"></a></span>
<span id="cb7-7"><a href="#cb7-7"></a>cv2.imshow(<span class="st">"inRange"</span>, threshImg1)</span>
<span id="cb7-8"><a href="#cb7-8"></a>cv2.imshow(<span class="st">"threshold"</span>, threshImg2)</span>
<span id="cb7-9"><a href="#cb7-9"></a>cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><a href="#fig-inRangeExamps" class="quarto-xref">Figure&nbsp;9</a> shows the original image, the grayscale version, and then the results of the calls to <code>inRange</code> and <code>threshold</code>.</p>
<div id="fig-inRangeExamps" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-inRangeExamps-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/Green1BG1Mid.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-29" title="Original image"><img src="Ch4-Images/Green1BG1Mid.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Original image</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/ballGray.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-30" title="Grayscale version"><img src="Ch4-Images/ballGray.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Grayscale version</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/ballInRange.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-31" title="Result of inRange"><img src="Ch4-Images/ballInRange.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of <code>inRange</code></figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/ballThreshold.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-32" title="Result of threshold with OTSU"><img src="Ch4-Images/ballThreshold.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of <code>threshold</code> with OTSU</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-inRangeExamps-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9: Using <code>inRange</code> and <code>theshold</code> on an image, seeking to isolate the green ball from the rest of the image
</figcaption>
</figure>
</div>
<p>We encourage you to try this on some of the different colors of balls in the <code>BallFinding</code> folder. There are two main drawbacks to this method:</p>
<ul>
<li>Careful tuning of the lower and upper bounds can mean that you can isolate the ball well in this image, but not in others (so it’s best to test your program on multiple images, or even the frames of a video).</li>
<li>Determining the right range of hue values is tricky or time-consuming; you must either:
<ul>
<li>Open a color picker that displays HSV in your browser, then hand-match the color to the ball’s color (then remember to divide the hue values by 2 for OpenCV’s version of HSV)</li>
<li>Figure out an ROI that covers the ball, and print its hue values</li>
</ul></li>
</ul>
<p>In the next section, we will look at another method for building threshold, or near-threshold images, using a histogram of hue values. With this method, called <strong>backprojection</strong>, we can even isolate multicolored objects to some extent.</p>
</section>
<section id="pseudo-thresholds-with-histograms-and-backprojection" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Pseudo-thresholds with histograms and backprojection</h1>
<p>With grayscale threshold methods, we focused on the brightness of the pixels: keeping only the pixels brighter, or darker, than our threshold value. With the <code>inRange</code> color thresholding, we have to give ranges of each channel, and we keep only the pixels that fall inside all three ranges. With backprojection, we will collect the hue values from a region of interest, and use those to build a histogram of hue values. Then we will keep the pixels whose hue values match our histogram. Let’s break that process down into a series of steps.</p>
<section id="making-a-reference-image-or-roi" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="making-a-reference-image-or-roi"><span class="header-section-number">5.1</span> Making a reference image or ROI</h2>
<p>To build a histogram that represent the color(s) we want to match, we need a <em>reference image</em> that contains the colors of the object we want to detect, and <em>no other colors</em>. How can we make such a reference image?</p>
<p>There are two main methods for making a simple reference image. One just uses your operating system’s tools, and the other works within Python and OpenCV.</p>
<p><strong>Using the operating system:</strong></p>
<ul>
<li>Outside of OpenCV/Python, take a picture of the object in question (On the Mac, you could use Photobooth, on Windows, use the Camera app).</li>
<li>Open the image in the system’s default image viewer (Preview on the Mac, Photos on Windows).</li>
<li>Use the application’s tool to crop the image so all remaining pixels are part of the object (no background or extraneous objects)</li>
<li>Save the resulting image, and place it where you can load it into your Python program with OpenCV</li>
</ul>
<p><strong>Using OpenCV:</strong></p>
<ul>
<li>Determine a region of interest that includes as much as possible of the object, and no background or extraneous pixels</li>
<li>Slice the ROI from the original image</li>
<li>Save the result to a file with <code>imwrite</code></li>
</ul>
<p>The first step is the tricky one. How do you determine the indices to use for the right ROI? You could use <em>guess and check</em>, but this is also an point where you could learn about the tools in OpenCV for responding to the mouse. The program shown below uses mouse clicks to select the upper left and then lower right corner of a rectangular region. It prints those points. The user can reset the rectangle selection by hitting the space bar.</p>
<div id="0bf8b357" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="im">import</span> cv2</span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a>startPt <span class="op">=</span> <span class="va">None</span>                                  <span class="co">#1</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>endPt <span class="op">=</span> <span class="va">None</span>                                    <span class="co">#1</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>selected <span class="op">=</span> <span class="va">False</span>                                <span class="co">#1</span></span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="kw">def</span> selectROI(event, x, y, flags, param):</span>
<span id="cb8-8"><a href="#cb8-8"></a>    <span class="co">"""This is a mouse callback function. ..."""</span>      <span class="co">#2</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>    <span class="kw">global</span> startPt, endPt, selected                   <span class="co">#3</span></span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a>    <span class="cf">if</span> event <span class="op">==</span> cv2.EVENT_LBUTTONUP:</span>
<span id="cb8-12"><a href="#cb8-12"></a>        <span class="co"># If user just clicked and released the left mouse button...</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>        <span class="cf">if</span> startPt <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb8-14"><a href="#cb8-14"></a>            startPt <span class="op">=</span> (x, y)</span>
<span id="cb8-15"><a href="#cb8-15"></a>        <span class="cf">else</span>:</span>
<span id="cb8-16"><a href="#cb8-16"></a>            endPt <span class="op">=</span> (x, y)</span>
<span id="cb8-17"><a href="#cb8-17"></a>            selected <span class="op">=</span> <span class="va">True</span></span>
<span id="cb8-18"><a href="#cb8-18"></a></span>
<span id="cb8-19"><a href="#cb8-19"></a><span class="kw">def</span> runSelection(mainImg):</span>
<span id="cb8-20"><a href="#cb8-20"></a>    <span class="co">"""Takes in an image, and loops while user selects regions."""</span></span>
<span id="cb8-21"><a href="#cb8-21"></a>    <span class="kw">global</span> startPt, endPt, selected</span>
<span id="cb8-22"><a href="#cb8-22"></a></span>
<span id="cb8-23"><a href="#cb8-23"></a>    cv2.namedWindow(<span class="st">'Image'</span>)</span>
<span id="cb8-24"><a href="#cb8-24"></a>    cv2.setMouseCallback(<span class="st">'Image'</span>, selectROI)                 <span class="co">#4</span></span>
<span id="cb8-25"><a href="#cb8-25"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb8-26"><a href="#cb8-26"></a>        workingCopy <span class="op">=</span> mainImg.copy()                         <span class="co">#5</span></span>
<span id="cb8-27"><a href="#cb8-27"></a>        <span class="cf">if</span> selected:                                         <span class="co">#6</span></span>
<span id="cb8-28"><a href="#cb8-28"></a>            <span class="bu">print</span>(startPt, endPt)</span>
<span id="cb8-29"><a href="#cb8-29"></a>            cv2.rectangle(workingCopy, startPt, endPt, (<span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">255</span>), <span class="dv">2</span>)</span>
<span id="cb8-30"><a href="#cb8-30"></a>        cv2.imshow(<span class="st">"Image"</span>, workingCopy)</span>
<span id="cb8-31"><a href="#cb8-31"></a>        x <span class="op">=</span> cv2.waitKey(<span class="dv">10</span>)</span>
<span id="cb8-32"><a href="#cb8-32"></a>        <span class="cf">if</span> x <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb8-33"><a href="#cb8-33"></a>            <span class="cf">if</span> <span class="bu">chr</span>(x) <span class="op">==</span> <span class="st">'q'</span>:</span>
<span id="cb8-34"><a href="#cb8-34"></a>                <span class="cf">break</span></span>
<span id="cb8-35"><a href="#cb8-35"></a>            <span class="cf">elif</span> <span class="bu">chr</span>(x) <span class="op">==</span> <span class="st">' '</span>:                             <span class="co">#7</span></span>
<span id="cb8-36"><a href="#cb8-36"></a>                selected <span class="op">=</span> <span class="va">False</span></span>
<span id="cb8-37"><a href="#cb8-37"></a>                startPt <span class="op">=</span> <span class="va">None</span></span>
<span id="cb8-38"><a href="#cb8-38"></a>                endPt <span class="op">=</span> <span class="va">None</span></span>
<span id="cb8-39"><a href="#cb8-39"></a></span>
<span id="cb8-40"><a href="#cb8-40"></a>img <span class="op">=</span> cv2.imread(<span class="st">"BallFinding/Pink/PinkBG1Mid.jpg"</span>)</span>
<span id="cb8-41"><a href="#cb8-41"></a>runSelection(img)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ol type="1">
<li>Sets up global variables to let the callback function communicate with the main program</li>
<li>The callback function runs separately from the main program, every mouse event triggers this function to run</li>
<li>When using global variables inside a function, it is good style to declare them explicitly this way</li>
<li>This sets up the callback function to respond to mouse events</li>
<li>We copy the image so that drawing doesn’t change the original</li>
<li>Set to <code>True</code> only when both points have been selected</li>
<li>If user hits space, then globals are reset</li>
</ol>
<p>You can also find this program in <a href="Ch4-Images/selectROI.py"><code>selectROI.py</code></a> with additional comments added.</p>
<p><a href="#fig-pinkROI" class="quarto-xref">Figure&nbsp;10</a> shows the original pink ball picture from <code>BallFinding</code>, along with a good ROI selected using the <code>selectROI.py</code> program.</p>
<div id="fig-pinkROI" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-pinkROI-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/PinkBG1Mid.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-33" title="Original image"><img src="Ch4-Images/PinkBG1Mid.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Original image</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/referencePic.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-34" title="ROI selected for this image"><img src="Ch4-Images/referencePic.jpg" class="img-fluid figure-img"></a></p>
<figcaption>ROI selected for this image</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pinkROI-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10: Original image, and reference image for pink ball selected from the original.
</figcaption>
</figure>
</div>
</section>
<section id="building-a-histogram-of-hues-from-reference-image" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="building-a-histogram-of-hues-from-reference-image"><span class="header-section-number">5.2</span> Building a histogram of hues from reference image</h2>
<p>The next step in the backprojection process is to build a histogram of hue values from the reference image. A <em>histogram</em> is used to count how frequently each range of hues occurs. Rather than having an entry for each possible value, we make <em>bins</em> that hold equal sized sequences of values. For instance, if we made 18 bins for the 180 hue values, then each bin would cover 10 hue values: bin 0 would count values between 0 and 9, bin 1 would count between 10 and 19, and so forth. (See <a href="https://en.wikipedia.org/wiki/Histogram">Wikipedia article on Histograms</a> if you don’t remember what a histogram is.)</p>
<p>Below is a code example that shows how to take a reference image and construct a histogram from it. You don’t need to understand the <code>show_hist</code> function right now: it takes a histogram (represented as a one-dimensional Numpy array) and it displays the histogram as a bar chart.</p>
<div id="741996a8" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="im">import</span> cv2</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="kw">def</span> show_hist(hist):</span>
<span id="cb9-5"><a href="#cb9-5"></a>    <span class="co">"""Takes in the histogram, and displays it in the hist window."""</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>    bin_count <span class="op">=</span> hist.shape[<span class="dv">0</span>]</span>
<span id="cb9-7"><a href="#cb9-7"></a>    bin_w <span class="op">=</span> <span class="dv">24</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>    img <span class="op">=</span> np.zeros((<span class="dv">256</span>, bin_count <span class="op">*</span> bin_w, <span class="dv">3</span>), np.uint8)</span>
<span id="cb9-9"><a href="#cb9-9"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(bin_count):</span>
<span id="cb9-10"><a href="#cb9-10"></a>        h <span class="op">=</span> <span class="bu">int</span>(hist[i])</span>
<span id="cb9-11"><a href="#cb9-11"></a>        cv2.rectangle(img, (i <span class="op">*</span> bin_w <span class="op">+</span> <span class="dv">2</span>, <span class="dv">255</span>), ((i <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> bin_w <span class="op">-</span> <span class="dv">2</span>, <span class="dv">255</span> <span class="op">-</span> h), (<span class="bu">int</span>(<span class="fl">180.0</span> <span class="op">*</span> i <span class="op">/</span> bin_count), <span class="dv">255</span>, <span class="dv">255</span>),</span>
<span id="cb9-12"><a href="#cb9-12"></a>                      <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb9-13"><a href="#cb9-13"></a>    img <span class="op">=</span> cv2.cvtColor(img, cv2.COLOR_HSV2BGR)</span>
<span id="cb9-14"><a href="#cb9-14"></a>    cv2.imshow(<span class="st">'hist'</span>, img)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="c6327399" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="annotated-cell-11"><pre class="sourceCode numberSource python code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-11-1"><a href="#annotated-cell-11-1"></a>refImg <span class="op">=</span> cv2.imread(<span class="st">"referencePic.jpg"</span>)</span>
<span id="annotated-cell-11-2"><a href="#annotated-cell-11-2"></a>cv2.imshow(<span class="st">"Ref img"</span>, refImg)</span>
<span id="annotated-cell-11-3"><a href="#annotated-cell-11-3"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-11" data-target-annotation="1">1</button><span id="annotated-cell-11-4" class="code-annotation-target"><a href="#annotated-cell-11-4"></a>histImage <span class="op">=</span> cv2.cvtColor(refImg, cv2.COLOR_BGR2HSV)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-11" data-target-annotation="2">2</button><span id="annotated-cell-11-5" class="code-annotation-target"><a href="#annotated-cell-11-5"></a>hist <span class="op">=</span> cv2.calcHist([histImage], [<span class="dv">0</span>], <span class="va">None</span>, [<span class="dv">18</span>], [<span class="dv">0</span>, <span class="dv">180</span>])</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-11" data-target-annotation="3">3</button><span id="annotated-cell-11-6" class="code-annotation-target"><a href="#annotated-cell-11-6"></a>cv2.normalize(hist, hist, <span class="dv">0</span>, <span class="dv">255</span>, cv2.NORM_MINMAX)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-11" data-target-annotation="4">4</button><span id="annotated-cell-11-7" class="code-annotation-target"><a href="#annotated-cell-11-7"></a>hist <span class="op">=</span> hist.reshape(<span class="op">-</span><span class="dv">1</span>)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-11" data-target-annotation="5">5</button><span id="annotated-cell-11-8" class="code-annotation-target"><a href="#annotated-cell-11-8"></a>show_hist(hist)</span>
<span id="annotated-cell-11-9"><a href="#annotated-cell-11-9"></a></span>
<span id="annotated-cell-11-10"><a href="#annotated-cell-11-10"></a>cv2.waitKey()</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-11" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-11" data-code-lines="4" data-code-annotation="1">Convert the reference images into HSV format</span>
</dd>
<dt data-target-cell="annotated-cell-11" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-11" data-code-lines="5" data-code-annotation="2">Calculate the histogram on the HSV image, looking only at the 0 channel (hue), with no mask, 18 bins, and values that range between 0 and 180</span>
</dd>
<dt data-target-cell="annotated-cell-11" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-11" data-code-lines="6" data-code-annotation="3">Rescale the histogram so that the minimum value is 0 and the maximum is 255</span>
</dd>
<dt data-target-cell="annotated-cell-11" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-11" data-code-lines="7" data-code-annotation="4">Change from a column vector (18 rows and 1 column), to a row vector (1 row, 18 values)</span>
</dd>
<dt data-target-cell="annotated-cell-11" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-11" data-code-lines="8" data-code-annotation="5">Display the histogram as an image</span>
</dd>
</dl>
</div>
</div>
<p>The <code>calcHist</code> function is the most important, and complex, step in this code. It has five required inputs:</p>
<ul>
<li>First, it takes in a list of images, here we pass just one, but we have to pass it as a list containing one image.</li>
<li>Second, we specify which channels of the image we want to build the histogram from (in this case just the 0, hue, channel).</li>
<li>Third, we could pass in a mask, if we wanted to, but we pass in <code>None</code> to indicate we don’t want to apply a mask.</li>
<li>Fourth, we specify the number of bins for the histogram (the function will divide the range of values as evenly as it can across the bins).</li>
<li>Fifth, we specify the range of values, from 0 to 180 in this case.</li>
</ul>
<p><strong>Normalization</strong>, in computer vision, and in computer science more broadly, is the process of rescaling some collection of data so that the data values fall within a specified, canonical range. Here, we want to rescale height of the histogram data so that the maximum height of any bar is 255, and the minimum is 0. This will be needed for the next, and final, step, where we compute the backprojection.</p>
<p><a href="#fig-pinkHist" class="quarto-xref">Figure&nbsp;11</a> shows the histogram we would get if we selected a reference image for the ball in the earlier example.</p>
<div id="fig-pinkHist" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-pinkHist-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="Ch4-Images/pinkHist.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-35" title="Figure&nbsp;11: Histogram for pink reference image"><img src="Ch4-Images/pinkHist.jpg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pinkHist-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11: Histogram for pink reference image
</figcaption>
</figure>
</div>
</section>
<section id="computing-the-backprojection" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="computing-the-backprojection"><span class="header-section-number">5.3</span> Computing the backprojection</h2>
<p>The backprojection algorithm treats the histogram we calculated as a <em>probability distribution</em>: the height of a bar represents the probability that the hues in that range match the reference image.</p>
<p>We apply this idea to our current image: for each pixel, we look at its hue and determine which bin of the histogram it falls into. We then use the value/height of that bin as the value in our backprojection image. The result is a threshold image, although often one with grayscale values as well as black and white. Pixels that match our reference hues are non-zero, with brighter pixels falling into the tallest bin.</p>
<div id="b864c410" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a>bpImg <span class="op">=</span> cv2.calcBackProject([hsvImage], [<span class="dv">0</span>], hist, [<span class="dv">0</span>, <span class="dv">180</span>], <span class="dv">1</span>)</span>
<span id="cb10-2"><a href="#cb10-2"></a>cv2.imshow(<span class="st">"Backproject"</span>, bpImg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The <code>calcBackProject</code> function takes in a list of images (they must be in HSV since our histogram is in HSV), a list of the channels to apply the backprojection to (just the hue channel, here), the histogram itself, the range of hue values, and an optional scaling factor, to modify the size of the output image.</p>
<p><a href="#fig-backproj" class="quarto-xref">Figure&nbsp;12</a> shows the result of computing the backprojection using the histogram from the previous step.</p>
<div id="fig-backproj" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-backproj-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="Ch4-Images/backproject.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-36" title="Figure&nbsp;12: Backprojection for pink reference image applied to original"><img src="Ch4-Images/backproject.jpg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-backproj-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;12: Backprojection for pink reference image applied to original
</figcaption>
</figure>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
        for (let i=0; i<annoteTargets.length; i++) {
          const annoteTarget = annoteTargets[i];
          const targetCell = annoteTarget.getAttribute("data-target-cell");
          const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
          const contentFn = () => {
            const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
            if (content) {
              const tipContent = content.cloneNode(true);
              tipContent.classList.add("code-annotation-tip-content");
              return tipContent.outerHTML;
            }
          }
          const config = {
            allowHTML: true,
            content: contentFn,
            onShow: (instance) => {
              selectCodeLines(instance.reference);
              instance.reference.classList.add('code-annotation-active');
              window.tippy.hideAll();
            },
            onHide: (instance) => {
              unselectCodeLines();
              instance.reference.classList.remove('code-annotation-active');
            },
            maxWidth: 300,
            delay: [50, 0],
            duration: [200, 0],
            offset: [5, 10],
            arrow: true,
            appendTo: function(el) {
              return el.parentElement.parentElement.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'quarto',
            placement: 'right',
            popperOptions: {
              modifiers: [
              {
                name: 'flip',
                options: {
                  flipVariations: false, // true by default
                  allowedAutoPlacements: ['right'],
                  fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
                },
              },
              {
                name: 'preventOverflow',
                options: {
                  mainAxis: false,
                  altAxis: false
                }
              }
              ]        
            }      
          };
          window.tippy(annoteTarget, config); 
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>