<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Susan Eileen Fox">
<meta name="dcterms.date" content="2025-08-11">

<title>Chapter 4, Image Transformations</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Chapter4_files/libs/clipboard/clipboard.min.js"></script>
<script src="Chapter4_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Chapter4_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Chapter4_files/libs/quarto-html/popper.min.js"></script>
<script src="Chapter4_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Chapter4_files/libs/quarto-html/anchor.min.js"></script>
<link href="Chapter4_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Chapter4_files/libs/quarto-html/quarto-syntax-highlighting-226bd0f977fa82dfae4534cac220d79a.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Chapter4_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Chapter4_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Chapter4_files/libs/bootstrap/bootstrap-c9dc05ccd9e6568c662515419180efc4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="Chapter4_files/libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="Chapter4_files/libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="Chapter4_files/libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#masking-images" id="toc-masking-images" class="nav-link active" data-scroll-target="#masking-images"><span class="header-section-number">1</span> Masking images</a>
  <ul class="collapse">
  <li><a href="#three-channel-versus-one-channel-masks" id="toc-three-channel-versus-one-channel-masks" class="nav-link" data-scroll-target="#three-channel-versus-one-channel-masks"><span class="header-section-number">1.1</span> Three-channel versus one-channel masks</a></li>
  <li><a href="#masks-built-from-image-features" id="toc-masks-built-from-image-features" class="nav-link" data-scroll-target="#masks-built-from-image-features"><span class="header-section-number">1.2</span> Masks built from image features</a></li>
  </ul></li>
  <li><a href="#converting-images-from-bgr-to-other-color-representations" id="toc-converting-images-from-bgr-to-other-color-representations" class="nav-link" data-scroll-target="#converting-images-from-bgr-to-other-color-representations"><span class="header-section-number">2</span> Converting images from ‘BGR’ to other color representations</a></li>
  <li><a href="#thresholds-from-grayscale-images" id="toc-thresholds-from-grayscale-images" class="nav-link" data-scroll-target="#thresholds-from-grayscale-images"><span class="header-section-number">3</span> Thresholds from grayscale images</a>
  <ul class="collapse">
  <li><a href="#the-threshold-function" id="toc-the-threshold-function" class="nav-link" data-scroll-target="#the-threshold-function"><span class="header-section-number">3.1</span> The <code>threshold</code> function</a></li>
  <li><a href="#adaptive-threshold" id="toc-adaptive-threshold" class="nav-link" data-scroll-target="#adaptive-threshold"><span class="header-section-number">3.2</span> Adaptive threshold</a></li>
  </ul></li>
  <li><a href="#thresholds-from-color-images" id="toc-thresholds-from-color-images" class="nav-link" data-scroll-target="#thresholds-from-color-images"><span class="header-section-number">4</span> Thresholds from color images</a></li>
  <li><a href="#pseudo-thresholds-with-histograms-and-backprojection" id="toc-pseudo-thresholds-with-histograms-and-backprojection" class="nav-link" data-scroll-target="#pseudo-thresholds-with-histograms-and-backprojection"><span class="header-section-number">5</span> Pseudo-thresholds with histograms and backprojection</a>
  <ul class="collapse">
  <li><a href="#making-a-reference-image-or-roi" id="toc-making-a-reference-image-or-roi" class="nav-link" data-scroll-target="#making-a-reference-image-or-roi"><span class="header-section-number">5.1</span> Making a reference image or ROI</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Chapter 4, Image Transformations</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Susan Eileen Fox </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 11, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>In this chapter, we will examine a variety of methods for <strong>transforming</strong> images: taking in an image, and producing a new, changed image. We will start with masks and threshold images, and then examine <strong>geometric transformations</strong> including resizing images, translating and rotating image contents, and warping, a more general way of twisting and stretching the contents of an image. We will also laearn about different kinds of <strong>filters</strong>, including blurring, morphological filters, and edge detection.</p>
<section id="masking-images" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Masking images</h1>
<p>When we <strong>mask</strong> an image, we cover over portions of the image, allowing only selected portions to be visible. To mask an image, we must first create a <em>mask image</em>: a special image that has only black and white pixels. The black portions of the mask image are where we will cover up the original image, and the white portions are where we will let the original image show through.</p>
<p>One way to picture this process, is to imagine we have a printed photograph of some kind. If we take a black sheet of paper, and cut holes in it, and then lay it over the printed photograph, that is what masking does. The white parts of the mask image are the holes in the black paper.</p>
<p>There are multiple ways of creating masks. The most simple is to just make a black image and then draw on it the regions we can to keep in the original image. The code example below does exactly this, using OpenCV’s drawing functions to create a black and white mask image.</p>
<div id="f3c3b6f3" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> cv2</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a>origImg <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/grandTeton.jpg"</span>)</span>
<span id="cb1-5"><a href="#cb1-5"></a>maskImg <span class="op">=</span> np.zeros(origImg.shape, origImg.dtype)   <span class="co"># Makes a copy the same size and type, but all zeros, so black</span></span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co"># draw a rectangular region on the mask, and a line of circles</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>cv2.rectangle(maskImg, (<span class="dv">75</span>, <span class="dv">320</span>), (<span class="dv">565</span>, <span class="dv">565</span>), (<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span> (<span class="dv">160</span>, <span class="dv">640</span>, <span class="dv">160</span>):</span>
<span id="cb1-10"><a href="#cb1-10"></a>    cv2.circle(maskImg, (x, <span class="dv">160</span>), <span class="dv">50</span>, (<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a>cv2.imshow(<span class="st">"Original"</span>, origImg)</span>
<span id="cb1-13"><a href="#cb1-13"></a>cv2.imshow(<span class="st">"Mask"</span>, maskImg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><a href="#fig-buildMask" class="quarto-xref">Figure&nbsp;1</a> shows the original image and the mask image constructed by the code.</p>
<div id="fig-buildMask" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-buildMask-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/grandTetons.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Original image"><img src="Ch4-Images/grandTetons.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Original image</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/MaskImg.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Mask image with additions"><img src="Ch4-Images/MaskImg.png" class="img-fluid figure-img"></a></p>
<figcaption>Mask image with additions</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-buildMask-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Original image, and mask image with rectangle and circles on it
</figcaption>
</figure>
</div>
<p>To apply the mask to the original image, we will use the OpenCV function <code>bitwise_and</code>. This is an arithmetic function on images. It takes two images the same size and shape, and it combines them using the bitwise and operation. You don’t need to know all the details, just this: <strong>bitwise-and of a color and white returns the color, bitwise-and of a color and black returns black.</strong> This gives us the effect we want: the original colors where the mask was white, and black where the mask was black. Below is a continuation of the script above showing how to apply the mask, and <a href="#fig-maskresult" class="quarto-xref">Figure&nbsp;2</a> shows the result of this operation.</p>
<div id="0d551b1c" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># apply mask</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>maskedImage <span class="op">=</span> cv2.bitwise_and(origImg, maskImg)</span>
<span id="cb2-3"><a href="#cb2-3"></a>cv2.imshow(<span class="st">"Mask result"</span>, maskedImage)</span>
<span id="cb2-4"><a href="#cb2-4"></a>cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-maskresult" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-maskresult-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="Ch4-Images/MaskResult.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Figure&nbsp;2: Result of applying the mask above to the original image"><img src="Ch4-Images/MaskResult.png" class="img-fluid figure-img" style="width:12cm"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-maskresult-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Result of applying the mask above to the original image
</figcaption>
</figure>
</div>
<section id="three-channel-versus-one-channel-masks" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="three-channel-versus-one-channel-masks"><span class="header-section-number">1.1</span> Three-channel versus one-channel masks</h2>
<p>The mask image above was created as a color image, with three channels. If the only colors in a mask are white or black, we don’t really need all three channels. However, when we have a one-channel mask, applying it to the image is a little bit different.</p>
<p>The script below demonstrates several ideas:</p>
<ul>
<li>How to apply a mask to frames of a video feed</li>
<li>How to apply a one-channel mask to a color image</li>
<li>How to make a square bounce around a window</li>
</ul>
<p>We’ll discuss each of these ideas as they appear in the code below.</p>
<div id="7baab25e" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="annotated-cell-3"><pre class="sourceCode numberSource python code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-3-1"><a href="#annotated-cell-3-1"></a>vidCap <span class="op">=</span> cv2.VideoCapture(<span class="dv">0</span>)</span>
<span id="annotated-cell-3-2"><a href="#annotated-cell-3-2"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="1">1</button><span id="annotated-cell-3-3" class="code-annotation-target"><a href="#annotated-cell-3-3"></a>sqrX <span class="op">=</span> <span class="dv">50</span></span>
<span id="annotated-cell-3-4"><a href="#annotated-cell-3-4"></a>sqrY <span class="op">=</span> <span class="dv">50</span></span>
<span id="annotated-cell-3-5"><a href="#annotated-cell-3-5"></a>deltaX <span class="op">=</span> <span class="dv">5</span></span>
<span id="annotated-cell-3-6"><a href="#annotated-cell-3-6"></a>deltaY <span class="op">=</span> <span class="dv">5</span></span>
<span id="annotated-cell-3-7"><a href="#annotated-cell-3-7"></a>sqSize <span class="op">=</span> <span class="dv">400</span></span>
<span id="annotated-cell-3-8"><a href="#annotated-cell-3-8"></a></span>
<span id="annotated-cell-3-9"><a href="#annotated-cell-3-9"></a><span class="cf">while</span> <span class="va">True</span>:</span>
<span id="annotated-cell-3-10"><a href="#annotated-cell-3-10"></a>    res, frame <span class="op">=</span> vidCap.read()</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="2">2</button><span id="annotated-cell-3-11" class="code-annotation-target"><a href="#annotated-cell-3-11"></a>    (hgt, wid, dep)<span class="op">=</span> frame.shape</span>
<span id="annotated-cell-3-12"><a href="#annotated-cell-3-12"></a>    </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="3">3</button><span id="annotated-cell-3-13" class="code-annotation-target"><a href="#annotated-cell-3-13"></a>    <span class="co"># make mask a grayscale image (one channel)</span></span>
<span id="annotated-cell-3-14"><a href="#annotated-cell-3-14"></a>    maskIm <span class="op">=</span> np.zeros((hgt, wid), np.uint8)</span>
<span id="annotated-cell-3-15"><a href="#annotated-cell-3-15"></a>    cv2.rectangle(maskIm, (sqrX, sqrY), (sqrX <span class="op">+</span> sqSize, sqrY <span class="op">+</span> sqSize), <span class="dv">255</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="annotated-cell-3-16"><a href="#annotated-cell-3-16"></a>    </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="4">4</button><span id="annotated-cell-3-17" class="code-annotation-target"><a href="#annotated-cell-3-17"></a>    maskedFrame <span class="op">=</span> cv2.bitwise_and(frame, frame, mask<span class="op">=</span>maskIm)</span>
<span id="annotated-cell-3-18"><a href="#annotated-cell-3-18"></a>    </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="5">5</button><span id="annotated-cell-3-19" class="code-annotation-target"><a href="#annotated-cell-3-19"></a>    cv2.imshow(<span class="st">"Moving Mask"</span>, maskedFrame)</span>
<span id="annotated-cell-3-20"><a href="#annotated-cell-3-20"></a>    x <span class="op">=</span> cv2.waitKey(<span class="dv">10</span>)</span>
<span id="annotated-cell-3-21"><a href="#annotated-cell-3-21"></a>    <span class="cf">if</span> x <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="annotated-cell-3-22"><a href="#annotated-cell-3-22"></a>        <span class="cf">if</span> <span class="bu">chr</span>(x) <span class="op">==</span> <span class="st">'q'</span>:</span>
<span id="annotated-cell-3-23"><a href="#annotated-cell-3-23"></a>            <span class="cf">break</span></span>
<span id="annotated-cell-3-24"><a href="#annotated-cell-3-24"></a>    </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="6">6</button><span id="annotated-cell-3-25" class="code-annotation-target"><a href="#annotated-cell-3-25"></a>    <span class="cf">if</span> (sqrX <span class="op">+</span> sqSize <span class="op">&gt;=</span> wid) <span class="kw">or</span> (sqrX <span class="op">&lt;=</span> <span class="dv">0</span>):</span>
<span id="annotated-cell-3-26"><a href="#annotated-cell-3-26"></a>        deltaX <span class="op">=</span> <span class="op">-</span>deltaX</span>
<span id="annotated-cell-3-27"><a href="#annotated-cell-3-27"></a>    <span class="cf">if</span> (sqrY <span class="op">+</span> sqSize <span class="op">&gt;=</span> hgt) <span class="kw">or</span> (sqrY <span class="op">&lt;=</span> <span class="dv">0</span>):</span>
<span id="annotated-cell-3-28"><a href="#annotated-cell-3-28"></a>        deltaY <span class="op">=</span> <span class="op">-</span>deltaY</span>
<span id="annotated-cell-3-29"><a href="#annotated-cell-3-29"></a>    </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="7">7</button><span id="annotated-cell-3-30" class="code-annotation-target"><a href="#annotated-cell-3-30"></a>    sqrX <span class="op">+=</span> deltaX</span>
<span id="annotated-cell-3-31"><a href="#annotated-cell-3-31"></a>    sqrY <span class="op">+=</span> deltaY</span>
<span id="annotated-cell-3-32"><a href="#annotated-cell-3-32"></a></span>
<span id="annotated-cell-3-33"><a href="#annotated-cell-3-33"></a>vidCap.release()</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-3" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="3,4,5,6,7" data-code-annotation="1">Sets up variables to hold the size and position of the mask square, and how fast it will change from one frame to the other</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="11" data-code-annotation="2">Gets the shape of the frame into <code>hgt</code> and <code>wid</code> variables, so we can make a one-channel mask</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="13,14,15" data-code-annotation="3">Creates the mask and draws a white square on it</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="17" data-code-annotation="4">Applies the mask to the frame from the camera feed (or video file), using the <code>mask</code> input</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="19" data-code-annotation="5">Displays the result</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="25,26,27,28" data-code-annotation="6">Changes <code>deltaX</code> and/or <code>deltaY</code> if the square gets to any of the four edges of the picture; causes the square to change the direction it moves</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="7">7</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="30,31" data-code-annotation="7">Updates the position of the square for the next frame, by adding <code>deltaX</code> to <code>sqrX</code> and <code>deltaY</code> to <code>sqrY</code></span>
</dd>
</dl>
</div>
</div>
<p>The first part of the <code>while</code> loop creates the mask with one white square, and applies it to the original image. To understand how one-channel masks can be applied to an image, focus on <strong>line 17</strong>. We cannot just call <code>bitwise_and</code> and pass it the original frame and the mask, because <code>bitwise_and</code> requires that the two images passed to it are the same shape. <em>However,</em> <code>bitwise_and</code> takes an optional input called <code>mask</code>, which specifies a one-channel mask, which is applied to the result of the bitwise-and operation. So we pass the original frame in for both ordinary inputs (bitwise-and applied to two identical images produces the image itself again). And then the mask gets applied in a separate step. <strong>This is cryptic and weird, but it works!</strong></p>
<p>The last idea in this code, making a shape bounce around a window, is just for fun, and to emphasize that for each frame in the video feed, we compute and apply a new mask. The key to moving the square is just to change the position of its upper left (x, y) coordinates, which is done at the end of the <code>while</code> loop. To keep the square from just moving out of view, we need to make it bounce back. This sounds daunting, but is actually easy.</p>
<ul>
<li>If the right edge of the square reaches or exceeds the right edge of the image, then we change the <code>deltaX</code> value to be its negative (it will have been +5, after this it will be -5)</li>
<li>If the left edge of the square reaches or exceeds the left edge of the image, then we change <code>deltaX</code> to be its negative (it will have been -5, –5 = +5)</li>
<li>Similar logic for the top and bottom edges</li>
</ul>
<p><strong>Try this code for yourself.</strong> To fully understand this code, you should experiment with changing the accumulator variables (one at a time) that control the position, size, and movement speed of the square. Or change the rectangle to a circle or an ellipse.</p>
</section>
<section id="masks-built-from-image-features" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="masks-built-from-image-features"><span class="header-section-number">1.2</span> Masks built from image features</h2>
<p>Besides building masks as we have done here, by drawing white shapes on a black image, we can also generate mask images using other image transformations. So that the pixels that are white fit some pattern or criteria. There are multiple ways to build masks like this, but we will look at one way in the next section: computing threshold images.</p>
</section>
</section>
<section id="converting-images-from-bgr-to-other-color-representations" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Converting images from ‘BGR’ to other color representations</h1>
<p>Some of our image manipulations will require us to change from the normal BGR representation of an image to other forms, including grayscale and HSV. OpenCV gives us one function that can convert between all the implemented color representations: <code>cvtColor</code>. This function takes in an image and a code that tells it which conversion we want, and it returns the converted image. The script below shows how to convert an image to grayscale and to HSV.</p>
<div id="fb0c157d" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>img <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/mushrooms.jpg"</span>)</span>
<span id="cb3-2"><a href="#cb3-2"></a>grayImg <span class="op">=</span> cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span>
<span id="cb3-3"><a href="#cb3-3"></a>hsvImg <span class="op">=</span> cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</span>
<span id="cb3-4"><a href="#cb3-4"></a>cv2.imshow(<span class="st">"Original"</span>, img)</span>
<span id="cb3-5"><a href="#cb3-5"></a>cv2.imshow(<span class="st">"Grayscale"</span>, grayImg)</span>
<span id="cb3-6"><a href="#cb3-6"></a>cv2.imshow(<span class="st">"HSV - weird!"</span>, hsvImg)</span>
<span id="cb3-7"><a href="#cb3-7"></a>cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><a href="#fig-gray" class="quarto-xref">Figure&nbsp;3</a> shows the original image next to the grayscale version. The <code>imshow</code> function recognizes grayscale images, which have only one channel, and can display them correctly.</p>
<div id="fig-gray" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-gray-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/mushrooms.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Original image"><img src="Ch4-Images/mushrooms.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Original image</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/mushGray.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Grayscale version"><img src="Ch4-Images/mushGray.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Grayscale version</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-gray-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: The original mushrooms picture, and its grayscale version
</figcaption>
</figure>
</div>
<p><strong>A warning about HSV:</strong> HSV images have three channels and use <code>np.uint8</code> as the data type, just like BGR ones. To the computer, these image representations look identical! A function that expects a BGR image and is given an HSV one will interpret the hue channels as a blue channel, the saturation channels as a green one, and the value channel as red. The <code>imshow</code> function assumes that an image with three channels is BGR, so if we try to display an HSV image, we get an odd result, as shown in <a href="#fig-HSV" class="quarto-xref">Figure&nbsp;4</a></p>
<div id="fig-HSV" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-HSV-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="Ch4-Images/mushHSV.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Figure&nbsp;4: Attempt to display the HSV version of the mushrooms image with imshow"><img src="Ch4-Images/mushHSV.jpg" class="img-fluid figure-img" style="width:10cm"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-HSV-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Attempt to display the HSV version of the mushrooms image with <code>imshow</code>
</figcaption>
</figure>
</div>
</section>
<section id="thresholds-from-grayscale-images" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Thresholds from grayscale images</h1>
<p>Threshold functions transform images based on the range of brightness or color values at each pixel. They often produce a black and white image, suitable for use as a mask. And often we can also use the threshold image to locate interesting objects in the image.</p>
<section id="the-threshold-function" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="the-threshold-function"><span class="header-section-number">3.1</span> The <code>threshold</code> function</h2>
<p>The simplest threshold function is called just <code>threshold</code>. It operates on grayscale images, and has multiple modes to choose from. It returns a new grayscale or black and white image.</p>
<p>The <code>threshold</code> function takes in four inputs and returns two results. The four inputs include: a source image, a threshold value (between 0 and 255, a maximum value (also between 0 and 255), and a constant that defines which threshold variant to perform. <a href="#tbl-threshmodes" class="quarto-xref">Table&nbsp;1</a> shows the five main modes for this function.</p>
<p>The binary threshold sets pixels over the threshold value to the maximum value you specify, and under the threshold to zero. The inverse-binary threshold does the opposite.</p>
<p>The truncating threshold sets pixels over the threshold value to the threshold value, and leaves those under the threshold value alone</p>
<p>The “to-zero” threshold sets values below the threshold to zero, while leaving those above the threshold alone, and its inverse sets values over the threshold to zero, leaving those below alone.</p>
<div id="tbl-threshmodes" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-threshmodes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Five threshold modes, which create different results, binary thresholding is most common
</figcaption>
<div aria-describedby="tbl-threshmodes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 28%">
<col style="width: 71%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Threshold operator</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>cv2.THRESH_BINARY</code></td>
<td style="text-align: left;">Values above the threshold are set to the maximum value, values less than or equal to the threshold are set to zero</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>cv2.THRESH_BINARY_INV</code></td>
<td style="text-align: left;">Values above the threshold are set to zero, values less than or equal to the threshold are set to the maximum value</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>cv2.THRESH_TRUNC</code></td>
<td style="text-align: left;">Values above the threshold are set to the threshold value, values less than or equal to the threshold are unchanged</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>cv2.THRESH_TOZERO</code></td>
<td style="text-align: left;">Values above the threshold are left unchanged, values less than or equal to the threshold are set to zero</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>cv2.THRESH_TOZERO_INV</code></td>
<td style="text-align: left;">Values above the threshold are set to zero, values less than or equal to the threshold are left unchanged</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>The <code>threshold</code> function returns two values. The first returned value is the threshold value. This may seem odd, but the function has optional add-ons that use particularly algorithms to guess at the most useful threshold value, so in that case we do want the function to tell us the value the algorithm chose. The second returned value is the threshold image itself.</p>
<p>The script below illustrates the <code>threshold</code> function, in all its main variants, on a picture of coins on a red background (found in the <code>Coins</code> folder inside <code>SampleImages</code>). <a href="#fig-threshVariants" class="quarto-xref">Figure&nbsp;9</a> shows the original image, its grayscale counterpart, and then all the five variants.</p>
<div id="186a81e1" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>coinImg <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/Coins/coins6.jpg"</span>)</span>
<span id="cb4-2"><a href="#cb4-2"></a>grayCoin <span class="op">=</span> cv2.cvtColor(coinImg, cv2.COLOR_BGR2GRAY)</span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a>cv2.imshow(<span class="st">"Original"</span>, coinImg)</span>
<span id="cb4-5"><a href="#cb4-5"></a>cv2.imshow(<span class="st">"Gray"</span>, grayCoin)</span>
<span id="cb4-6"><a href="#cb4-6"></a>cv2.waitKey()</span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a>threshModes <span class="op">=</span> [cv2.THRESH_BINARY, cv2.THRESH_BINARY_INV, cv2.THRESH_TRUNC, cv2.THRESH_TOZERO, cv2.THRESH_TOZERO_INV]</span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="cf">for</span> threshMode <span class="kw">in</span> threshModes:</span>
<span id="cb4-10"><a href="#cb4-10"></a>    res, threshIm <span class="op">=</span> cv2.threshold(grayCoin, <span class="dv">128</span>, <span class="dv">255</span>, threshMode)</span>
<span id="cb4-11"><a href="#cb4-11"></a>    <span class="bu">print</span>(res)</span>
<span id="cb4-12"><a href="#cb4-12"></a>    cv2.imshow(<span class="st">"Threshed"</span>, threshIm)</span>
<span id="cb4-13"><a href="#cb4-13"></a>    cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-threshVariants" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-threshVariants-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/coins6.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Original image"><img src="Ch4-Images/coins6.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Original image</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/grayCoin.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-8" title="Grayscale version"><img src="Ch4-Images/grayCoin.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Grayscale version</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/threshedBin.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-9" title="Result of threshold with THRESH_BINARY mode"><img src="Ch4-Images/threshedBin.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of threshold with <code>THRESH_BINARY</code> mode</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/threshedBinInv.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-10" title="Result of threshold with THRESH_BINARY_INV mode"><img src="Ch4-Images/threshedBinInv.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of threshold with <code>THRESH_BINARY_INV</code> mode</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/threshedTrunc.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-11" title="Result of threshold with THRESH_TRUNC mode"><img src="Ch4-Images/threshedTrunc.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of threshold with <code>THRESH_TRUNC</code> mode</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/threshedToZero.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-12" title="Result of threshold with THRESH_TOZERO mode"><img src="Ch4-Images/threshedToZero.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of threshold with <code>THRESH_TOZERO</code> mode</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/threshedToZeroInv.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-13" title="Result of threshold with THRESH_TOZERO_INV mode"><img src="Ch4-Images/threshedToZeroInv.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of threshold with <code>THRESH_TOZERO_INV</code> mode</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-threshVariants-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Showing the main variants of the <code>threshold</code> function, all run with threshold value of 128 and max value of 255
</figcaption>
</figure>
</div>
<p>One issue with <code>threshold</code>is determining what the best threshold value is. Algorithms exist that can identify good threshold values for you, and two of them are integrated into the <code>threshold</code> function. The OTSU and Triangle algorithms both build a histogram of the brightness values in a grayscale image. The OTSU algorithm looks for a threshold value that minimizes the variance on each side of the threshold in the histogram. The Triangle algorithm draws a line between the maximum histogram and the minimum one, and finds the point along that line that is maximal distance from values in the histogram, and uses that as the threshold value. (For more information about both algorithms, see <a href="https://en.wikipedia.org/wiki/Otsu%27s_method">OTSU’s Wikipedia page</a>, or <a href="https://stackabuse.com/opencv-thresholding-in-python-with-cv2threshold/">David Landup’s blog on StackAbuse.com</a>).</p>
<p>Below is a variation on the code above that shows how to use OTSU or Triangle, combining it with the binary threshold mode. <a href="#fig-adapt1" class="quarto-xref">Figure&nbsp;6</a> illustrates the results on the coins pictures of each of these algorithms. Note that when we use these algorithms, <code>threshold</code> ignores the input threshold value, and computes its own. It then returns the computed threshold value as its return value.</p>
<div id="8e29634b" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>coinImg <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/Coins/coins6.jpg"</span>)</span>
<span id="cb5-2"><a href="#cb5-2"></a>grayCoin <span class="op">=</span> cv2.cvtColor(coinImg, cv2.COLOR_BGR2GRAY)</span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co"># Adaptive threshold with OTSU and Triangle algorithms</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>adaptMode1 <span class="op">=</span> cv2.THRESH_BINARY <span class="op">+</span> cv2.THRESH_OTSU</span>
<span id="cb5-6"><a href="#cb5-6"></a>adaptMode2 <span class="op">=</span> cv2.THRESH_BINARY <span class="op">+</span> cv2.THRESH_TRIANGLE</span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="cf">for</span> tm <span class="kw">in</span> [adaptMode1, adaptMode2]:</span>
<span id="cb5-8"><a href="#cb5-8"></a>    res, threshIm <span class="op">=</span> cv2.threshold(grayCoin, <span class="dv">128</span>, <span class="dv">255</span>, tm)</span>
<span id="cb5-9"><a href="#cb5-9"></a>    <span class="bu">print</span>(res)</span>
<span id="cb5-10"><a href="#cb5-10"></a>    cv2.imshow(<span class="st">"Threshed"</span>, threshIm)</span>
<span id="cb5-11"><a href="#cb5-11"></a>    cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-adapt1" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-adapt1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/threshedBinOTSU161.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-14" title="Result of threshold with THRESH_BINARY + THRESH_OTSU mode, chose threshold value of 161"><img src="Ch4-Images/threshedBinOTSU161.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of threshold with <code>THRESH_BINARY + THRESH_OTSU</code> mode, chose threshold value of 161</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/threshedBinTriangle105.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-15" title="Result of threshold with THRESH_BINARY + THRESH_TRIANBLE mode, chose threshold value of 105"><img src="Ch4-Images/threshedBinTriangle105.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of threshold with <code>THRESH_BINARY + THRESH_TRIANBLE</code> mode, chose threshold value of 105</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-adapt1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Showing the two adaptive modes for the <code>threshold</code> function, usually added to the binary or to-zero threshold modes.
</figcaption>
</figure>
</div>
<p><strong>Think about this:</strong> Of all of these approaches, which work best on this picture. Experiment with this code, trying it on the other coin pictures in <code>SampleImages</code>. Does the same version or the same threshold, work for all pictures?</p>
</section>
<section id="adaptive-threshold" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="adaptive-threshold"><span class="header-section-number">3.2</span> Adaptive threshold</h2>
<p>The <code>adaptiveThreshold</code> function takes things a step further. Rather than just determining one global threshold value, it throws out the idea of a global threshold value altogether. Instead, it computes an individual threshold value at each small patch in the image (this is really a form of <strong>filtering</strong>, which is the next main subject in this chapter!).</p>
<p>The function does the same operation on every overlapping patch in the image. It computes either a plain average or a weighted average of the brightness values in the patch, and subtracts a constant <code>c</code> that we provide. This value is the threshold value for the center pixel of the patch. thus different parts of the image may have very different threshold values. An input constant selects whether to do a plain average or a <em>Gaussian</em> one. A Gaussian average is a weighted average where the weights form a Gaussian curve (also called a Normal curve, or a bell curve.). <a href="#fig-gauss" class="quarto-xref">Figure&nbsp;7</a> depicts a typical two-dimensional Gaussian curve. We would take</p>
<div id="fig-gauss" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-gauss-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="Ch4-Images/2dGaussPlot.png" class="lightbox" data-gallery="quarto-lightbox-gallery-16" title="Figure&nbsp;7: Two-dimensional Gaussian curve"><img src="Ch4-Images/2dGaussPlot.png" class="img-fluid figure-img" style="width:10cm"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-gauss-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7: Two-dimensional Gaussian curve
</figcaption>
</figure>
</div>
<p>The <code>adaptiveThreshold</code> function takes six (<strong>6!</strong>) inputs, outlined below:</p>
<ul>
<li>The grayscale image to be processed</li>
<li>The maximum value for the thresholding mode</li>
<li>The adaptive effect, one of <code>cv2.ADAPTIVE_THRESH_MEAN_C</code> or <code>cv2.ADAPTIVE_THRESH_GAUSSIAN_C</code> (see discussion above)</li>
<li>The threshold mode, same ones as the <code>threshold</code> function takes</li>
<li>The size in pixels of the patch to use (use an odd number so that there is always a center pixel)</li>
<li>The value of <code>c</code>, a constant that will be subtracted from the average that is computed to produce the threshold value</li>
</ul>
<p>The code example below loops over different values for the patch size (called <code>bSize</code> because patches are called blocks), and different values for the <code>c</code> constant. We often have to experiment to find the right combination of these values to get the result we want.</p>
<div id="d0a3c2ae" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="cf">for</span> bSize <span class="kw">in</span> [<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">11</span>]:</span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="cf">for</span> c <span class="kw">in</span> [<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">20</span>]:</span>
<span id="cb6-3"><a href="#cb6-3"></a>        adaIm1 <span class="op">=</span> cv2.adaptiveThreshold(grayCoin, </span>
<span id="cb6-4"><a href="#cb6-4"></a>                                       <span class="dv">255</span>, </span>
<span id="cb6-5"><a href="#cb6-5"></a>                                       cv2.ADAPTIVE_THRESH_MEAN_C, </span>
<span id="cb6-6"><a href="#cb6-6"></a>                                       cv2.THRESH_BINARY,</span>
<span id="cb6-7"><a href="#cb6-7"></a>                                       bSize,</span>
<span id="cb6-8"><a href="#cb6-8"></a>                                       c)</span>
<span id="cb6-9"><a href="#cb6-9"></a>        adaIm2 <span class="op">=</span> cv2.adaptiveThreshold(grayCoin,</span>
<span id="cb6-10"><a href="#cb6-10"></a>                                       <span class="dv">255</span>, </span>
<span id="cb6-11"><a href="#cb6-11"></a>                                       cv2.ADAPTIVE_THRESH_GAUSSIAN_C, </span>
<span id="cb6-12"><a href="#cb6-12"></a>                                       cv2.THRESH_BINARY,</span>
<span id="cb6-13"><a href="#cb6-13"></a>                                       bSize,</span>
<span id="cb6-14"><a href="#cb6-14"></a>                                       c)</span>
<span id="cb6-15"><a href="#cb6-15"></a>        <span class="bu">print</span>(bSize, c)</span>
<span id="cb6-16"><a href="#cb6-16"></a>        cv2.imshow(<span class="st">"Adaptive Mean_C"</span>, adaIm1)</span>
<span id="cb6-17"><a href="#cb6-17"></a>        cv2.imshow(<span class="st">"Adaptive Gauss_C"</span>, adaIm2)</span>
<span id="cb6-18"><a href="#cb6-18"></a>        cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="border">
<p>Notice how the calls to <code>adaptiveThreshold</code> are formatted, with one input per line. This is a common Python style: if the arguments to a function run too far to the right, rather than just breaking them up wherever, we put one per line, and line them up under the start of the first input.</p>
</div>
<p><a href="#fig-adaptiveThresh" class="quarto-xref">Figure&nbsp;8</a> shows pairs of values, one for the mean, and one for the Gaussian average, for different values of <code>bSize</code> and <code>c</code>.</p>
<div id="fig-adaptiveThresh" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-adaptiveThresh-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshMean3_2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-17" title="Mean, bSize = 3, c = 2"><img src="Ch4-Images/adaptiveThreshold/adaThreshMean3_2.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Mean</code>, <code>bSize</code> = 3, <code>c</code> = 2</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshGauss3_2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-18" title="Gauss, bSize = 3, c = 2"><img src="Ch4-Images/adaptiveThreshold/adaThreshGauss3_2.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Gauss</code>, <code>bSize</code> = 3, <code>c</code> = 2</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshMean3_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-19" title="Mean, bSize = 3, c = 5"><img src="Ch4-Images/adaptiveThreshold/adaThreshMean3_5.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Mean</code>, <code>bSize</code> = 3, <code>c</code> = 5</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshGauss3_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-20" title="Gauss, bSize = 3, c = 5"><img src="Ch4-Images/adaptiveThreshold/adaThreshGauss3_5.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Gauss</code>, <code>bSize</code> = 3, <code>c</code> = 5</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshMean7_2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-21" title="Mean, bSize = 7, c == 2"><img src="Ch4-Images/adaptiveThreshold/adaThreshMean7_2.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Mean</code>, <code>bSize</code> = 7, <code>c</code> == 2</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshGauss7_2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-22" title="Gauss, bSize = 7, c = 2"><img src="Ch4-Images/adaptiveThreshold/adaThreshGauss7_2.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Gauss</code>, <code>bSize</code> = 7, <code>c</code> = 2</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshMean7_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-23" title="Mean, bSize = 7, c = 5"><img src="Ch4-Images/adaptiveThreshold/adaThreshMean7_5.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Mean</code>, <code>bSize</code> = 7, <code>c</code> = 5</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshGauss7_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-24" title="Gauss, bSize = 7, c = 5"><img src="Ch4-Images/adaptiveThreshold/adaThreshGauss7_5.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Gauss</code>, <code>bSize</code> = 7, <code>c</code> = 5</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshMean11_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-25" title="Mean, bSize = 11, c = 5"><img src="Ch4-Images/adaptiveThreshold/adaThreshMean11_5.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Mean</code>, <code>bSize</code> = 11, <code>c</code> = 5</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshGauss11_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-26" title="Gauss, bSize = 11, c = 5"><img src="Ch4-Images/adaptiveThreshold/adaThreshGauss11_5.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Gauss</code>, <code>bSize</code> = 11, <code>c</code> = 5</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshMean11_10.png" class="lightbox" data-gallery="quarto-lightbox-gallery-27" title="Mean, bSize = 11, c = 10"><img src="Ch4-Images/adaptiveThreshold/adaThreshMean11_10.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Mean</code>, <code>bSize</code> = 11, <code>c</code> = 10</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/adaptiveThreshold/adaThreshGauss11_10.png" class="lightbox" data-gallery="quarto-lightbox-gallery-28" title="Gauss, bSize = 11, c = 10"><img src="Ch4-Images/adaptiveThreshold/adaThreshGauss11_10.png" class="img-fluid figure-img"></a></p>
<figcaption><code>Gauss</code>, <code>bSize</code> = 11, <code>c</code> = 10</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-adaptiveThresh-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8: Showing the varying results for <code>adaptiveThreshold</code> given different averaging and values of <code>bSize</code> and <code>x</code>
</figcaption>
</figure>
</div>
</section>
</section>
<section id="thresholds-from-color-images" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Thresholds from color images</h1>
<p>Grayscale as a basis for finding objects in images is limited. We could have a red ball on a green background where they happen to have similar brightness levels. We often want to detect objects by their colors, so there is a threshold function that does just that: <code>inRange</code>. This function takes in a color image, plus two tuples that specify low and high values for each channel, and it returns a threshold image. The returned image is white for pixels where all channel vaues fall within the range we’ve given for that channel.</p>
<p>We can use <code>inRange</code> on BGR images, but BGR color values change in complex ways when the lighting varies: all three channels must increase to produce a brighter version of a given hue, for instance. Instead we will <em>typically</em> convert the image to HSV and then use <code>inRange</code>. If we want to detect a certain color, we can use a narrow range of hue values, but let the saturation and value cover most of the range.</p>
<p><strong>OpenCV adaptation of HSV:</strong> If you look at a color wheel to explore HSV values for colors, you will notice that the hue channel typically ranges from 0 to 359 (degrees around a circl), while the saturation and value channels often range either between 0.0 and 1.0 or betwen 0 and 100. OpenCV wants to use 8-bit unsigned integers to represent HSV channels; those are restricted to 0 to 255. The typical range of hue values will not fit in an 8-bit unsigned integer, and the typical range of saturation and value would use less than half of the range available. Thus, OpenCV implements a variation on the typical HSV representation:</p>
<ul>
<li>OpenCV uses the range from 0 to 180 to represent hues (take the typical hue and divide by 2)</li>
<li>OpenCV maps saturation and value numbers on to the full range from 0 to 255</li>
</ul>
<p>Below is a script that detects a green ball in an image using <code>inRange</code>. It also shows what happens if we try to isolate the ball in the image using <code>threshold</code>, even with the threshold adaptation OTSU in use. Color images just hold more information than grayscale ones.</p>
<div id="2fac05af" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>ballImg <span class="op">=</span> cv2.imread(<span class="st">"BallFinding/Green/Green1BG1Mid.jpg"</span>)</span>
<span id="cb7-2"><a href="#cb7-2"></a>grayBall <span class="op">=</span> cv2.cvtColor(ballImg, cv2.COLOR_BGR2GRAY)</span>
<span id="cb7-3"><a href="#cb7-3"></a>hsvBall <span class="op">=</span> cv2.cvtColor(ballImg, cv2.COLOR_BGR2HSV)</span>
<span id="cb7-4"><a href="#cb7-4"></a>threshImg1 <span class="op">=</span> cv2.inRange(hsvBall, (<span class="dv">45</span>, <span class="dv">10</span>, <span class="dv">0</span>), (<span class="dv">65</span>, <span class="dv">255</span>, <span class="dv">255</span>))</span>
<span id="cb7-5"><a href="#cb7-5"></a>res, threshImg2 <span class="op">=</span> cv2.threshold(grayBall, <span class="dv">128</span>,<span class="dv">255</span>, cv2.THRESH_BINARY<span class="op">+</span>cv2.THRESH_OTSU)</span>
<span id="cb7-6"><a href="#cb7-6"></a></span>
<span id="cb7-7"><a href="#cb7-7"></a>cv2.imshow(<span class="st">"inRange"</span>, threshImg1)</span>
<span id="cb7-8"><a href="#cb7-8"></a>cv2.imshow(<span class="st">"threshold"</span>, threshImg2)</span>
<span id="cb7-9"><a href="#cb7-9"></a>cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>?@fig-inRangeExamp</strong> shows the original image, the grayscale version, and then the results of the calls to <code>inRange</code> and <code>threshold</code>.</p>
<div id="fig-threshVariants" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-threshVariants-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/Green1BG1Mid.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-29" title="Original image"><img src="Ch4-Images/Green1BG1Mid.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Original image</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/ballGray.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-30" title="Grayscale version"><img src="Ch4-Images/ballGray.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Grayscale version</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/ballInRange.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-31" title="Result of inRange"><img src="Ch4-Images/ballInRange.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of <code>inRange</code></figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch4-Images/ballThreshold.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-32" title="Result of threshold with OTSU"><img src="Ch4-Images/ballThreshold.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Result of <code>threshold</code> with OTSU</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-threshVariants-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9: Using <code>inRange</code> and <code>theshold</code> on an image, seeking to isolate the green ball from the rest of the image
</figcaption>
</figure>
</div>
<p>We encourage you to try this on some of the different colors of balls in the <code>BallFinding</code> folder. There are two main drawbacks to this method:</p>
<ul>
<li>Careful tuning of the lower and upper bounds can mean that you can isolate the ball well in this image, but not in others (so it’s best to test your program on multiple images, or even the frames of a video).</li>
<li>Determining the right range of hue values is tricky or time-consuming; you must either:
<ul>
<li>Open a color picker that displays HSV in your browser, then hand-match the color to the ball’s color (then remember to divide the hue values by 2 for OpenCV’s version of HSV)</li>
<li>Figure out an ROI that covers the ball, and print its hue values</li>
</ul></li>
</ul>
<p>In the next section, we will look at another method for building threshold, or near-threshold images, using a histogram of hue values. With this method, called <strong>backprojection</strong>, we can even isolate multicolored objects to some extent.</p>
</section>
<section id="pseudo-thresholds-with-histograms-and-backprojection" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Pseudo-thresholds with histograms and backprojection</h1>
<p>With grayscale threshold methods, we focused on the brightness of the pixels: keeping only the pixels brighter, or darker, than our threshold value. With the <code>inRange</code> color thresholding, we have to give ranges of each channel, and we keep only the pixels that fall inside all three ranges. With backprojection, we will collect the hue values from a region of interest, and use those to build a histogram of hue values. Then we will keep the pixels whose hue values match our histogram. Let’s break that process down into a series of steps.</p>
<section id="making-a-reference-image-or-roi" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="making-a-reference-image-or-roi"><span class="header-section-number">5.1</span> Making a reference image or ROI</h2>
<p>To build a histogram that represent the color(s) we want to match, we need a <em>reference image</em></p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
        for (let i=0; i<annoteTargets.length; i++) {
          const annoteTarget = annoteTargets[i];
          const targetCell = annoteTarget.getAttribute("data-target-cell");
          const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
          const contentFn = () => {
            const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
            if (content) {
              const tipContent = content.cloneNode(true);
              tipContent.classList.add("code-annotation-tip-content");
              return tipContent.outerHTML;
            }
          }
          const config = {
            allowHTML: true,
            content: contentFn,
            onShow: (instance) => {
              selectCodeLines(instance.reference);
              instance.reference.classList.add('code-annotation-active');
              window.tippy.hideAll();
            },
            onHide: (instance) => {
              unselectCodeLines();
              instance.reference.classList.remove('code-annotation-active');
            },
            maxWidth: 300,
            delay: [50, 0],
            duration: [200, 0],
            offset: [5, 10],
            arrow: true,
            appendTo: function(el) {
              return el.parentElement.parentElement.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'quarto',
            placement: 'right',
            popperOptions: {
              modifiers: [
              {
                name: 'flip',
                options: {
                  flipVariations: false, // true by default
                  allowedAutoPlacements: ['right'],
                  fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
                },
              },
              {
                name: 'preventOverflow',
                options: {
                  mainAxis: false,
                  altAxis: false
                }
              }
              ]        
            }      
          };
          window.tippy(annoteTarget, config); 
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>