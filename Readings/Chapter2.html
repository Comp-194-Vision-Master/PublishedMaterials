<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Susan Eileen Fox">
<meta name="dcterms.date" content="2025-06-10">

<title>Chapter 2, Images as Matrices (and Numpy Arrays)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Chapter2_files/libs/clipboard/clipboard.min.js"></script>
<script src="Chapter2_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Chapter2_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Chapter2_files/libs/quarto-html/popper.min.js"></script>
<script src="Chapter2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Chapter2_files/libs/quarto-html/anchor.min.js"></script>
<link href="Chapter2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Chapter2_files/libs/quarto-html/quarto-syntax-highlighting-226bd0f977fa82dfae4534cac220d79a.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Chapter2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Chapter2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Chapter2_files/libs/bootstrap/bootstrap-c9dc05ccd9e6568c662515419180efc4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="Chapter2_files/libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="Chapter2_files/libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="Chapter2_files/libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#images-as-numpy-arrays" id="toc-images-as-numpy-arrays" class="nav-link active" data-scroll-target="#images-as-numpy-arrays"><span class="header-section-number">1</span> Images as Numpy arrays</a></li>
  <li><a href="#a-few-basic-numpy-tools" id="toc-a-few-basic-numpy-tools" class="nav-link" data-scroll-target="#a-few-basic-numpy-tools"><span class="header-section-number">2</span> A few basic Numpy tools</a>
  <ul class="collapse">
  <li><a href="#creating-an-array" id="toc-creating-an-array" class="nav-link" data-scroll-target="#creating-an-array"><span class="header-section-number">2.1</span> Creating an array</a></li>
  <li><a href="#arithmetic-on-arrays" id="toc-arithmetic-on-arrays" class="nav-link" data-scroll-target="#arithmetic-on-arrays"><span class="header-section-number">2.2</span> Arithmetic on arrays</a></li>
  <li><a href="#accessing-and-slicing-arrays" id="toc-accessing-and-slicing-arrays" class="nav-link" data-scroll-target="#accessing-and-slicing-arrays"><span class="header-section-number">2.3</span> Accessing and slicing arrays</a></li>
  <li><a href="#using-boolean-arrays" id="toc-using-boolean-arrays" class="nav-link" data-scroll-target="#using-boolean-arrays"><span class="header-section-number">2.4</span> Using boolean arrays</a></li>
  </ul></li>
  <li><a href="#arithmetic-on-images" id="toc-arithmetic-on-images" class="nav-link" data-scroll-target="#arithmetic-on-images"><span class="header-section-number">3</span> Arithmetic on images</a></li>
  <li><a href="#accessing-color-channels" id="toc-accessing-color-channels" class="nav-link" data-scroll-target="#accessing-color-channels"><span class="header-section-number">4</span> Accessing color channels</a></li>
  <li><a href="#regions-of-interest" id="toc-regions-of-interest" class="nav-link" data-scroll-target="#regions-of-interest"><span class="header-section-number">5</span> Regions of interest</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Chapter 2, Images as Matrices (and Numpy Arrays)</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Susan Eileen Fox </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 10, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>In this chapter, we will take a closer look at how image representation works with OpenCV and Numpy, and tools from both libraries we can use to work with images. A key point to remember is that, though we can access individual pixel values, we will rarely ever write programs the manually iterate over the rows and columns of an image and read, or change, each individual pixel value. Doing so can be very slow. However, we can leverage the mathematics around vectors and matrices (a central focus of Linear Algebra) to treat images as matrices. This lets us use many highly-optimized algorithms for manipulating matrices, some of which leverage the multicore nature of modern computers.</p>
<p>The Numpy module implements N-dimensional arrays, a data structure that represents matrices, and it also provides those optimized algorithms for manipulating matrices. OpenCV sometimes has its own versions of basic matrix algorithms, as well.</p>
<section id="images-as-numpy-arrays" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Images as Numpy arrays</h1>
<p>Images in OpenCV are represented as N-dimensional arrays from the Numpy module. Numpy (NUMerical PYthon) implements efficient data types for arrays of numbers, including the 2-d and 3-d arrays that we need to represent grayscale and color images. An image is a Numpy <code>ndarray</code>, and the individual numbers in the array are typically one of the special Numpy number data types.</p>
<p>Numpy implements its own number types, similar to types used in other programming languages such as C, C++, and Java. Each number type has these properties: integer or floating-point, signed or unsigned, and a bit-size. For instance, to represent color values we use an 8-bit unsigned integer (which can represent values from 0 to 255). There is a Numpy type, <code>uint8</code>, which is exactly this kind of integer. Numpy also provides larger integer types, signed integer types that can represent both positive and negative integers, and floating-point types, such as <code>float32</code> (which holds signed 32-bit floating-point numbers).</p>
<p>Python, by contrast, has just one <code>int</code> and one <code>float</code> type, which can represent any integer or floating-point number that the computer can represent. How much memory an integer takes is hidden from us in Python, but Numpy makes that explicit to us. Similarly, Python lists are more flexible and fluid, and can be added to or removed from. Numpy arrays are less flexible: they hold just one type of number, and their size is fixed when they are created. These limitations allow them to represent data more efficiently, and increase the efficiency of accessing or changing data values.</p>
<div id="fig-mushrooms" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mushrooms-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="Ch2-Images/mushrooms.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Figure&nbsp;1: Mushroom image used in the next example, with 427 rows and 640 columns"><img src="Ch2-Images/mushrooms.jpg" class="img-fluid figure-img" style="width:12cm"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mushrooms-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Mushroom image used in the next example, with 427 rows and 640 columns
</figcaption>
</figure>
</div>
<p>The code example below reads in an image, and then prints its type, its size given as a tuple holding the size of each dimension of the array, and the type of data it contains. After that, it prints the array itself. <a href="#fig-mushrooms" class="quarto-xref">Figure&nbsp;1</a> shows the image that is used.</p>
<div id="5123446a" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> cv2</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a>origImage <span class="op">=</span> cv2.imread(<span class="st">"Ch2-Images/mushrooms.jpg"</span>)</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="bu">print</span>(<span class="st">"Type:"</span>, <span class="bu">type</span>(origImage))</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="bu">print</span>(<span class="st">"Shape:"</span>, origImage.shape, <span class="st">"  Data type:"</span>, origImage.dtype)</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="bu">print</span>(origImage)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Type: &lt;class 'numpy.ndarray'&gt;
Shape: (427, 640, 3)   Data type: uint8
[[[ 34 109  65]
  [ 35 107  65]
  [ 39 106  69]
  ...
  [ 69 109  81]
  [ 69 107  85]
  [ 69 108  83]]

 [[ 33 103  67]
  [ 37 104  67]
  [ 40 105  66]
  ...
  [ 71 109  87]
  [ 69 105  89]
  [ 66 102  90]]

 [[ 37 104  65]
  [ 39 104  65]
  [ 42 105  66]
  ...
  [ 71 111  83]
  [ 68 106  88]
  [ 63 105  82]]

 ...

 [[ 42  88  66]
  [ 50  90  65]
  [ 48  91  64]
  ...
  [ 36  91  52]
  [ 39  90  52]
  [ 34  90  55]]

 [[ 43  89  66]
  [ 51  91  66]
  [ 49  92  65]
  ...
  [ 37  93  52]
  [ 40  92  52]
  [ 35  92  54]]

 [[ 44  92  66]
  [ 52  92  67]
  [ 50  93  66]
  ...
  [ 36  93  48]
  [ 39  92  49]
  [ 34  91  53]]]</code></pre>
</div>
</div>
<p>You can see that the actual type for the image is <code>numpy.ndarray</code>. Each Numpy array has some variables associated with it; we print two of them on the second line. The <code>shape</code> of an array is its size, given as a tuple with one entry for each dimension, given the length of that dimension. The <code>dtype</code> of an array is the <em>data type</em>: the kind of data stored in the array. Since images use 8 bits per color channel in the RGB/BGR format, and we denote those with only positive values (and zero), we want to use <em>unsigned 8-bit integers</em> for each value in the array: The Numpy type <code>uint8</code> is exactly that.</p>
<p>When large Numpy arrays are printed, it automatically leaves out some of the data, putting in an ellipsis in each row and column where data has been omitted. It shows the first three elements and last three elements for each dimension: the first three rows and the last three rows, and within each row the first three pixels and the last three pixels. When we print a Numpy array it looks somewhat like a Python list, with nested brackets to show us the structure of the data. In this case, the outermost pair of brackets enclose the rows of the array. In other words, each element within the outer brackets is a row of the array. And each row can be thought of as an array itself. Within a row, each element is a color. And each color is itself an array of three integers. Those values are unsigned 8-bit ints.</p>
<p>To orient yourself with what has printed, consider the following hints:</p>
<ul>
<li>The first row starts with the (0, 0) pixel in the upper-left corner of the image with color (34, 109, 65).</li>
<li>The last pixel in the first row has color (69, 108, 83).</li>
<li>The last row starts with color (44, 92, 66) and ends with color (34, 91, 53).</li>
</ul>
</section>
<section id="a-few-basic-numpy-tools" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> A few basic Numpy tools</h1>
<p>In this section, we will introduce some basic functions, methods, and operations that apply to Numpy arrays. To keep examples simple, we will use small, simple arrays rather than images for many of these examples.</p>
<p>Whenever we want to use Numpy functions explicitly, we need to import the Numpy module. It has become standard to abbreviate the name of the module when importing it, so that it looks like the example below. Then, when using Numpy tools, we use the prefix <code>np.</code> rather than <code>numpy.</code>.</p>
<div id="9a437a15" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="creating-an-array" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="creating-an-array"><span class="header-section-number">2.1</span> Creating an array</h2>
<p>As we know, OpenCV will create an array to represent an image read from a file. But here we will examine some tools for creating arrays <em>from scratch</em>. More details about creating Numpy arrays may be found in the Numpy tutorial section <a href="https://numpy.org/doc/stable/user/basics.creation.html#">Creating Arrays</a>.</p>
<p>If we create a list or tuple with the structure we want in our Numpy array, the <code>array</code> or <code>asarray</code> functions can convert that to an array with the same structure. Each function takes one required input, the sequence or array to build the new array from, as well as optional inputs including <code>dtype</code>, which allows us to specify the type of data we want the new array to have. See the Numpy tutorial <a href="https://numpy.org/doc/stable/user/basics.types.html">Data types</a> for an extended discussion of Numpy data types, and how to specify them.</p>
<p>Below are some examples of making arrays with different structures with these functions.</p>
<div id="f97926b8" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>lst1 <span class="op">=</span> [<span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">4</span>, <span class="dv">3</span>]</span>
<span id="cb4-2"><a href="#cb4-2"></a>lst2 <span class="op">=</span> [[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]]</span>
<span id="cb4-3"><a href="#cb4-3"></a>lst3 <span class="op">=</span> [[[<span class="dv">9</span>, <span class="dv">8</span>], [<span class="dv">7</span>, <span class="dv">6</span>], [<span class="dv">5</span>, <span class="dv">4</span>]]]</span>
<span id="cb4-4"><a href="#cb4-4"></a>arr1 <span class="op">=</span> np.array(lst1)</span>
<span id="cb4-5"><a href="#cb4-5"></a>arr2 <span class="op">=</span> np.array(lst2, dtype<span class="op">=</span>np.uint8)</span>
<span id="cb4-6"><a href="#cb4-6"></a>arr3 <span class="op">=</span> np.asarray(lst3)</span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="bu">print</span>(<span class="st">"Array 1 shape and dtype:"</span>, arr1.shape, arr1.dtype)</span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="bu">print</span>(arr1)</span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="bu">print</span>(<span class="st">"Array 2 shape and dtype:"</span>, arr2.shape, arr2.dtype)</span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="bu">print</span>(arr2)</span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="bu">print</span>(<span class="st">"Array 3 shape and dtype:"</span>, arr3.shape, arr3.dtype)</span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="bu">print</span>(arr3)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Array 1 shape and dtype: (4,) int64
[5 6 4 3]
Array 2 shape and dtype: (2, 3) uint8
[[1 2 3]
 [4 5 6]]
Array 3 shape and dtype: (1, 3, 2) int64
[[[9 8]
  [7 6]
  [5 4]]]</code></pre>
</div>
</div>
<p>We can also use these functions to copy an array and change the type of the data, etc. The <code>array</code> function always makes a copy of the data, while the <code>asarray</code> function, when given an array as input, may create a new <strong>view</strong> of the data, but not actually copy it. Thus changes to the original array can show up in the new array. We have seen a similar phenomena, <strong>aliasing</strong>, with shared data in lists. A Numpy array has a method <code>astype</code>, that can convert the contents of the array from one type to another. As with the <code>asarray</code> function, it may not copy the data, but rather just provide a view of it as a new type. (For an <em>extended</em> discussion of copying versus viewing, see the Numpy tutorial section <a href="https://numpy.org/doc/stable/user/basics.copies.html">Copies and view</a>)</p>
<div id="db53e990" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>arr4 <span class="op">=</span> np.array(arr1)</span>
<span id="cb6-2"><a href="#cb6-2"></a>arr5 <span class="op">=</span> np.asarray(arr1)</span>
<span id="cb6-3"><a href="#cb6-3"></a>arr1[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="bu">print</span>(<span class="st">"Original array:"</span>, arr1)</span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="bu">print</span>(<span class="st">"Copied array:"</span>, arr4)</span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="bu">print</span>(<span class="st">"Viewed array:"</span>, arr5)</span>
<span id="cb6-7"><a href="#cb6-7"></a>arr6 <span class="op">=</span> arr1.astype(np.float32)</span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="bu">print</span>(<span class="st">"astype array:"</span>, arr6)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Original array: [20  6  4  3]
Copied array: [5 6 4 3]
Viewed array: [20  6  4  3]
astype array: [20.  6.  4.  3.]</code></pre>
</div>
</div>
<p>There are several functions to create arrays from scratch, by specifying only the size and data type. Each function fills the array with data that follows a particular pattern. We have already seen two of these functions, <code>zeros</code> and <code>ones</code>, but now we will look at them more closely. Additional functions include <code>random.rand</code>, which makes an array filled with random values, <code>eye</code>, which creates an identity matrix for any <span class="math inline">\(N\times N\)</span> size, and <code>arange</code>, which fills the array with values where start and end are specified.</p>
<p>The <code>zeros</code> and <code>ones</code> functions take in a tuple that defines the shape of the new matrix to make. The most common optional input is <code>dtype</code>, where we can specify the type of data to put into the array. The <code>zeros</code> function makes an array of the given size, and fills each cell in the array with 0. The <code>ones</code> is similar, except that it fills each cell in the array with 1.</p>
<div id="2c9f1e09" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a>z1 <span class="op">=</span> np.zeros((<span class="dv">5</span>, <span class="dv">5</span>))</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="bu">print</span>(<span class="st">"z1:"</span>)</span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="bu">print</span>(z1)</span>
<span id="cb8-4"><a href="#cb8-4"></a>z2 <span class="op">=</span> np.zeros((<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">2</span>), dtype<span class="op">=</span>np.uint8)</span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="bu">print</span>(<span class="st">"z2:"</span>)</span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="bu">print</span>(z2)</span>
<span id="cb8-7"><a href="#cb8-7"></a>o1 <span class="op">=</span> np.ones((<span class="dv">1</span>, <span class="dv">4</span>), dtype<span class="op">=</span>np.float64)</span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="bu">print</span>(<span class="st">"o1:"</span>)</span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="bu">print</span>(o1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>z1:
[[0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]]
z2:
[[[0 0]
  [0 0]
  [0 0]]

 [[0 0]
  [0 0]
  [0 0]]

 [[0 0]
  [0 0]
  [0 0]]]
o1:
[[1. 1. 1. 1.]]</code></pre>
</div>
</div>
</section>
<section id="arithmetic-on-arrays" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="arithmetic-on-arrays"><span class="header-section-number">2.2</span> Arithmetic on arrays</h2>
<p>Numpy extends the built-in arithmetic operators to work on arrays. The four basic arithmetic operations, addition, subtraction, multiplication, and division, all perform <strong>element-wise</strong> operations on arrays. That means that it matches up corresponding elements of the arrays, and does the arithmetic on them. The examples below show this process on two arrays with the same shape.</p>
<div id="5badcddc" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a>a1 <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>], [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]])</span>
<span id="cb10-2"><a href="#cb10-2"></a>a2 <span class="op">=</span> np.array([[<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>], [<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">3</span>]])</span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="bu">print</span>(<span class="st">"Addition"</span>)</span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="bu">print</span>(a1 <span class="op">+</span> a2)</span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="bu">print</span>(<span class="st">"Subtraction"</span>)</span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="bu">print</span>(a1 <span class="op">-</span> a2)</span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="bu">print</span>(<span class="st">"Multiplication"</span>)</span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="bu">print</span>(a1 <span class="op">*</span> a2)</span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="bu">print</span>(<span class="st">"Division"</span>)</span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="bu">print</span>(a1 <span class="op">/</span> a2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Addition
[[3 4 3]
 [7 8 9]]
Subtraction
[[-1  0 -1]
 [ 1  2  3]]
Multiplication
[[ 2  4  2]
 [12 15 18]]
Division
[[0.5        1.         0.5       ]
 [1.33333333 1.66666667 2.        ]]</code></pre>
</div>
</div>
<p>We can always apply arithmetic operations when two arrays have the same shape. Numpy also allows us to perform arithmetic between an array and a <em>scalar</em> (an individual number). At each cell in the array, we perform the arithmetic on that cell’s value, and the scalar.</p>
<div id="017dd4d1" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="bu">print</span>(a1 <span class="op">+</span> <span class="dv">4</span>)</span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="bu">print</span>(<span class="dv">10</span> <span class="op">*</span> a1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[ 5  6  5]
 [ 8  9 10]]
[[10 20 10]
 [40 50 60]]</code></pre>
</div>
</div>
<p>Numpy also allows arithmetic between two arrays of different shapes, if one can be naturally <strong>extended</strong> to map onto the other. It can be tricky to determine the rules for when something is extensible, but a simple case is when we have a 2-d array: we can specify a second array the length of a row and the arithmetic operator will extend that across all the rows of the array, and similarly for columns.</p>
<div id="92eaccc1" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a>a1 <span class="op">=</span> np.array([[<span class="dv">2</span>, <span class="dv">4</span>], [<span class="dv">6</span>, <span class="dv">8</span>], [<span class="dv">10</span>, <span class="dv">12</span>]])</span>
<span id="cb14-2"><a href="#cb14-2"></a>a2 <span class="op">=</span> np.array([<span class="dv">5</span>, <span class="dv">10</span>])</span>
<span id="cb14-3"><a href="#cb14-3"></a>a3 <span class="op">=</span> np.array([[<span class="dv">3</span>], [<span class="op">-</span><span class="dv">3</span>], [<span class="dv">2</span>]])</span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="bu">print</span>(<span class="st">"a1 * a2:"</span>)</span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="bu">print</span>(a1 <span class="op">*</span> a2)</span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="bu">print</span>(<span class="st">"a1 * a3:"</span>)</span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="bu">print</span>(a1 <span class="op">*</span> a3)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>a1 * a2:
[[ 10  40]
 [ 30  80]
 [ 50 120]]
a1 * a3:
[[  6  12]
 [-18 -24]
 [ 20  24]]</code></pre>
</div>
</div>
</section>
<section id="accessing-and-slicing-arrays" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="accessing-and-slicing-arrays"><span class="header-section-number">2.3</span> Accessing and slicing arrays</h2>
<p>We can access and modify individual values in an array, or subarrays of various shapes and sizes, using an extended version of the square bracket notation Python uses for lists and strings, as well as an extended version of slicing. Numpy’s introductory tutorial has a section, <a href="https://numpy.org/doc/stable/user/basics.indexing.html">Indexing on <code>ndarrays</code></a>, that goes into more details about accessing and indexing.</p>
<p>If we have a one-dimensional Numpy array, holding data in a single row, then accessing its elements or slicing out a subarray looks just like operating on a list.</p>
<div id="b1929c8f" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a>a1 <span class="op">=</span> np.arange(<span class="dv">3</span>, <span class="dv">8</span>)</span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="bu">print</span>(a1.shape, a1)</span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="bu">print</span>(<span class="st">"Values:"</span>, a1[<span class="dv">0</span>], a1[<span class="dv">3</span>], a1[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="bu">print</span>(<span class="st">"Subarrays:"</span>, a1[<span class="dv">0</span>:<span class="dv">3</span>], a1[<span class="dv">4</span>:], a1[::<span class="dv">2</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(5,) [3 4 5 6 7]
Values: 3 6 7
Subarrays: [3 4 5] [7] [3 5 7]</code></pre>
</div>
</div>
<p>Suppose we have a two-dimensional array. Its structure matches that of a nested list. With nested lists, a single square bracket returns the whole nested sublist. To access an individual value inside that sublist, we add a second square bracket (see first examples below).</p>
<p>With a two-d array, a single square bracket with a single number returns the subarray corresponding to that row. We can add a second square bracket after the first, with a similar effect as with lists, but Numpy also allow us to put both indices inside a single pair of square brackets, separated by commas. This is an easier notation (see second examples below).</p>
<div id="7f1e7a88" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a>lst <span class="op">=</span> [[<span class="dv">9</span>, <span class="dv">8</span>], [<span class="dv">7</span>, <span class="dv">6</span>]]</span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="bu">print</span>(<span class="st">"List element:"</span>, lst[<span class="dv">1</span>], <span class="st">"  Sublist element:"</span>, lst[<span class="dv">1</span>][<span class="dv">0</span>])</span>
<span id="cb18-3"><a href="#cb18-3"></a>a2 <span class="op">=</span> np.array(lst)</span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="bu">print</span>(<span class="st">"Array element:"</span>, a2[<span class="dv">1</span>], <span class="st">"  Subarray element:"</span>, a2[<span class="dv">1</span>][<span class="dv">0</span>], <span class="st">"  and simpler notation:"</span>, a2[<span class="dv">1</span>, <span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>List element: [7, 6]   Sublist element: 7
Array element: [7 6]   Subarray element: 7   and simpler notation: 7</code></pre>
</div>
</div>
<p>We can always replace the single number with a slicing operator, where we specify start and end indices, and step size, to select a range of values from an array. Notice that we can use a single colon (<code>:</code>) to indicate <em>all values</em> for a given dimension. Remember that if we leave out start or end then Python assumes it should start at 0 and go to the end of the current dimension. And if we have two colons, the value after the second colon is a step size or number of elements to skip. Before looking closely at the output for the examples below, try to predict the output for the random array shown here and the code below.</p>
<div id="c4cf23e6" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a>rArr <span class="op">=</span> np.random.rand(<span class="dv">6</span>, <span class="dv">6</span>) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>rArr <span class="op">=</span> rArr.astype(<span class="bu">int</span>)</span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="bu">print</span>(<span class="st">"Random array:"</span>)</span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="bu">print</span>(rArr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Random array:
[[ 7 78 18 79 69 26]
 [94 94 90 38  5 59]
 [53 99 10 28 37 95]
 [32 90  4 11 47 12]
 [34 88 92 16 93  1]
 [22 24 65 17 72 54]]</code></pre>
</div>
</div>
<div id="ccb2a7f9" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1"></a><span class="bu">print</span>(<span class="st">"Selecting just rows 2 through 4:"</span>)</span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="bu">print</span>(rArr[<span class="dv">2</span>:<span class="dv">4</span>])</span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="bu">print</span>(<span class="st">"Selecting all rows of columns 0 and 3:"</span>)</span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="bu">print</span>(rArr[:, ::<span class="dv">3</span>])</span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="bu">print</span>(<span class="st">"Selecting rows 2 and 3 and columns 2 and 3:"</span>)</span>
<span id="cb22-6"><a href="#cb22-6"></a><span class="bu">print</span>(rArr[<span class="dv">2</span>:<span class="dv">4</span>, <span class="dv">2</span>:<span class="dv">4</span>])</span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="bu">print</span>(<span class="st">"Selecting the last value from all rows:"</span>)</span>
<span id="cb22-8"><a href="#cb22-8"></a><span class="bu">print</span>(rArr[:, <span class="op">-</span><span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Selecting just rows 2 through 4:
[[53 99 10 28 37 95]
 [32 90  4 11 47 12]]
Selecting all rows of columns 0 and 3:
[[ 7 79]
 [94 38]
 [53 28]
 [32 11]
 [34 16]
 [22 17]]
Selecting rows 2 and 3 and columns 2 and 3:
[[10 28]
 [ 4 11]]
Selecting the last value from all rows:
[26 59 95 12  1 54]</code></pre>
</div>
</div>
<p>We use slicing like this on images to extract a rectangular region of an image, called a region of interest (ROI). See discussion in a later section.</p>
</section>
<section id="using-boolean-arrays" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="using-boolean-arrays"><span class="header-section-number">2.4</span> Using boolean arrays</h2>
<p>The last Numpy tools we will look at are boolean arrays. These arrays allow us to apply comparison operations to whole arrays, creating arrays the same shape filled with <code>True</code> and <code>False</code>. We can use Numpy functions <code>any</code> and <code>all</code> to ask whether the resulting array has any true values, or if all are true values.</p>
<p>Most exciting, we can use boolean arrays as a selection index inside square brackets, to extract just the values from the array where the boolean array has True. (Much more can be found in the <a href="https://numpy.org/doc/stable/user/quickstart.html#indexing-with-boolean-arrays">Indexing with boolean arrays</a> section of the Numpy quickstart guide.</p>
<div id="d6cecfa3" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1"></a>arr <span class="op">=</span> np.array([[<span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">2</span>], [<span class="dv">9</span>, <span class="dv">1</span>, <span class="dv">6</span>, <span class="dv">8</span>], [<span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">7</span>]])</span>
<span id="cb24-2"><a href="#cb24-2"></a>bArr <span class="op">=</span> arr <span class="op">&gt;=</span> <span class="dv">5</span></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="bu">print</span>(bArr)</span>
<span id="cb24-4"><a href="#cb24-4"></a>result <span class="op">=</span> arr[bArr]</span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="bu">print</span>(<span class="st">"Result:"</span>, result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[ True False  True False]
 [ True False  True  True]
 [False False False  True]]
Result: [5 6 9 6 8 7]</code></pre>
</div>
</div>
</section>
</section>
<section id="arithmetic-on-images" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Arithmetic on images</h1>
<p>As we saw in the previous section, Numpy provides arithmetic operations on arrays. OpenCV provides its own set of functions to perform arithmetic on images. We might prefer Numpy’s operations for their simplicity in terms of writing code, and also probably a slightly better speed, but the Numpy operations can have some bad effects, and OpenCV’s arithmetic functions are safer.</p>
<p>Consider the code example below. It is brightening an image by adding 50 to each value in the array (all three color channels, every rown and column). The results are shown in <a href="#fig-imageArith" class="quarto-xref">Figure&nbsp;2</a>.</p>
<div id="476c7bab" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a><span class="im">import</span> cv2</span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb26-3"><a href="#cb26-3"></a></span>
<span id="cb26-4"><a href="#cb26-4"></a>origImg <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/canyonlands.jpg"</span>)</span>
<span id="cb26-5"><a href="#cb26-5"></a>cv2.imshow(<span class="st">"Original"</span>, origImg)</span>
<span id="cb26-6"><a href="#cb26-6"></a></span>
<span id="cb26-7"><a href="#cb26-7"></a>npBrighter <span class="op">=</span> origImg <span class="op">+</span> <span class="dv">50</span></span>
<span id="cb26-8"><a href="#cb26-8"></a>cvBrighter <span class="op">=</span> cv2.add(origImg, <span class="dv">50</span>)</span>
<span id="cb26-9"><a href="#cb26-9"></a></span>
<span id="cb26-10"><a href="#cb26-10"></a>cv2.imshow(<span class="st">"Numpy brighter"</span>, npBrighter)</span>
<span id="cb26-11"><a href="#cb26-11"></a>cv2.imshow(<span class="st">"OpenCV brighter"</span>, cvBrighter)</span>
<span id="cb26-12"><a href="#cb26-12"></a>cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-imageArith" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-imageArith-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch2-Images/canyonlands.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Original image"><img src="Ch2-Images/canyonlands.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Original image</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch2-Images/NumpyBrightened.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Numpy brightened"><img src="Ch2-Images/NumpyBrightened.png" class="img-fluid figure-img"></a></p>
<figcaption>Numpy brightened</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch2-Images/OpenCVBrightened.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="OpenCV brightened"><img src="Ch2-Images/OpenCVBrightened.png" class="img-fluid figure-img"></a></p>
<figcaption>OpenCV brightened</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-imageArith-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Comparing arithmetic effects of Numpy and OpenCV
</figcaption>
</figure>
</div>
<p>In this example, the Numpy arithmetic leads to strange color artifacts in the resulting image. Why? This is an example of <strong>overflow</strong>. With an unsigned 8-bit integer, the largest value we can represent is 255. If we add 50 to a number like 235, the result should be 285, but we can’t represent that in 8 bits, so the result wraps around to the bottom of the range, giving the value 29. The color artifacts occur when some or all color channel values overflow. When the result looks black or dark gray, then all three channels overflowed. If the result looks red, then both blue and green overflowed, and so on.</p>
<p><strong>Numpy arithmetic does not check for or correct for overflow!</strong></p>
<p>If we use Numpy arithmetic, it is our responsibility as programmers to ensure that overflow can’t happen.</p>
<p>On the other hand, OpenCV’s arithmetic function doesn’t show these artifacts. This is because it checks if overflow might occur, and if so, it sets the channel value to 255. This makes it more safe, more reliable, but that extra check also means it will run slightly slower than the plain Numpy version.</p>
<p>To learn more about Numpy, check out the <a href="https://numpy.org/doc/stable/reference/index.html">Numpy documentation</a>. And for more about OpenCV’s arithmetic operations, see OpenCV’s <a href="https://docs.opencv.org/4.x/d2/de8/group__core__array.html#gafafb2513349db3bcff51f54ee5592a19">Operations on arrays</a> documentation.</p>
</section>
<section id="accessing-color-channels" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Accessing color channels</h1>
<p>Remember that color images in OpenCV are, by default, represented as BGR 3-d arrays, where the first and second dimensions are for rows and columns of pixels, and the third dimension holds the three color channels in blue, green, and red order. There are times when we want to separate the channels from each other, perhaps to brighten only the blue channel, or reduce the amount of red. We can use the slicing operators from the previous section to slice out the channels for each other.</p>
<p>But OpenCV provides us with a function, <code>split</code>, to separate the channels into their own arrays, as well as a function, <code>merge</code>, to put channels back together again. The <code>split</code> function takes one input, a color image, and it returns a tuple of the three channel arrays. The merge function takes a tuple containing three channel arrays (each must be a 2d array, and all the same size) and it returns a new image array.</p>
<p>The code example below splits the channels of an image, and then copies and modifies two of the channels: one with increased blue, and the other with decreased red. Finally, the code merges the three channels back together again to create two new images and displays them. <a href="#fig-splitMerge" class="quarto-xref">Figure&nbsp;3</a> shows the original image and the two with modified color channels.</p>
<div id="f7fafdcd" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a>img <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/wildColumbine.jpg"</span>)</span>
<span id="cb27-2"><a href="#cb27-2"></a>cv2.imshow(<span class="st">"Original"</span>, img)</span>
<span id="cb27-3"><a href="#cb27-3"></a></span>
<span id="cb27-4"><a href="#cb27-4"></a>(bChan, gChan, rChan) <span class="op">=</span> cv2.split(img)</span>
<span id="cb27-5"><a href="#cb27-5"></a></span>
<span id="cb27-6"><a href="#cb27-6"></a>newB <span class="op">=</span> cv2.add(bChan, <span class="dv">75</span>)</span>
<span id="cb27-7"><a href="#cb27-7"></a>newR <span class="op">=</span> cv2.subtract(rChan, <span class="dv">75</span>)</span>
<span id="cb27-8"><a href="#cb27-8"></a></span>
<span id="cb27-9"><a href="#cb27-9"></a>img2 <span class="op">=</span> cv2.merge((newB, gChan, rChan))</span>
<span id="cb27-10"><a href="#cb27-10"></a>img3 <span class="op">=</span> cv2.merge((bChan, gChan, newR))</span>
<span id="cb27-11"><a href="#cb27-11"></a></span>
<span id="cb27-12"><a href="#cb27-12"></a>cv2.imshow(<span class="st">"Changed blue"</span>, img2)</span>
<span id="cb27-13"><a href="#cb27-13"></a>cv2.imshow(<span class="st">"Changed red"</span>, img3)</span>
<span id="cb27-14"><a href="#cb27-14"></a>cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-splitMerge" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-splitMerge-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch2-Images/wildColumbine.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Original image"><img src="Ch2-Images/wildColumbine.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Original image</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch2-Images/MoreBlue.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="New image with boosted blue values"><img src="Ch2-Images/MoreBlue.png" class="img-fluid figure-img"></a></p>
<figcaption>New image with boosted blue values</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch2-Images/LessRed.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="New image with reduced red values"><img src="Ch2-Images/LessRed.png" class="img-fluid figure-img"></a></p>
<figcaption>New image with reduced red values</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-splitMerge-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Examples of splitting and merging to change color channel arrays
</figcaption>
</figure>
</div>
<p>Note that we can make channel-specific changes using Numpy’s tools as well, though we may run the risk of visual artifacts. <a href="#fig-numpyChannels" class="quarto-xref">Figure&nbsp;4</a> shows what would happen if we used Numpy. Notice that increasing the blue works well, because blue values were generally not high, but reducing red, for pixels that had little red to start with, causes overflow.</p>
<div id="db390b8c" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1"></a>img <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/wildColumbine.jpg"</span>)</span>
<span id="cb28-2"><a href="#cb28-2"></a>cv2.imshow(<span class="st">"Original"</span>, img)</span>
<span id="cb28-3"><a href="#cb28-3"></a></span>
<span id="cb28-4"><a href="#cb28-4"></a>img2 <span class="op">=</span> img.copy()</span>
<span id="cb28-5"><a href="#cb28-5"></a>img2[:, :, <span class="dv">0</span>] <span class="op">=</span> img2[:, :, <span class="dv">0</span>] <span class="op">+</span> <span class="dv">75</span></span>
<span id="cb28-6"><a href="#cb28-6"></a></span>
<span id="cb28-7"><a href="#cb28-7"></a>img3 <span class="op">=</span> img.copy()</span>
<span id="cb28-8"><a href="#cb28-8"></a>img3[:, :, <span class="dv">2</span>] <span class="op">=</span> img2[:, :, <span class="dv">2</span>] <span class="op">-</span> <span class="dv">75</span></span>
<span id="cb28-9"><a href="#cb28-9"></a></span>
<span id="cb28-10"><a href="#cb28-10"></a>cv2.imshow(<span class="st">"Changed blue"</span>, img2)</span>
<span id="cb28-11"><a href="#cb28-11"></a>cv2.imshow(<span class="st">"Changed red"</span>, img3)</span>
<span id="cb28-12"><a href="#cb28-12"></a>cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-numpyChannels" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-numpyChannels-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch2-Images/wildColumbine.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-8" title="Original image"><img src="Ch2-Images/wildColumbine.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Original image</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch2-Images/NumpyMoreBlue.png" class="lightbox" data-gallery="quarto-lightbox-gallery-9" title="New image with boosted blue values"><img src="Ch2-Images/NumpyMoreBlue.png" class="img-fluid figure-img"></a></p>
<figcaption>New image with boosted blue values</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch2-Images/NumpyLessRed.png" class="lightbox" data-gallery="quarto-lightbox-gallery-10" title="New image with reduced red values"><img src="Ch2-Images/NumpyLessRed.png" class="img-fluid figure-img"></a></p>
<figcaption>New image with reduced red values</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-numpyChannels-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Examples of using Numpy arithmetic to change channel values
</figcaption>
</figure>
</div>
</section>
<section id="regions-of-interest" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Regions of interest</h1>
<p>When working with images, especially in the context of computer vision, we often want to isolate and focus on smaller section of the overall image. We call these sections “regions of interest” (ROIs). We can treat them as smaller images in their own right.</p>
<p>To create a region of interest, we can use Numpy’s slicing operators to select a certain range of x and y values from an image.</p>
<p><strong>Note:</strong> for memory efficiency, when you create an ROI, it is a new <em>view</em> on the original image data. It does not copy the data. Many times this is just what we want: we can focus on a small section and any changes we make show up in the original. However, when you are working with a view onto a different image, some operations are prohibited (for example, you are not allowed to draw on an ROI that is a view). You can always use the <code>copy</code> method to explicitly make a copy of the data, working with a real, new image.</p>
<p>The code below illustrates how to make an ROI, and what happens when you manipulate it. This code reads in one of the snow leopard images, and defines an ROI <code>faceROI</code> that is centered on the cat’s head (the actual coordinates for the ROI were found with trial and error). It changes the blue channel values for the ROI to be zero, which will also change the original image (you must call <code>imshow</code> again to see the changes).</p>
<p>Finally, this program creates a second ROI, where we have reversed the rows in the y direction, so that it is upside down from the original. We then change the green channel values for the second ROI to be 128, and view the original images again. Run this script on your own computer; the results are shown in <a href="#fig-rois" class="quarto-xref">Figure&nbsp;5</a> below.</p>
<div id="663b0c79" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1"></a><span class="im">import</span> cv2</span>
<span id="cb29-2"><a href="#cb29-2"></a></span>
<span id="cb29-3"><a href="#cb29-3"></a>catImage <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/snowLeo1.jpg"</span>)</span>
<span id="cb29-4"><a href="#cb29-4"></a>faceROI <span class="op">=</span> catImage[<span class="dv">250</span>:<span class="dv">550</span>, <span class="dv">570</span>:<span class="dv">860</span>, :]</span>
<span id="cb29-5"><a href="#cb29-5"></a></span>
<span id="cb29-6"><a href="#cb29-6"></a>cv2.imshow(<span class="st">"Orig"</span>, catImage)</span>
<span id="cb29-7"><a href="#cb29-7"></a>cv2.imshow(<span class="st">"Face"</span>, faceROI)</span>
<span id="cb29-8"><a href="#cb29-8"></a>cv2.waitKey(<span class="dv">0</span>)</span>
<span id="cb29-9"><a href="#cb29-9"></a></span>
<span id="cb29-10"><a href="#cb29-10"></a><span class="co"># set blue channel of this ROI to zero, notice change shows in original</span></span>
<span id="cb29-11"><a href="#cb29-11"></a>faceROI[:, :, <span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb29-12"><a href="#cb29-12"></a></span>
<span id="cb29-13"><a href="#cb29-13"></a>cv2.imshow(<span class="st">"Orig"</span>, catImage)</span>
<span id="cb29-14"><a href="#cb29-14"></a>cv2.imshow(<span class="st">"Face"</span>, faceROI)</span>
<span id="cb29-15"><a href="#cb29-15"></a>cv2.waitKey(<span class="dv">0</span>)</span>
<span id="cb29-16"><a href="#cb29-16"></a></span>
<span id="cb29-17"><a href="#cb29-17"></a><span class="co"># flip the face upside down by reversing the Y direction and keeping the others the same</span></span>
<span id="cb29-18"><a href="#cb29-18"></a>flipFace <span class="op">=</span> faceROI[::<span class="op">-</span><span class="dv">1</span>, :, :]</span>
<span id="cb29-19"><a href="#cb29-19"></a>hgt, wid, dep <span class="op">=</span> flipFace.shape    <span class="co"># get dimensions of ROI</span></span>
<span id="cb29-20"><a href="#cb29-20"></a>flipFace[:hgt<span class="op">//</span><span class="dv">2</span>, :, <span class="dv">1</span>] <span class="op">=</span> <span class="dv">128</span></span>
<span id="cb29-21"><a href="#cb29-21"></a></span>
<span id="cb29-22"><a href="#cb29-22"></a>cv2.imshow(<span class="st">"Orig"</span>, catImage)</span>
<span id="cb29-23"><a href="#cb29-23"></a>cv2.imshow(<span class="st">"Face"</span>, faceROI)</span>
<span id="cb29-24"><a href="#cb29-24"></a>cv2.imshow(<span class="st">"Flipped"</span>, flipFace)</span>
<span id="cb29-25"><a href="#cb29-25"></a>cv2.waitKey(<span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-rois" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-rois-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch2-Images/ROI1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-11" title="Original image and first ROI"><img src="Ch2-Images/ROI1.png" class="img-fluid figure-img"></a></p>
<figcaption>Original image and first ROI</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch2-Images/ROI2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-12" title="Changing first ROI blue values to zero"><img src="Ch2-Images/ROI2.png" class="img-fluid figure-img"></a></p>
<figcaption>Changing first ROI blue values to zero</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch2-Images/ROI3.png" class="lightbox" data-gallery="quarto-lightbox-gallery-13" title="Creating flipped ROI and changing green values to 128 in its top half"><img src="Ch2-Images/ROI3.png" class="img-fluid figure-img"></a></p>
<figcaption>Creating flipped ROI and changing green values to 128 in its top half</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-rois-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: The effect of making and modifying ROIs
</figcaption>
</figure>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
        for (let i=0; i<annoteTargets.length; i++) {
          const annoteTarget = annoteTargets[i];
          const targetCell = annoteTarget.getAttribute("data-target-cell");
          const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
          const contentFn = () => {
            const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
            if (content) {
              const tipContent = content.cloneNode(true);
              tipContent.classList.add("code-annotation-tip-content");
              return tipContent.outerHTML;
            }
          }
          const config = {
            allowHTML: true,
            content: contentFn,
            onShow: (instance) => {
              selectCodeLines(instance.reference);
              instance.reference.classList.add('code-annotation-active');
              window.tippy.hideAll();
            },
            onHide: (instance) => {
              unselectCodeLines();
              instance.reference.classList.remove('code-annotation-active');
            },
            maxWidth: 300,
            delay: [50, 0],
            duration: [200, 0],
            offset: [5, 10],
            arrow: true,
            appendTo: function(el) {
              return el.parentElement.parentElement.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'quarto',
            placement: 'right',
            popperOptions: {
              modifiers: [
              {
                name: 'flip',
                options: {
                  flipVariations: false, // true by default
                  allowedAutoPlacements: ['right'],
                  fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
                },
              },
              {
                name: 'preventOverflow',
                options: {
                  mainAxis: false,
                  altAxis: false
                }
              }
              ]        
            }      
          };
          window.tippy(annoteTarget, config); 
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>