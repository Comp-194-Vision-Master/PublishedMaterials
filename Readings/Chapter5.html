<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Susan Eileen Fox">
<meta name="dcterms.date" content="2025-10-16">

<title>Chapter 5, Geometric Transformations â€“ Vision Readings</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-226bd0f977fa82dfae4534cac220d79a.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-9011e249e8d359b0658fa71d60c1fa6f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Vision Readings</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Chapter 5, Geometric Transformations</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Susan Eileen Fox </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 16, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#resizing-images" id="toc-resizing-images" class="nav-link active" data-scroll-target="#resizing-images"><span class="header-section-number">1</span> Resizing images</a></li>
  <li><a href="#geometric-transformations-with-affine-warping" id="toc-geometric-transformations-with-affine-warping" class="nav-link" data-scroll-target="#geometric-transformations-with-affine-warping"><span class="header-section-number">2</span> Geometric transformations with affine warping</a>
  <ul class="collapse">
  <li><a href="#translation" id="toc-translation" class="nav-link" data-scroll-target="#translation"><span class="header-section-number">2.1</span> Translation</a></li>
  <li><a href="#rotation" id="toc-rotation" class="nav-link" data-scroll-target="#rotation"><span class="header-section-number">2.2</span> Rotation</a></li>
  <li><a href="#general-affine-warping" id="toc-general-affine-warping" class="nav-link" data-scroll-target="#general-affine-warping"><span class="header-section-number">2.3</span> General affine warping</a></li>
  <li><a href="#a-note-about-the-perspective-transform" id="toc-a-note-about-the-perspective-transform" class="nav-link" data-scroll-target="#a-note-about-the-perspective-transform"><span class="header-section-number">2.4</span> A note about the <em>perspective transform</em></a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>In this chapter, we will continue our examination of image transformations with <strong>geometric transformations.</strong> Geometric transformations are used to resize images, but also to translate, rotate, or warp image contents within the frame of an image.</p>
<section id="resizing-images" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Resizing images</h1>
<p>The most basic transformation is resizing an image. The <code>resize</code> function will scale a picture up or down, and can also be used to stretch an image by changing its <em>aspect ratio</em>, the ratio of an imageâ€™s width to its height. You must give the <code>resize</code> function a source image and an input for the dimensions of the new image. It has three optional inputs, as well. Two of these let you specify the width and/or height of the new image as a factor of the original, and the last optional input lets you select the <em>interpolation</em> algorithm to be used. Below are some examples of ways to use <code>resize</code>:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 41%">
<col style="width: 58%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Examples</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>cv2.resize(src, (100, 100))</code></td>
<td style="text-align: left;">Returns a new image that is 100 x 100 pixels, a stretched/squashed version of the original</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>cv2.resize(src, (0, 0), fx=2, fy=2)</code></td>
<td style="text-align: left;">Returns a new image that is twice the size of the original, same aspect ratio</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>cv2.resize(src, (0, 0), fx=0.5, fy=1.0)</code></td>
<td style="text-align: left;">Returns a new image whose columns have been squashed to half the original size</td>
</tr>
</tbody>
</table>
<p><em>Interpolation</em> is the process used to make the resized image look better. When we reduce the size of the image, one new pixel might have to cover a part of the image that original had multiple pixels. When we increase the size of the image, we want to smooth the colors where we are adding pixels that werenâ€™t there before, so that the image does not look pixelated. Interpolation determines the colors of the pixels to preserve as much information from the image as possible, while smoothing adjacent pixel values.</p>
<p>According to the OpenCV documentation, The <code>cv2.INTER_AREA</code> interpolation method is best when reducing the size of the image, but <code>cv2.INTER_CUBIC</code> or <code>cv2.INTER_LINEAR</code> (the default method) work best when scaling an image up to a larger size.</p>
<p>Below is a code example that illustrates some changes made to a typical image, followed by the results in <a href="#fig-resize" class="quarto-xref">Figure&nbsp;1</a>.</p>
<div id="1b5ceec4" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> cv2</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a>img <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/mushrooms.jpg"</span>)</span>
<span id="cb1-4"><a href="#cb1-4"></a>img1 <span class="op">=</span> cv2.resize(img, (<span class="dv">100</span>, <span class="dv">100</span>))</span>
<span id="cb1-5"><a href="#cb1-5"></a>img2 <span class="op">=</span> cv2.resize(img, (<span class="dv">0</span>, <span class="dv">0</span>), fx<span class="op">=</span><span class="dv">2</span>, fy<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb1-6"><a href="#cb1-6"></a>img3 <span class="op">=</span> cv2.resize(img, (<span class="dv">0</span>, <span class="dv">0</span>), fx<span class="op">=</span><span class="fl">0.5</span>, fy<span class="op">=</span><span class="fl">1.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-resize" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-resize-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch5-Images/mushrooms.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Original image"><img src="Ch5-Images/mushrooms.jpg" class="img-fluid figure-img" style="width:5cm"></a></p>
<figcaption>Original image</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch5-Images/resize1.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Resized to 100 by 100"><img src="Ch5-Images/resize1.jpg" class="img-fluid figure-img" style="width:1cm"></a></p>
<figcaption>Resized to 100 by 100</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch5-Images/resize2.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Resized to twice the width and height"><img src="Ch5-Images/resize2.jpg" class="img-fluid figure-img" style="width:10cm"></a></p>
<figcaption>Resized to twice the width and height</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch5-Images/resize3.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Resized to half the width, original height"><img src="Ch5-Images/resize3.jpg" class="img-fluid figure-img" style="width:2.5cm"></a></p>
<figcaption>Resized to half the width, original height</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-resize-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Three different resizing of an image, including one that squashes the imageâ€™s width.
</figcaption>
</figure>
</div>
</section>
<section id="geometric-transformations-with-affine-warping" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Geometric transformations with affine warping</h1>
<p>Geometric transformations includes scaling, translation, rotation, reflection, and <em>skewing</em> the contents of an image. The <code>resize</code> function takes care of the scaling part, and the <code>flip</code> function (or just Numpy slicing) can handle reflection. We will use affine warping to perform most of the other kinds of geometric transformations.</p>
<ul>
<li>Translation means moving the pixels in an image horizontally and vertically, so the image appears shifted to the right or left, up or down.</li>
<li>Rotation means moving the pixels so that the image appears to be turned around some specific pixel in the image.</li>
<li>Skewing, or warping, are more complex transformation. For skewing, imaging taking a rectangular image and transforming it into a parallelogram. For warping, imaging the image is on a flexible surface and we pull, push, stretch or compress the image as a whole into a new shape.</li>
</ul>
<p>All of these geometric transformations can be thought of in terms of geometry <strong>or</strong> in terms of linear algebra and matrix operations.</p>
<p><strong>Additional notes:</strong></p>
<ul>
<li>A more complex form of geometric transformation is called <em>perspective warping</em>. This treats the image as a part of a plane, and transforms the plane to a new location (as if the image was a printed painting, and we were viewing it moved to a new location).</li>
<li>For more details about the mathematics underlying geometric transformations, see the blog post on Geeks for Geeks, <a href="https://www.geeksforgeeks.org/electronics-engineering/geometric-transformation-in-image-processing-1/">Geometric Transformation in Image Processing</a>.</li>
</ul>
<p>Affine warping can be thought of as a set of formulas that map pixel locations in the original image to where that pixel should appear in the new, transformed image. The formulas are shown below:</p>
<p><span class="math display">\[x_{new} = a \cdot x_{old} + b \cdot y_{old} + t_x\]</span></p>
<p><span class="math display">\[y_{new} = c \cdot x_{old} + d \cdot y_{old} + t_y\]</span></p>
<p>We can write these in terms of matrix and vector operations, like this:</p>
<p><span class="math display">\[
\begin{bmatrix}
x_{new} \\
y_{new} \\
1
\end{bmatrix} =
\begin{bmatrix}
a &amp; b &amp; t_x \\
c &amp; d &amp; t_y \\
0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\cdot \begin{bmatrix}
x_{old} \\
y_{old} \\
1
\end{bmatrix}
\]</span></p>
<p>The effect of the transformation depends on the values of the four coefficients, <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>, and <span class="math inline">\(d\)</span>, as well as the two constants <span class="math inline">\(t_x\)</span> and <span class="math inline">\(t_y\)</span>. By varying those six values, we can perform all kinds of geometric transformations. In the next subsections, weâ€™ll take a look at each type of transformation.</p>
<section id="translation" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="translation"><span class="header-section-number">2.1</span> Translation</h2>
<p>To translate an image, we want to move every pixel the same distance in the x direction, and the same distance in the y direction. In math terms, this looks like:</p>
<p><span class="math display">\[x_{new} = x_{old} + t_x\]</span> <span class="math display">\[y_{new} = y_{old} + t_y\]</span></p>
<p>Compare this formula to the affine warping formula above, and you can see how we can choose values for <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>, and <span class="math inline">\(d\)</span> to make these formulas out of the original (Let <span class="math inline">\(a= 1\)</span>, <span class="math inline">\(b = 0\)</span>, <span class="math inline">\(c = 0\)</span>, and <span class="math inline">\(d = 1\)</span>). Because the matrix for translation will always have this simple form, when we program it, we will have to make the matrix ourselves. Look at the 3x3 matrix shown above; since the bottom row is always fixed in value, we only have to specify the top two rows when doing an affine warp in OpenCV.</p>
<p>In the code below, we use the <code>warpAffine</code> function to translate the contents of the image 100 pixels to the right, and 50 pixels down. This function takes in an image, and a 2x3 matrix of floating-point values that specify the six values from the affine warping formulas/matrix. We also tell the function how large to make the output image: it is common to keep it the same size, but we can choose any size we want.</p>
<div id="a9533e03" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="annotated-cell-2"><pre class="sourceCode numberSource python code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-2-1"><a href="#annotated-cell-2-1"></a><span class="im">import</span> cv2</span>
<span id="annotated-cell-2-2"><a href="#annotated-cell-2-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="annotated-cell-2-3"><a href="#annotated-cell-2-3"></a></span>
<span id="annotated-cell-2-4"><a href="#annotated-cell-2-4"></a>img <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/antiqueTractors.jpg"</span>)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="1">1</button><span id="annotated-cell-2-5" class="code-annotation-target"><a href="#annotated-cell-2-5"></a>(hgt, wid, dep) <span class="op">=</span> img.shape</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="2">2</button><span id="annotated-cell-2-6" class="code-annotation-target"><a href="#annotated-cell-2-6"></a>tMatrix <span class="op">=</span> np.matrix([[<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">100</span>], [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">50</span>]], np.float32)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="3">3</button><span id="annotated-cell-2-7" class="code-annotation-target"><a href="#annotated-cell-2-7"></a>newIm <span class="op">=</span> cv2.warpAffine(img, tMatrix, (wid, hgt))</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-2" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="5" data-code-annotation="1">Gets the size of the original, so we can set the new image to that size</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="6" data-code-annotation="2">Makes a 32-bit floating-point matrix with the values for translating in both x and y directions</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="7" data-code-annotation="3">Creates a translated image the same size as the original</span>
</dd>
</dl>
</div>
</div>
<p><a href="#fig-translate" class="quarto-xref">Figure&nbsp;2</a> shows the result of this transformation.</p>
<div id="fig-translate" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-translate-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="Ch5-Images/transimg.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Figure&nbsp;2: Tractor image translated to the right by 100 pixels and down by 50 using affine warping"><img src="Ch5-Images/transimg.jpg" class="img-fluid figure-img" style="width:12cm"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-translate-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Tractor image translated to the right by 100 pixels and down by 50 using affine warping
</figcaption>
</figure>
</div>
</section>
<section id="rotation" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="rotation"><span class="header-section-number">2.2</span> Rotation</h2>
<p>Rotating an image is closely related to the rotation of axes, a topic you may have studied in school earlier (in the US, it is often covered in precalculus classes). In linear algebra terms, there is a <a href="https://en.wikipedia.org/wiki/Rotation_matrix"><em>rotation matrix</em></a> that can perform a rotation. With affine warping, we could build and use a version of this rotation matrix to perform rotations.</p>
<p>However, OpenCV is going to do some of the hard work for us! Instead of us remember the formulas for the affine warping rotation matrix, OpenCV implements a function, <code>getRotationMatrix2d</code> that calculates the correct rotation matrix for us. This function has three inputs: the (x, y) coordinates of the pixel that should be the center of rotation, the angle to rotate by (positive values rotate counter-clockwise), and a scaling factor (in case we want to resize the rotated image at the same time). <a href="#fig-rotMatrix" class="quarto-xref">Figure&nbsp;3</a> shows what these inputs mean. We can choose any pixel in the image as the center of rotation. Think of this as a putting a pin at a specific pixel, and then rotating the image around that point. The angle, given in degrees, tells how far to rotate in the counter-clockwise direction.</p>
<div id="fig-rotMatrix" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-rotMatrix-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="Ch5-Images/opencvRotate.drawio.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Figure&nbsp;3: Rotation using getRotationMatrix2d with center of rotation and angle of rotation specified"><img src="Ch5-Images/opencvRotate.drawio.png" class="img-fluid figure-img" style="width:15cm"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-rotMatrix-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Rotation using <code>getRotationMatrix2d</code> with center of rotation and angle of rotation specified
</figcaption>
</figure>
</div>
<p>The code example below rotates the image three different amounts, and #fig-rotExamples shows the resulting images.</p>
<div id="314f77ac" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>origIm <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/canyonlands.jpg"</span>)</span>
<span id="cb2-2"><a href="#cb2-2"></a>(hgt, wid, dep) <span class="op">=</span> origIm.shape</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a>rot1Mat <span class="op">=</span> cv2.getRotationMatrix2D((wid<span class="op">//</span><span class="dv">2</span>, hgt<span class="op">//</span><span class="dv">2</span>), <span class="dv">45</span>, <span class="dv">1</span>)</span>
<span id="cb2-5"><a href="#cb2-5"></a>imRot1 <span class="op">=</span> cv2.warpAffine(origIm, rot1Mat, (wid, hgt))</span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a>rot2Mat <span class="op">=</span> cv2.getRotationMatrix2D((<span class="dv">100</span>, <span class="dv">100</span>), <span class="op">-</span><span class="dv">70</span>, <span class="dv">1</span>)</span>
<span id="cb2-8"><a href="#cb2-8"></a>imRot2 <span class="op">=</span> cv2.warpAffine(origIm, rot2Mat, (wid, hgt))</span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a>rot3Mat <span class="op">=</span> cv2.getRotationMatrix2D((wid<span class="op">//</span><span class="dv">2</span>, hgt<span class="op">//</span><span class="dv">2</span>), <span class="dv">160</span>, <span class="fl">0.75</span>)</span>
<span id="cb2-11"><a href="#cb2-11"></a>imRot3 <span class="op">=</span> cv2.warpAffine(origIm, rot3Mat, (<span class="bu">int</span>(<span class="fl">1.5</span><span class="op">*</span>wid), <span class="bu">int</span>(<span class="fl">1.5</span><span class="op">*</span>hgt)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-rotExamples" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-rotExamples-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch5-Images/canyonlands.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Original image"><img src="Ch5-Images/canyonlands.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Original image</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch5-Images/rot1.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-8" title="Rotated counter-clockwise around center by 45 degrees"><img src="Ch5-Images/rot1.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Rotated counter-clockwise around center by 45 degrees</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch5-Images/rot2.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-9" title="Rotated clockwise around (100, 100) by 70 degrees"><img src="Ch5-Images/rot2.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Rotated clockwise around (100, 100) by 70 degrees</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch5-Images/rot3.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-10" title="Rotated counter-clockwise around center by 160 degrees, scaled down to 3/4 size, viewed on larger image"><img src="Ch5-Images/rot3.jpg" class="img-fluid figure-img"></a></p>
<figcaption>Rotated counter-clockwise around center by 160 degrees, scaled down to 3/4 size, viewed on larger image</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-rotExamples-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Three different rotations of an image, demonstrating variations of angle, center point, and scaling.
</figcaption>
</figure>
</div>
</section>
<section id="general-affine-warping" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="general-affine-warping"><span class="header-section-number">2.3</span> General affine warping</h2>
<p>Besides translation and rotation, the affine warping formulas can be used in ways that skew, twist, and warp the original image. Rather than building the 2x3 matrix by hand, as we did for translation, we will instead use a helper function, like we did for rotation, to build the matrix for us.</p>
<p>The affine warping formulas are fairly simple: just a linear combinations of the old x and old y values. Because of this, we can <em>derive</em> the values for the 2x3 matrix just by knowing how to map a small set of points from the original to locations in the new image. In fact, we only need three points (as long as the points do not all lie in a straight line).</p>
<p><a href="#fig-warpPoints" class="quarto-xref">Figure&nbsp;5</a> illustrates this process. We pick 3 points, A, B and C, from the original image, and decide where those points should go in the warped image (on the right). Then OpenCV will help us to figure out how to calculate the transformation for all other points. The figure shows four points, rather than three, because the more complex <em>perspective transform</em> requires four points. Affine warping only requires three.</p>
<div id="fig-warpPoints" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-warpPoints-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="Ch5-Images/warpPoints.png" class="lightbox" data-gallery="quarto-lightbox-gallery-11" title="Figure&nbsp;5: Illustrates how we pick points from the original image, and choose their new location in the warped image."><img src="Ch5-Images/warpPoints.png" class="img-fluid figure-img" style="width:18cm"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-warpPoints-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Illustrates how we pick points from the original image, and choose their new location in the warped image.
</figcaption>
</figure>
</div>
<p>OpenCV provides a helper function, <code>getAffineTransform</code>, that does this derivation. We pass this function two sets of (x, y) coordinates: three points from the original image, and then the points in the new image that should correspond with our three chosen points. In other words, we tell it where we want the three original points to move to in the new, warped image. Specify the points as two Numpy arrays, each with 3 rows and 2 columns, both as 32-bit floating point numbers. Below I show the form of the points arrays, as matrices in math notation.</p>
<p><span class="math display">\[
\begin{array}{cc}
origPts = \begin{bmatrix}
   ox_1 &amp; oy_1 \\
   ox_2 &amp; oy_2 \\
   ox_3 &amp; oy_3 \\
   \end{bmatrix}
&amp;
newPts = \begin{bmatrix}
   nx_1 &amp; ny_1 \\
   nx_2 &amp; ny_2 \\
   nx_3 &amp; ny_3 \\
   \end{bmatrix}
\end{array}
\]</span></p>
<p>Here is an example of how to create the point matrices, get the affine matrix, and apply it to an image.</p>
<div id="5999d2c8" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="annotated-cell-4"><pre class="sourceCode numberSource python code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-4-1"><a href="#annotated-cell-4-1"></a><span class="im">import</span> cv2</span>
<span id="annotated-cell-4-2"><a href="#annotated-cell-4-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="annotated-cell-4-3"><a href="#annotated-cell-4-3"></a></span>
<span id="annotated-cell-4-4"><a href="#annotated-cell-4-4"></a>img <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/snowLeo2.jpg"</span>)</span>
<span id="annotated-cell-4-5"><a href="#annotated-cell-4-5"></a>cv2.imshow(<span class="st">"Original"</span>, img)</span>
<span id="annotated-cell-4-6"><a href="#annotated-cell-4-6"></a>(rows, cols, depth) <span class="op">=</span> img.shape</span>
<span id="annotated-cell-4-7"><a href="#annotated-cell-4-7"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="1">1</button><span id="annotated-cell-4-8" class="code-annotation-target"><a href="#annotated-cell-4-8"></a>origPts <span class="op">=</span> np.float32([[<span class="dv">40</span>, <span class="dv">40</span>], [<span class="dv">350</span>, <span class="dv">40</span>], [<span class="dv">40</span>, <span class="dv">350</span>]])</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="2">2</button><span id="annotated-cell-4-9" class="code-annotation-target"><a href="#annotated-cell-4-9"></a>newPts <span class="op">=</span> np.float32([[<span class="dv">240</span>, <span class="dv">10</span>], [<span class="dv">350</span>, <span class="dv">350</span>], [<span class="dv">10</span>, <span class="dv">240</span>]])</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="3">3</button><span id="annotated-cell-4-10" class="code-annotation-target"><a href="#annotated-cell-4-10"></a>mat <span class="op">=</span> cv2.getAffineTransform(origPts, newPts)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="4">4</button><span id="annotated-cell-4-11" class="code-annotation-target"><a href="#annotated-cell-4-11"></a>warpImg <span class="op">=</span> cv2.warpAffine(img, mat, (<span class="dv">2</span> <span class="op">*</span> cols, <span class="dv">2</span> <span class="op">*</span> rows))</span>
<span id="annotated-cell-4-12"><a href="#annotated-cell-4-12"></a>cv2.imshow(<span class="st">"Warped"</span>, warpImg)</span>
<span id="annotated-cell-4-13"><a href="#annotated-cell-4-13"></a>cv2.waitKey(<span class="dv">0</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-4" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="8" data-code-annotation="1">Creates the array of original points as Numpyâ€™s <code>float32</code> dtype</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="9" data-code-annotation="2">Creates the array of new points as Numpyâ€™s <code>float32</code> dtype</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="10" data-code-annotation="3">Derive the affine matrix from these two matrices</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="11" data-code-annotation="4">Create the warped image according to the matrix, drawing on a larger image size</span>
</dd>
</dl>
</div>
</div>
<p>In <a href="#fig-affWarp" class="quarto-xref">Figure&nbsp;6</a> below, we show the original image and the warped one. The warped image is shown on a background image twice as wide and twice as tall as the original. For this, we augmented the code above to draw a small circle at each of the chosen points: cyan for the first pair of points, yellow for the second, and magenta for the third.</p>
<div id="fig-affWarp" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-affWarp-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch5-Images/affOrig.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-12" title="Original image"><img src="Ch5-Images/affOrig.jpg" class="img-fluid figure-img" style="width:10cm"></a></p>
<figcaption>Original image</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Ch5-Images/affWarp.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-13" title="Warped version"><img src="Ch5-Images/affWarp.jpg" class="img-fluid figure-img" style="width:18cm"></a></p>
<figcaption>Warped version</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-affWarp-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: The original image and the result of affine warping from the example above.
</figcaption>
</figure>
</div>
</section>
<section id="a-note-about-the-perspective-transform" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="a-note-about-the-perspective-transform"><span class="header-section-number">2.4</span> A note about the <em>perspective transform</em></h2>
<p>In addition to affine warping, OpenCV provides another type of warping, the perspective transform. This is based on somewhat more sophisticated, and expensive, math. It simulates the kind of view you would have if the image was printed out on rigid paper, and you looked at it from different perspectives. And it matches the kind of vanishing-point perspective used in art to show realistic depth. When you transform an imate that contains a pair of parallel lines using affine warping, the lines will remain parallel to each other, but they may turn into curved lines. By contrast, if you transform the same image with the perspective transform, the lines will remain straight, but they wonâ€™t remain parallel to each other.</p>
<p>Using the perspective transformation is very similar to the affine transformation. You are encouraged to look up the details in <a href="https://docs.opencv.org/4.x/d2/de8/group__core__array.html#gad327659ac03e5fd6894b90025e6900a7">the OpenCV documentation</a>.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
        for (let i=0; i<annoteTargets.length; i++) {
          const annoteTarget = annoteTargets[i];
          const targetCell = annoteTarget.getAttribute("data-target-cell");
          const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
          const contentFn = () => {
            const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
            if (content) {
              const tipContent = content.cloneNode(true);
              tipContent.classList.add("code-annotation-tip-content");
              return tipContent.outerHTML;
            }
          }
          const config = {
            allowHTML: true,
            content: contentFn,
            onShow: (instance) => {
              selectCodeLines(instance.reference);
              instance.reference.classList.add('code-annotation-active');
              window.tippy.hideAll();
            },
            onHide: (instance) => {
              unselectCodeLines();
              instance.reference.classList.remove('code-annotation-active');
            },
            maxWidth: 300,
            delay: [50, 0],
            duration: [200, 0],
            offset: [5, 10],
            arrow: true,
            appendTo: function(el) {
              return el.parentElement.parentElement.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'quarto',
            placement: 'right',
            popperOptions: {
              modifiers: [
              {
                name: 'flip',
                options: {
                  flipVariations: false, // true by default
                  allowedAutoPlacements: ['right'],
                  fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
                },
              },
              {
                name: 'preventOverflow',
                options: {
                  mainAxis: false,
                  altAxis: false
                }
              }
              ]        
            }      
          };
          window.tippy(annoteTarget, config); 
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>