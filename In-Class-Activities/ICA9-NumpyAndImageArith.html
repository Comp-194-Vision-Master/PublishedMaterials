<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Susan Eileen Fox">
<meta name="dcterms.date" content="2025-08-12">

<title>ICA: Numpy Arrays and Image Arithmetic</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="ICA9-NumpyAndImageArith_files/libs/clipboard/clipboard.min.js"></script>
<script src="ICA9-NumpyAndImageArith_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="ICA9-NumpyAndImageArith_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="ICA9-NumpyAndImageArith_files/libs/quarto-html/popper.min.js"></script>
<script src="ICA9-NumpyAndImageArith_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ICA9-NumpyAndImageArith_files/libs/quarto-html/anchor.min.js"></script>
<link href="ICA9-NumpyAndImageArith_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ICA9-NumpyAndImageArith_files/libs/quarto-html/quarto-syntax-highlighting-226bd0f977fa82dfae4534cac220d79a.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ICA9-NumpyAndImageArith_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ICA9-NumpyAndImageArith_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ICA9-NumpyAndImageArith_files/libs/bootstrap/bootstrap-c9dc05ccd9e6568c662515419180efc4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">ICA: Numpy Arrays and Image Arithmetic</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Susan Eileen Fox </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 12, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#numpy-operations" id="toc-numpy-operations" class="nav-link" data-scroll-target="#numpy-operations">Numpy operations</a>
  <ul class="collapse">
  <li><a href="#creating-arrays" id="toc-creating-arrays" class="nav-link" data-scroll-target="#creating-arrays">Creating arrays</a></li>
  </ul></li>
  <li><a href="#image-arithmetic" id="toc-image-arithmetic" class="nav-link" data-scroll-target="#image-arithmetic">Image Arithmetic</a>
  <ul class="collapse">
  <li><a href="#subtracting-images" id="toc-subtracting-images" class="nav-link" data-scroll-target="#subtracting-images">Subtracting images</a></li>
  <li><a href="#blending-images" id="toc-blending-images" class="nav-link" data-scroll-target="#blending-images">Blending images</a></li>
  </ul></li>
  <li><a href="#accessing-channels" id="toc-accessing-channels" class="nav-link" data-scroll-target="#accessing-channels">Accessing channels</a></li>
  <li><a href="#regions-of-interest" id="toc-regions-of-interest" class="nav-link" data-scroll-target="#regions-of-interest">Regions of Interest</a></li>
  <li><a href="#what-to-hand-in" id="toc-what-to-hand-in" class="nav-link" data-scroll-target="#what-to-hand-in">What to hand in</a></li>
  </ul>
</nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="overview" class="level1">
<h1>Overview</h1>
<p>In this activity, we will take a closer look at images as matrices and what we can do with them in that context. You will practice with basic Numpy tools operating on both image arrays and smaller practice arrays. We will look at how to use simple arithmetic operations on matrices to change colors, brightness, and more. We will examine how to access the channels of an image, and will create <strong>regions of interest</strong>, subsections of images that we want to focus on.</p>
<p>The Github repository for this assignment will contain a starter code file, <code>activ9.py</code>. Put your code in this file, as directed by the <code>TODO</code> comments.</p>
</section>
<section id="numpy-operations" class="level1">
<h1>Numpy operations</h1>
<section id="creating-arrays" class="level2">
<h2 class="anchored" data-anchor-id="creating-arrays">Creating arrays</h2>
<p>The list of functions below allows us to create Numpy arrays from scratch. With this, we can make a blank canvas to use the Numpy drawing functions, create synthetic images, or just make a black and white <em>mask</em> or frame to apply to an image.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 86%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>array</code></td>
<td style="text-align: left;">Takes a sequence data type (list, string, tuple, or Numpy array), and builds a Numpy array with the same shape. Optional input allows us to specify the type of data for the array.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>zeros</code></td>
<td style="text-align: left;">Takes in a tuple giving dimensions, and an optional input for the type of data, and it makes an array with the given dimensions and type, all filled with zeros.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ones</code></td>
<td style="text-align: left;">Similar to <code>zeros</code> but it fills the array with the value 1.</td>
</tr>
</tbody>
</table>
<p><strong>Try this to hand in:</strong> Create a function <code>blackCanvas</code> that takes in two inputs, the width and height for the canvas, and it creates a new color Numpy array all filled with black, with the given width and height. It should <strong>return</strong> the new image array. In your main script, try several test calls to this function with different sizes of images, and draw a square centered in each.</p>
<p><strong>Try this to hand in:</strong> Create a function <code>rgbStripes</code> that takes in two inputs, the width and height for the new image. It should create a new image array of the given size. Then it should fill the first 1/3 of rows with red, the second 1/3 of rows with green, and the remaining rows with blue. There are at least four different ways of filling in the values (iterate over each row and column with nested for loops, iterate over each row and use slicing to assign the whole row at once, use slicing to select the whole region to be red, or green, or blue, or build a list the shape of the image and then convert it to a Numpy array). Pick the approach that suits you the best!</p>
</section>
</section>
<section id="image-arithmetic" class="level1">
<h1>Image Arithmetic</h1>
<p>Remember that both Numpy and OpenCV provide tools for doing arithmetic on images. This means we can add or subtract a constant amount to every value in an image, changing the overall brightness of the image. We can also add or subtract images from each other, so long as they are the same shape: corresponding values in the image arrays are added or subtracted from each other.</p>
<section id="subtracting-images" class="level2">
<h2 class="anchored" data-anchor-id="subtracting-images">Subtracting images</h2>
<p>We can perform a simple kind of motion detection on frames from a video, by subtracting one frame from its predecessor. The Numpy module tells Python how to interpret the minus sign when applied to Numpy arrays. OpenCV has two functions for taking the difference: <code>subtract</code> and <code>absdiff</code>. The first one just does subtraction, the second one computes the absolute value of the difference for each corresponding value in the arrays.</p>
<p><strong>Try this to hand in:</strong> In the script section of the starter code file, add a script to experiment with subtracting two frames from a video (this video is one we will work with later, it shows Prof.&nbsp;Fox holding an orange ball and moving it around in the air):</p>
<ul>
<li>Start by reading in <code>frame1.jpg</code> and <code>frame2.jpg</code></li>
<li>Use <code>imshow</code> to display the two images; notice that frame 1 is slightly different from frame 2</li>
<li>Define a new image <code>diff1</code> to be the result of calculating frame 1 minus frame 2, using the minus sign (<code>-</code>)</li>
<li>Define another new image <code>diff2</code> to hold the result of OpenCV’s <code>subtract</code> function applied to frame 1 and frame 2</li>
<li>Define a third new image <code>diff3</code> to hold the result of OpenCV’2 <code>absdiff</code> function</li>
<li>Use <code>imshow</code> to display all three diff images</li>
<li>Examine the results. Based on what you know about how Numpy and OpenCV handle arithmetic, and how <code>subtract</code> and <code>absdiff</code> differ from each other, explain why the three difference images look the way they are, and how they are different. <strong>Write this explanation in the starter code file, as a comment</strong></li>
</ul>
</section>
<section id="blending-images" class="level2">
<h2 class="anchored" data-anchor-id="blending-images">Blending images</h2>
<p>We can use image arithmetic to blend two images together, using the <code>addWeighted</code> function from OpenCV. To blend two images, we want to look at corresponding pixels, and average their two red values to make a new red value, and do similarly with green and blue channel values. <em>(It is kind of amazing that this works, actually!)</em></p>
<p><strong>Resizing images</strong></p>
<p>In order to blend two images, we need to make them the same size and shape. We could do that using the Numpy slicing operators, but here we will take a look at a function that lets you resize an image either by scaling it to a specific size, or by scaling it by given factors in the x and y directions.</p>
<div id="dec60dfe" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a>cv2.resize(<span class="op">&lt;</span>img<span class="op">&gt;</span>, (<span class="op">&lt;</span>wid<span class="op">&gt;</span>, <span class="op">&lt;</span>hgt<span class="op">&gt;</span>), fx<span class="op">=</span>?, fy<span class="op">=</span>?)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The <code>resize</code> function takes in the image to be resized, and a tuple giving the new size as width followed by depth, and it returns a new image of the new size. However, if we set the width and height in the tuple to be zero, then we can provide optional inputs that give the new size as a factor of the original. The optional input <code>fx</code> specifies the factor in the x dimension, and <code>fy</code> in the y dimension. If we set <code>fx</code> to 0.5, for example, then the new image will have a width one half the size of the original’s width.</p>
<p>The examples below illustrate different ways of calling <code>resize</code>.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 55%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Examples</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>cv2.resize(src, (100, 100))</code></td>
<td style="text-align: left;">Returns a new stretch/squashed image that is 100 x 100 pixels</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>cv2.resize(src, (0, 0), fx = 2, fy = 2)</code></td>
<td style="text-align: left;">Returns a new image twice the size of the original</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>cv2.resize(src, (0, 0), fx = 0.5, fy = 1.0)</code></td>
<td style="text-align: left;">Returns a new image whose width is half the original size</td>
</tr>
</tbody>
</table>
<p><strong>Try this to hand in:</strong> In the script section of the activity code file, read in three images from <code>SampleImages</code> (any ones you choose). Use the <code>resize</code> command to change the second and third images to match the size of the first. Be sure to <code>imshow</code> the images so that you can check your work. <strong>Call these images <code>img1</code>, <code>img2</code>, and <code>img3</code>.</strong></p>
<p><strong>Blending with arithmetic</strong></p>
<p>Examine the code fragment below (also reproduced in your activity code file).</p>
<div id="bd586b98" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>blendImg1 <span class="op">=</span> cv2.add(img1, img2)</span>
<span id="cb2-2"><a href="#cb2-2"></a>cv2.imshow(<span class="st">"Blend by adding"</span>, blendImg1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Try this fragment on the resized images you created in the previous section, and observe the results. If we just add the two images, the result is too bright, and would have tons of overflow artifacts if we used Numpy addition. We want to <em>average</em> the two image values, not just add them. But consider this: if we first add the images, and then divide by 2 (the way we typically think about computing an average) the result will be distorted. Even OpenCV’s addition operator avoids overflow by capping the values at 255 when they would have added up to more than 255. That means that adding and then dividing by 2 will produce a different result than dividing each original image by 2 and then adding.</p>
<p>Try the code below on the images you resized, and compare <code>blend1</code> and <code>blend2</code>.</p>
<div id="838c69f8" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>sumImg <span class="op">=</span> cv2.add(img1, img2)</span>
<span id="cb3-2"><a href="#cb3-2"></a>blend1 <span class="op">=</span> cv2.divide(sumImg, <span class="dv">2</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a>divImg1 <span class="op">=</span> cv2.divide(img1, <span class="dv">2</span>)</span>
<span id="cb3-5"><a href="#cb3-5"></a>divImg2 <span class="op">=</span> cv2.divide(img2, <span class="dv">2</span>)</span>
<span id="cb3-6"><a href="#cb3-6"></a>blend2 <span class="op">=</span> cv2.add(divImg1, divImg2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can also use Numpy commands to compute the average more easily, so long as we remember to divide first, and then add, to avoid overflow artifacts. Try this:</p>
<div id="78eebdd7" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>avgImg <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> img1 <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> img2</span>
<span id="cb4-2"><a href="#cb4-2"></a>blend3 <span class="op">=</span> avgImg.astype(np.uint8)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Weighted averages</strong></p>
<p>A normal average (add the two numbers and divide by 2) weights both pixels/images equally: 50% from one image and 50% from another. The previous example multipled each image by 0.5: by shifting from division to multiplication we can see that we are really multiplying each image by a <em>weight</em>, the percentage of the final image that should come from each image.</p>
<p>We can change the percentages, by changing the weights. Just make sure they are each between 0.0 and 1.0 and that they add up to 1.0, so that the resulting image has the same brightness as the originals.</p>
<p>Try varying the weights for the example above, and examining the resulting blend.</p>
<p><strong>The <code>addWeighted</code> function</strong></p>
<p>OpenCV actually provides a function, <code>addWeighted</code>, to perform a weighted average of two images.</p>
<div id="2fa78991" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>blend4 <span class="op">=</span> cv2.addWeighted(img1, <span class="fl">0.5</span>, img2, <span class="fl">0.5</span>, <span class="dv">0</span>)   </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The <code>addWeighted</code> function has 5 required inputs: the first image to blend, the weight to multiply the first image by, the second image to blend, the weight for the second image, and a constant to add the result. In other words, the function computes this mathematical formula:</p>
<p><span class="math display">\[newIm = \alpha \cdot img1 + \beta \cdot img2 + \gamma\]</span></p>
<p>Try this as an alternative to the Numpy arithmetic version, and compare the results.</p>
<p><strong>Try this to hand in:</strong> Create a function <code>phaseBlend</code> that takes in two images presumed to be the same size. This function should include the following steps:</p>
<ul>
<li>Set up one weight value, <code>w</code>, to be 0.0 (<code>w</code> is an accumulator variable foer this loop)</li>
<li>Repeat with a <code>for</code> loop, ehough times for <code>w</code> to go to zero (experiment or calculate)</li>
<li>Inside the for loop, use <code>w</code> and <code>1 - w</code> as the weights, and blend the two input images, assigning the result to a variable</li>
<li>Also in the loop, <code>imshow</code> the blended result, and include a <code>waitkey</code></li>
<li>Finally, in the loop, add a small amount to <code>w</code> to change the weight for next time (use 0.1 or 0.05, or similar)</li>
<li><strong>Optional extension:</strong> Instead of trying to time the loop stopping to when <code>w</code> gets to 1.0, we could change the direction of the blend and start reducing <code>w</code> each time (until it gets to 0.0). To do this, we need another accumulator variable, <code>deltaW</code>, to hold the amount to change <code>w</code> by each time. It will stay at 0.1 or 0.05 until <code>w</code> reaches 1.0, and then it should change to be -0.1/-0.05.</li>
</ul>
</section>
</section>
<section id="accessing-channels" class="level1">
<h1>Accessing channels</h1>
<p>The <code>split</code> and <code>merge</code> functions allow us to pull apart an image’s channels, and put them back together again.</p>
<p><strong>Try this to hand in:</strong> Examine the code below, also found in your starter file.</p>
<div id="4efc2923" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>flowerIm <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/wildcolumbine.jpg"</span>)</span>
<span id="cb6-2"><a href="#cb6-2"></a>(blueChan, greenChan, redChan) <span class="op">=</span> cv2.split(flowerIm)</span>
<span id="cb6-3"><a href="#cb6-3"></a>cv2.imshow(<span class="st">"Original"</span>, flowerIm)</span>
<span id="cb6-4"><a href="#cb6-4"></a>cv2.imshow(<span class="st">"Blue channel alone"</span>, blueChan)</span>
<span id="cb6-5"><a href="#cb6-5"></a>cv2.imshow(<span class="st">"Green channel alone"</span>, greenChan)</span>
<span id="cb6-6"><a href="#cb6-6"></a>cv2.imshow(<span class="st">"Red channel alone"</span>, redChan)</span>
<span id="cb6-7"><a href="#cb6-7"></a>cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>When you run this code, what happens, and why?</strong> Discuss with classmates, preceptor, or instructor if you aren’t sure why the channels appear the way they do when displayed.</p>
<p>Add a call to <code>merge</code> to your code file, right after these lines. Merge takes in a tuple of three channels, and treats them as the blue, green, and red channels of the image. Try these variations:</p>
<ul>
<li>Make an exact copy of the original, by calling <code>merge</code> and passing it a tuple containing the channel images in the original order (blue, then green, then red). (Be sure to <code>imshow</code> the result.)</li>
<li>Use <code>zeros</code> to make a copy of the red channel that is all filled with zeros. Call <code>merge</code> again, but replace the red channel with the new blank one. How does it differ? What if you make a white image the same shape as the red channel, and then used that in <code>merge</code>?</li>
<li>Call <code>merge</code> a third time, and use the original three channels, but put them in a different order. What does the result look like?</li>
</ul>
<p><strong>Can you explain the results you see? If not, discuss with a neighbor or teammate, or with preceptor or faculty member.</strong></p>
<p><strong>Try this to hand in:</strong> Create a function, <code>colorShuffle</code>, that takes in one image as an input parameter. It will return a new image that has the three color channels randomly shuffled to a new order!</p>
<p>Do this:</p>
<ul>
<li>Add an import statement at the top of the file to import the <code>random</code> module</li>
<li>Inside the function, use <code>split</code> to separate the three channels from each other</li>
<li>Define a variable to hold a list with the three channel arrays in it</li>
<li>Call <code>random.shuffle</code> and pass it the list from the previous step (this will change the list to a new ordering, try printing the list before and after to see how <code>shuffle</code> works)</li>
<li>Pass <code>merge1</code> the list to get the new image</li>
<li>Return the image</li>
</ul>
</section>
<section id="regions-of-interest" class="level1">
<h1>Regions of Interest</h1>
<p>A region of interest is a section of an image that we want to focus on. Often it is the result of running computer vision algorithms to determine where something interesting is in the image, but it could also be human-designed.</p>
<p>At its core, we make a region of interest using Numpy’s array slicing operator. We will practice the slicing operator here, on small arrays and on images.</p>
<p><em>Key idea:</em> Remember that Numpy often avoids copying the data in an array, both when we use slicing to access portions of it, and when we use the <code>astype</code> method to change the type of data. Instead, it provides a <strong>view</strong> of the original data, either limiting the indices we can see, or mapping the values to a new type as we access them. When this happens, changes to the original array show up in the view array, and vice versa.</p>
<p>Consider the small 2d array shown in the code below.</p>
<div id="3f032af8" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>arr1 <span class="op">=</span> np.array([[<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">8</span>], [<span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">9</span>, <span class="dv">12</span>], [<span class="dv">4</span>, <span class="dv">8</span>, <span class="dv">12</span>, <span class="dv">16</span>]])</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="bu">print</span>(arr1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[ 2  4  6  8]
 [ 3  6  9 12]
 [ 4  8 12 16]]</code></pre>
</div>
</div>
<p>If we want to access and individual element of the array, we can put its row and column indices inside square brackets, separated by commas:</p>
<div id="b0f1404a" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="bu">print</span>(<span class="st">"last of second row:"</span>, arr1[<span class="dv">1</span>, <span class="dv">3</span>])</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="bu">print</span>(<span class="st">"second of last row:"</span>, arr1[<span class="dv">2</span>, <span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>last of second row: 12
second of last row: 8</code></pre>
</div>
</div>
<p>If we want a subarray, we extend this notation to use slicing operators for the row or column we are selecting from. Here are a few examples:</p>
<div id="a30d8321" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="bu">print</span>(<span class="st">"middle values:"</span>, arr1[<span class="dv">1</span>, <span class="dv">1</span>:<span class="dv">3</span>])</span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="bu">print</span>(<span class="st">"third and fourth columns:"</span>)</span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="bu">print</span>(arr1[:, <span class="dv">2</span>:<span class="dv">4</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>middle values: [6 9]
third and fourth columns:
[[ 6  8]
 [ 9 12]
 [12 16]]</code></pre>
</div>
</div>
<p>Now you try some examples, putting your code in the script section indicated by a TODO comment.</p>
<ul>
<li>Access just the value 16 from this array</li>
<li>Access the first column of the array</li>
<li>Select the last two elements from the first two rows (giving a 2x2 matrix)</li>
<li>Select values from every other row, and every other column, starting with the 2 at [0, 0]</li>
</ul>
<p>When working with images, we typically use slicing in two ways: to select the color at a specific pixel, or to select a rectangular region of the picture. The code sample below illustrates two ways to select the color channels from a specific pixel location. It also draws a tiny circle at that location on the image and displays it.</p>
<div id="be276630" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a>img <span class="op">=</span> cv2.imread(<span class="st">"SampleImages/antiqueTractors.jpg"</span>)</span>
<span id="cb13-2"><a href="#cb13-2"></a>col1 <span class="op">=</span> img[<span class="dv">150</span>, <span class="dv">325</span>, :]</span>
<span id="cb13-3"><a href="#cb13-3"></a>col2 <span class="op">=</span> img[<span class="dv">150</span>, <span class="dv">325</span>]</span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="bu">print</span>(col1, col2)</span>
<span id="cb13-5"><a href="#cb13-5"></a>cv2.circle(img, (<span class="dv">325</span>, <span class="dv">150</span>), <span class="dv">2</span>, (<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>))</span>
<span id="cb13-6"><a href="#cb13-6"></a>cv2.imshow(<span class="st">"Image"</span>, img)</span>
<span id="cb13-7"><a href="#cb13-7"></a>cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Notice that this is one of the places where Numpy and OpenCV’s different ordering of rows and columns comes into play: Numpy orders the location as (row, column), but when we specify the location for drawing the circle, we give it as (x, y).</p>
<p>To access a region of an image, we select the range of rows, then the range of columns, and then place a colon (<code>:</code>) for the channel dimension, to indicate we want all three channels.</p>
<div id="59a2591b" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a>steer <span class="op">=</span> img[<span class="dv">150</span>:<span class="dv">225</span>, <span class="dv">410</span>:<span class="dv">460</span>, :]</span>
<span id="cb14-2"><a href="#cb14-2"></a>cv2.rectangle(img, (<span class="dv">410</span>, <span class="dv">150</span>), (<span class="dv">460</span>, <span class="dv">225</span>), (<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>))</span>
<span id="cb14-3"><a href="#cb14-3"></a>cv2.imshow(<span class="st">"Image"</span>, img)</span>
<span id="cb14-4"><a href="#cb14-4"></a>cv2.imshow(<span class="st">"ROI"</span>, steer)</span>
<span id="cb14-5"><a href="#cb14-5"></a>cv2.waitKey()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Try these to hand in:</strong></p>
<ul>
<li>Create an interactive function, <code>colorShow</code>, to let the user input coordinates, and show the resulting color in a small image window.
<ul>
<li>This function will take one input, the image we are going to sample colors from</li>
<li>Inside the function, display the input image and wait for a key press</li>
<li>next, create a small blank image, <code>colorDisplay</code>, that is 100 by 100 pixels in size.</li>
<li>Add a <code>for</code> loop to repeat some number of times (like 5 or 10 times)</li>
<li>Inside the loop, ask the user to input first the x coordinate, and then ask them to input the y coordinate (remember to convert the string the user enters to an integer)</li>
<li>Use slicing to pull out the color at that (x, y) coordinate (remember to switch the ordering when slicing to y first, then x)</li>
<li>Draw a circle with radius 2 centered on the (x, y) coordinate the user entered</li>
<li>Display the image (it’s okay if old circles still show up)</li>
<li>Set the color at every pixel of <code>colorDisplay</code> to be the selected color</li>
<li>Display <code>colorDisplay</code> in its own window</li>
<li>Add a <code>waitKey</code> at the end</li>
</ul></li>
<li>Create a function <code>centerCrop</code> that takes in an image as its input parameter. The function should make and return an ROI that is 200x200 pixels, centered in the image.
<ul>
<li>Get the height and width of the image, and from that calculate the center row and center column</li>
<li>Define an ROI that extends 100 to the either side of the center column and 100 to either side of the center row</li>
<li>Display the ROI and the original, and use <code>waitKey</code>e to pause</li>
<li>Return the ROI</li>
</ul></li>
</ul>
</section>
<section id="what-to-hand-in" class="level1">
<h1>What to hand in</h1>
<p>Put all of your function definitions for this activity into a single file to be submitted. Make sure you format your code appropriately:</p>
<ul>
<li>At the top of the file is a triple-quoted string describing the file</li>
<li>Next you include all import statements</li>
<li>Next you have your function definitions, visually separated by blank lines, and maybe comments with dashed or other visual horizontal lines</li>
<li>Each function should have a triple-quoted descriptive comment right after the <code>def</code> line</li>
<li>All calls to all functions should be in a script at the bottom of the file, ideally inside an <code>if __name__ ...</code> block</li>
</ul>
<p>Use <em>commit</em> and <em>push</em> to copy your code to Github to submit this work.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
        for (let i=0; i<annoteTargets.length; i++) {
          const annoteTarget = annoteTargets[i];
          const targetCell = annoteTarget.getAttribute("data-target-cell");
          const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
          const contentFn = () => {
            const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
            if (content) {
              const tipContent = content.cloneNode(true);
              tipContent.classList.add("code-annotation-tip-content");
              return tipContent.outerHTML;
            }
          }
          const config = {
            allowHTML: true,
            content: contentFn,
            onShow: (instance) => {
              selectCodeLines(instance.reference);
              instance.reference.classList.add('code-annotation-active');
              window.tippy.hideAll();
            },
            onHide: (instance) => {
              unselectCodeLines();
              instance.reference.classList.remove('code-annotation-active');
            },
            maxWidth: 300,
            delay: [50, 0],
            duration: [200, 0],
            offset: [5, 10],
            arrow: true,
            appendTo: function(el) {
              return el.parentElement.parentElement.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'quarto',
            placement: 'right',
            popperOptions: {
              modifiers: [
              {
                name: 'flip',
                options: {
                  flipVariations: false, // true by default
                  allowedAutoPlacements: ['right'],
                  fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
                },
              },
              {
                name: 'preventOverflow',
                options: {
                  mainAxis: false,
                  altAxis: false
                }
              }
              ]        
            }      
          };
          window.tippy(annoteTarget, config); 
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>