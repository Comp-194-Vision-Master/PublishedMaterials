[
  {
    "objectID": "Homework/Homework2.html",
    "href": "Homework/Homework2.html",
    "title": "Homework 2",
    "section": "",
    "text": "This assignment is individual work!\n\nDo not share or borrow solutions from other students.\nDo not use AI assistants to generate code for you.\nDo ask preceptors and instructors for help with the code, including what to write and debugging.\nDo ask peers or AI assistants for help in understanding error messages, but not for help in writing or debugging your work.\n\nThis homework assignment will ask you to demonstrate your skills at understanding, debugging, planning, and creating python scripts and function. The list of topics for this assignment include:\n\nContinued work with lists, strings, and numbers, for loops and conditionals\nFunctions\nNumpy arrays\nImage “arithmetic”\nRegions of interest\n\nTo hand in: You will use the Homework 2 Github Assignment to set up this assignment, and to push your code to save it to the cloud, to hand it in. Note that all your work will go into a single file for this assignment. A starter file, hw2Code.py will be provided, add your work there, and test your work with the hw2Checker.py file.\nHandling images: I will provide in the Github assignment just those images you need to have to do this assignment."
  },
  {
    "objectID": "Homework/Homework2.html#specifications-for-question-1",
    "href": "Homework/Homework2.html#specifications-for-question-1",
    "title": "Homework 2",
    "section": "Specifications for Question 1",
    "text": "Specifications for Question 1\nBase specifications:\n\nSolution defines a function called divisBy\nFunction header correctly specifies the name and inputs for this function\nFunction always returns either a Boolean value (True or False) for any numeric input\nFunction returns the correct answer for any valid inputs\nCode includes a triple-quoted docstring that describes the function’s input, purpose, and results\n\nExtended specifications:\n\nStudent name is at the top of the file\nAny completed TODO comments have been removed\nFile format has appropriate style:\n\nimport statements at the top\nthen function definitions with no script elements\nthen the main script, all insidde the if __name__ == '__main__': statement\n\n\nRatings:\n\nTo receive a gold rating, complete at least 6 specifications, at least 4 of them base\nTo receive a silver rating, complete at least 5 specifications, at least 3 of them base\nTo receive a bronze rating, complete at least 4 specifications, at least 2 of them base"
  },
  {
    "objectID": "Homework/Homework2.html#specifications-for-question-2",
    "href": "Homework/Homework2.html#specifications-for-question-2",
    "title": "Homework 2",
    "section": "Specifications for Question 2",
    "text": "Specifications for Question 2\nBase specifications:\n\nPseudocode is readable: what each line does is clearly stated\nPseudocode includes an accumulator for the answer list\nPseudocode includes a loop over (some of) the indices in the list\nPseudocode adds all the correct values it should to the answer list accumulator\nPseudocode loops correctly over the indices\nPseudocode handles start and end position special cases correctly\n\nExtended specifications:\n\nStudent name is at the top of the file\nAny completed TODO comments have been removed\nFile format has appropriate style:\n\nimport statements at the top\nthen function definitions with no script elements\nthen the main script, all inside the if __name__ == '__main__': statement\n\n\nRatings:\n\nTo receive a gold rating, fully complete 6 specifications, at least 4 base, partially complete at least 2 more\nTo receive a silver rating, fully complete at least 6 specifications, at least 3 base, partially complete at least 1 more\nTo receive a bronze rating, fully complete at least 5 specifications, at lesat 2 base, partially complete at least 1 more"
  },
  {
    "objectID": "Homework/Homework2.html#your-task-an-algorithm-to-draw-circles-on-an-image",
    "href": "Homework/Homework2.html#your-task-an-algorithm-to-draw-circles-on-an-image",
    "title": "Homework 2",
    "section": "Your task: an algorithm to draw circles on an image",
    "text": "Your task: an algorithm to draw circles on an image\nYour goal is to plan out, in pseudocode, an algorithm that would take in an image and the number of circles, and it would draw that many circles on the image. Each circle should have a random location (its center point may be anywhere within the image), a random radius between 10 and 50, and a random color.\nThere are two main ways for you to make random colors.\n\nOne approach would be to make a palette, a list containing color tuples that you have selected. Then your algorithm would choose one of the tuples from the list randomly, for each circle.\nThe other approach is to generate random values for red, green, and blue, each one between 0 and 255. This would allow you to generate any possible color, but some of those colors might be very dark, very light, or just plain ugly.\n\nThis is your choice. Decide on it, and write your pseudocode so it is clear which approach you chose.\nPut your pseudocode for this question in the q3Pseudocode.txt file (note that it is not a Python file)."
  },
  {
    "objectID": "Homework/Homework2.html#specifications-for-question-3",
    "href": "Homework/Homework2.html#specifications-for-question-3",
    "title": "Homework 2",
    "section": "Specifications for Question 3",
    "text": "Specifications for Question 3\nBase specifications:\n\nSolution defines a function called randomCrop\nFunction header correctly specifies the name and inputs for this function\nFunction correctly computes the range of valid indices for the left edge of the crop, based on the width of the image and the input width\nFunction correctly computes the range of valid indices for the upper edge of the crop, based on the height of the image and the input height\nFunction correctly generates random left and upper indices for the crop\nFunction crops the image correctly by defining an ROI of the right size\nFunction returns the cropped image\nCode includes a triple-quoted docstring that describes the function’s input, purpose, and results\n\nExtended specifications:\n\nStudent name is at the top of the file\nAny completed TODO comments have been removed\nFile format has appropriate style:\n\nimport statements at the top\nthen function definitions with no script elements\nthen the main script, all insidde the if __name__ == '__main__': statement\n\n\nRatings:\n\nTo receive a gold rating, complete 8 specifications in all, at least 6 of them base specifications.\nTo receive a silver rating, complete at least 7 specifications in all, at least 5 of them base specifications.\nTo receive a bronze rating, complete at least 6 specifications in all, at least 4 of them base specification."
  },
  {
    "objectID": "Homework/Homework2.html#specifications-for-question-4",
    "href": "Homework/Homework2.html#specifications-for-question-4",
    "title": "Homework 2",
    "section": "Specifications for Question 4",
    "text": "Specifications for Question 4\nBase specifications:\n\nSolution defines a function called findMedian\nFunction header correctly specifies the name and inputs for this function\nFunction keeps the first two lines from findMinMax\nFunction correctly distinguishes even-length lists from odd-length lists, with an if statement\nFunction correctly finds and returns the middle value from an odd-length list\nFunction correctly finds and returns the average of the two middle values from an even-length list\nCode includes a triple-quoted docstring that describes the function’s input, purpose, and results\n\nExtended specifications:\n\nStudent name is at the top of the file\nAny completed TODO comments have been removed\nFile format has appropriate style:\n\nimport statements at the top\nthen function definitions with no script elements\nthen the main script, all insidde the if __name__ == '__main__': statement\n\n\nRatings:\n\nTo receive a gold rating, complete at least 8 specifications in all, at least 6 of them base specifications.\nTo receive a silver rating, complete at least 7 specifications in all, at least 5 of them base.\nTo receive a bronze rating, complete at least 6 total specifications, at least 4 of them base."
  },
  {
    "objectID": "Homework/Homework2.html#step-1-examine-and-understand-the-starter-code",
    "href": "Homework/Homework2.html#step-1-examine-and-understand-the-starter-code",
    "title": "Homework 2",
    "section": "Step 1: Examine and understand the starter code",
    "text": "Step 1: Examine and understand the starter code\nWork through the steps below that guide you in making sense of the starter program\n\nRun q5Rainbows.py. It should produce an output that looks like Figure 6.\n\n\n\n\n\n\n\nFigure 6: The final image from the starter code\n\n\n\n\nNotice that the red rectangles are drawn where we ultimately want the rainbows to be drawn\nExamine the script at the bottom of the file.\n\nIt reads in the image\nThen, it has a pair of nested for loops that iterate over (x, y) coordinates where we want to draw rainbows\nIt calls the function drawRainbow once for each (x, y) pair\nIt then displays the image\nThe call to waitKey here is passed the value 100, this causes the program to pause for 100 milliseconds and then to go on, not to wait indefinitely for the user to hit a key\n\nYou don’t need to modify the main script. Just understand what parts of the problem it does for us (placing rainbows in a grid and displaying the image)\nNext, examine the function drawRainbow.\n\nIt takes in the image and the (x, y) position to center the rainbow on (this will be the center point of the full ellipse, so when we draw a half-ellipse this point will sit on the bottom of the half-ellipse)\nNotice the defined list colors: this defines colors for the seven ROY-G-BIV rainbow colors\nNotice the call that draws the red rectangle: do you understand why we pass the two points the way we do?"
  },
  {
    "objectID": "Homework/Homework2.html#step-2-change-rectangle-for-half-ellipse",
    "href": "Homework/Homework2.html#step-2-change-rectangle-for-half-ellipse",
    "title": "Homework 2",
    "section": "Step 2: Change rectangle for half-ellipse",
    "text": "Step 2: Change rectangle for half-ellipse\nWe will use incremental development to change the program one step at a time toward what we want.\nFor this step, we want to change the red rectangle to a red half-ellipse that is centered on the (x, y) position that is a parameter of the function, and that has currSize for both horizontal and vertical axes. It should draw only the upper half of the ellipse (that might take some experimentation).\nRemove the call to rectangle and add a call to ellipse, changing the inputs accordingly. (Make sure you keep the assignment of currSize to 100, we will need that later!)\nThe result of this step should look like Figure 7; don’t go on until you are producing this result.\n\n\n\n\n\n\nFigure 7: The resulting image from step 2"
  },
  {
    "objectID": "Homework/Homework2.html#step-3-add-the-other-colors",
    "href": "Homework/Homework2.html#step-3-add-the-other-colors",
    "title": "Homework 2",
    "section": "Step 3: Add the other colors",
    "text": "Step 3: Add the other colors\nFor this last step, we are going to draw a series of ellipses centered at the same location, each one smaller than the one before, and each one the next color in the rainbow (and the colors list).\n\nBetween the definition of currSize and the call to ellipse, insert a for loop that iterates over the colors in the colors list.\nIndent the call to ellipse so it is part of the loop body.\nUse the loop variable in place of the current color in the call to ellipse (If you run the code at this point, you should see violet half-ellipses instead of red ones.)\nThe last step is to reduce the size of the half-ellipse for each iteration of the for loop. To do this we will turn currSize into an accumulator variable, by subtracting 15 from its value inside the loop. Add a line after the call to ellipse. Make sure the new line is indented to match the ellipse call. On that line, update currsize to have the value of currSize - 15.\n\nTry running the program at this point. If you’ve done each step correctly, you should see the target picture."
  },
  {
    "objectID": "Homework/Homework2.html#specifications-for-question-5",
    "href": "Homework/Homework2.html#specifications-for-question-5",
    "title": "Homework 2",
    "section": "Specifications for Question 5",
    "text": "Specifications for Question 5\nBase specifications:\n\nFind, correct, and label first bug in colorBlink function\nFind, correct, and label second bug in colorBlink function\nFind, correct, and label first bug in halfColorShuffle function\nFind, correct, and label second bug in halfColorShuffle function\nFind, correct, and label first bug in colorShuffle function\nFind, correct, and label second bug in colorShuffle function\n\nExtended specifications:\n\nStudent name is at the top of the file\nAny completed TODO comments have been removed\nFile format has appropriate style:\n\nimport statements at the top\nthen function definitions with no script elements\nthen the main script, all insidde the if __name__ == '__main__': statement\n\n\nRatings:\n\nTo receive a gold rating, complete at least 8 specifications in all, at least 5 of them base specifications.\nTo receive a silver rating, complete at least 7 specifications in all, at least 4 of them base.\nTo receive a bronze rating, complete at least 5 total specifications, at least 2 of them base."
  },
  {
    "objectID": "Homework/Homework2.html#specifications-for-question-6",
    "href": "Homework/Homework2.html#specifications-for-question-6",
    "title": "Homework 2",
    "section": "Specifications for Question 6",
    "text": "Specifications for Question 6\nBase specifications:\n\nSolution defines a function called sepia\nFunction header correctly specifies the name and inputs for this function\nFunction correctly separates the channels of the color image into three separate variables\nFunction correctly implements the first formula to calculate red values on the whole red channel at once\nFunction correctly implements the second formula to calculate green values on the whole red channel at once\nFunction correctly implements the third formula to calculate blue values on the whole red channel at once\nFunction correctly clips each channel and converts it back to np.uint8\nFunction returns the final image\nCode includes a triple-quoted docstring that describes the function’s input, purpose, and results\n\nExtended specifications:\n\nStudent name is at the top of the file\nAny completed TODO comments have been removed\nFile format has appropriate style:\n\nimport statements at the top\nthen function definitions with no script elements\nthen the main script, all inside the if __name__ == '__main__': statement\n\n\nRatings:\n\nTo receive a gold rating, complete at least 9 specifications in all, at least 7 of them base.\nTo receive a silver rating, complete at least 8 specifications in all, at least 6 of them base.\nTo receive a bronze rating, complete at least 7 total specifications, at least 5 of them base."
  },
  {
    "objectID": "Documents/ClassNotes1.html#orientation-meeting",
    "href": "Documents/ClassNotes1.html#orientation-meeting",
    "title": "Comp 194 Class Notes - Weeks 0-3",
    "section": "Orientation meeting",
    "text": "Orientation meeting\n\nAnnouncements:\n\n???\n\n\n\nToday’s plan:\n\nGetting to know each other\nAdvising\nCourse overview\nActivity\n\n\n\nIntroductions\nIntroduce yourself and tell us:\n\nYour name\nWhere is home for you right now?\nWhat are your academic interests?\nWhat do you like to do outside of school?\nPick an animal mascot for yourself: what is your favorite animal?\n\n\n\nWhat are the goals of the FYC program in general\n\nIntroduce students to critical inquiry within at least one discipline or interdisciplinary area.\nIntroduce students to library research skills.\nEnsure that students receive explicit writing instruction, including the opportunity to revise writing based on faculty feedback.\nHelp students adjust to Macalester’s academic expectations.\nConnect incoming students to advisors who get to know the students well from the start.\nProvide a supportive community of other first-year students with shared interests and experiences to aid in the transition to college.\n\n\n\nThings to know about classes at Macalester\nAttendance: Going to class is expected.\n\nIf you need to miss class, send an email to the professor explaining why.\n\n\n\n\n\n\n\nSample email\n\n\n\nDear Prof. Faculty Name,\nI am not going to be able to attend class on Day/Date, because Reason. I’m sorry about missing class, and I will do my best to make up anything I have missed. Please let me know if there are specific things I should be looking at; I will stop by your office hours to check in.\nStudent name\n\n\n\nTry to let your faculty member know before class time, as early as possible.\nPlan on getting notes or resources from the class (ideally from a peer, but also ask the professor or the preceptor).\nIf you are sick, stay home!\n\nOffice Hours: Office hours are times that faculty members set aside to meet with students. They are your time with your faculty members: a great time to ask questions, get feedback on your work, etc.\nWhen I am holding office hours and no one comes, I do other work. But I am happy to be interrupted by students coming with questions.\nHow much time do you have? You will spend less time in class than you probably did in high school. That puts more responsibility on you to plan your work and study times!\n\nYou may feel like you have too much free time: think about scheduling times for work, exercise, relaxation\nYou may get involved in many activities, and find yourself short of time: find tools for prioritizing your tasks and planning your time\n\nSeeking help: Sometimes incoming students come to Mac used to being the ones to help others out, and never needing help. Macalester is different and can be challenging. The most successful students are those who look for help:\n\nProfessor and preceptor office hours\nAcademic Success at Mac: Parts of this used to be called the Max Center, tutors are available for several disciplines, and professional help for building skills\nResearch assistance in the Library\n\n\n\nQuick overview of course and tools (15 minutes)\n\nCourse goals\n\nDevelop skill as Python programmer\nLearn to use tools for image processing and computer vision\nExplore ethics and how it applies to you and to technology (AI ethics)\nPractice and improve as college-level writers\n\nWhat will this course be like?\n\nMoodle is our hub for everything\nWe will use Slack for announcements, questions and answers, and responses to the readings/materials\nSyllabus, grades, gradebook\n\nWhat to do before our next class…\n\n\n\nActivity (15 minutes)\n\nForm into groups and work on activity (to be introduced later)\n\n\n\nGood advice:\n\nDo not fall behind in this class!\n\nEspecially the first few weeks: everything builds from day to day\n\nAsk lots of questions!\n\nAsk questions sooner rather than later\n\n1-2 minutes of stuck time in class\n15 minutes of stuck time on homework\n\n\nFile management is important! Do you understand how your file system is organized?\nComputer science is about Process, not Answers\nCheck out the Installing Software document and bring questions about installation after the activity today\n\n\n\nWhat to do before next class session\n\nRead Chapter 1, ThinkCS (online textbook, Runestone)\nTry Comprehension Quiz for September 3, Moodle\nRead instructions for Ethics and Sci-Fi 1, and get started! (Due before class Friday)\n\n\n\nAdvising\nWhat is a college education about? How can I get the most out of it?\n\nOnly connect…\nHow to get the most out of college\nClaiming an education\n\nThis is a bit old, maybe outdated, but has some good general advice for anyone, including this quote: “Responsibility to yourself means refusing to let others do your thinking, talking, and naming for you; it means learning to respect and use your own brains and instincts; hence, grappling with hard work.”\n\n\nWhat should I look for in my first semester schedule?\nThe big picture ones:\n\nExploring options: Take some interesting classes in fields you might want to major in, and take some interesting classes that aren’t in fields you want to major in\nBalance: Take courses from a variety of divisions and departments, no more than 1-2 from the same department\n\nThe raw practical ones:\n\nIf you are interested in Biology or Chemistry, take Chem 111 (or whatever you would place into)\nLanguage requirement: If you need multiple semester of second language study, you might want to start now\nDo you have a lunch break? Time between classes to get work done?\nAre you in the right level of course? Is a course something you have done before? Or is it a high level course that you might not be ready for?\nMusic ensembles, Dance/theater practicums, Phys ed courses, etc.\n\nIf you have questions, stick around and we’ll talk about them some more."
  },
  {
    "objectID": "Documents/ClassNotes1.html#wednesday-september-3",
    "href": "Documents/ClassNotes1.html#wednesday-september-3",
    "title": "Comp 194 Class Notes - Weeks 0-3",
    "section": "Wednesday, September 3",
    "text": "Wednesday, September 3\n\nAnnouncements:\n\nJoin MSCS-Community (if you are thinking of a major or minor in the MSCS department)\nPreceptors for this semester:\n\nSam Kenney, Jay Lebakken\nPreceptor office hours will posted to the Comp 194 Preceptor calendar\n\nBe sure to get ready for the activity for today by:\n\nInstalling Python\nInstalling PyCharm\nWe will help you with this in class if need be\n\nWeek 1 teams:\n\nSydney G., Wyatt, Farihatou\nPatrick, Sydney P.\nEthan, Elabe, Mohamud\nBowen, Lunga, Ryder\nSkye, Fiona, Sabrina\nWheaton, Lindsay, Tene\n\nUpcoming assignments\n\nDo readings before class, complete comprehension quiz (or do at the start of class with your team)\nEthics and Sci-Fi (start early in week, ready for class on Friday)\nHomework 1: don’t need to start yet\n\n\n\n\nBig Idea:\nComputer science is about process. It’s about how to clearly and unambiguously describe how to solve a problem, so that a computer (which is in no way intelligent) can perform our algorithm. It’s also about how to represent and store data in a computer, and how to manipulate it. There are other aspects to computer science as well: efficiency both for the programmer and for the speed of the program itself, human-computer interaction, how to design programs to be intuitive and helpful.\nDo not expect the programs you write to run correctly right away. Professional software developers spend about 25% of the time writing code, and 75% of the time debugging and testing it. Humans are not good at the level of precision and clarity programs require. So be forgiving and patient with yourself, and don’t seek perfection!\n\n\nToday’s plan:\n\nGroup discussion of first readings\n\nComplete the Comprehension Quiz as a group, discussing right/wrong answers and questions you have\nPost questions to the quiz or to Slack\n\nSetting up a project in PyCharm (the default settings are not right)\n\nIf you can, pull up PyCharm and work through this along with me!\nBe sure to select the “System Interpreter”, NOT “Virtual Environment”\n\nProgramming as learning a new language\n\nExpect tons of new vocabulary and terminology\nProgramming terms you have to get exactly right (computers are not smart)\nOther terms you shouldn’t try to memorize\n\nData: without data there is no program!\n\nWhat are some basic Python data types?\n\nGetting started with Python\n\n\n\nPython and PyCharm\n\nSee the Software Setup document for details on installing these: you can try this today but if it doesn’t work, move on by using a lab computer or a teammate’s computer\nI will go over a quick introduction to the parts of PyCharm in class\n\n\n\nAlgorithms\nWhat is an algorithm?\n\nA structured set of instructions that describe how to perform some task.\nDescribes a process\n\nExamples of algorithms\n\nRecipe in cooking\nAssembly instructions\nDirections for travel\nMathematical calculations (algorithms for adding two multi-digit numbers)\nPrograms\n\n\n\nPython as an interpreted language\n\nInterpreters versus compilers:\n\nInterpreters take in code and perform its actions\nCompilers take in code and translate it to lower-level code, sometimes executable\n\nPython has a shell or console where you can interact with the interpreter\nPython also has program mode where you give it a file and it runs all the steps\n\n\n\nKey parts of a programming language\nFrom your reading:\n\nInput – a way to get data into the program\nOutput – a way to display results to user\nMath and logic – a way to do computations\nConditionals – a way to make decisions, do different things under different conditions\nRepetition – a way to repeat some set of instructions\n\nI would add (elaborating on the 3rd point):\n\nData – a way to represent various kinds of data inside the program\nOperations on data – Tools for manipulating the data\nVariables and environment – A way to store data while running a program\n\n\n\nDebugging\n\nProgramming languages are not built for humans, they are a compromise between what humans would like and what computers can understand.\nPrograms have to be very precise, or the computer will do what we tell it, not what we want\n\nThus, we spend a lot of time debugging our programs to make them work correctly!\nTypes of errors:\n\nSyntax errors: Your code is improperly formed, the computer can’t make sense of it\n\nPyCharm will often pick up on these errors, and mark them with a red line on the right\nYour program can’t run at all if it has syntax errors in it\n\nRuntime errors: Errors that happen while the program is running\n\nYou passed the wrong kind of data to an operation\nYour code referred to a nonexistent variable name\nYour code divided by zero\n\nSemantic errors: Your algorithm is incorrect\n\nMaybe your ideas are wrong\nMaybe you didn’t express them correctly in Python\nMaybe it’s a typo\n\n\n\n\nValues and data types\nData inside the computer is all stored as sequences of 0s and 1s. In order for the computer to make sense of it, the computer needs to know what type of data the sequence is, then it can work with it.\nSimple Python data types:\n\nint: Integers, written with no decimal point and no comma: 3 -2 558382 -19293\nfloat: Floating-point numbers (real numbers), written with a decimal point or in a form of scientific notation: 3.5 -21.132 0.5 6.4e-5\nstr: A string, a sequence of text. Written with single or double quotes: \"hello\"  \"This is a string!\"  '8sdfh38s afdfhf92 39'   \"5.2\"\n\nWatch out! The “normal” quotation mark in word processors is different from the plain text quotation mark: ” versus “\nType conversion\nWe can tell Python to change data from one type to another. There are built-in conversion functions that also serve as the official type object\n\n1str(39.2)\n2int(44.1)\n3int(\"192\")\n4float(103)\n5float(\"39.2\")\n\n\n1\n\nConverts the float 39.2 into the string \"39.2\"\n\n2\n\nConverts the float 44.1 into the integer 44\n\n3\n\nConverts the string \"192\" into the integer 192\n\n4\n\nConverts the integer 103 into the float 103.0\n\n5\n\nConverts the string \"39.2\" into the float 39.2"
  },
  {
    "objectID": "Documents/ClassNotes1.html#friday-september-5",
    "href": "Documents/ClassNotes1.html#friday-september-5",
    "title": "Comp 194 Class Notes - Weeks 0-3",
    "section": "Friday, September 5",
    "text": "Friday, September 5\n\nAnnouncements:\n\nMSCS Coffee Breaks: Starting next week, Thursdays, 11:15am, near MSCS department office\nMSCS Block Party, September 24, 4:45 - 6:30\n\nFor declared or intended MSCS majors\nGames, food, etc.\n\nWe will start class with a discussion of the first Ethics and Science Fiction materials: come prepared!\nThis weekend: finish ICA 2, then start Homework\nSame teams as last class: sit together to start the day\n\n\n\nBig ideas\n\nWe organize information in the computer into different data types. Each data type has three components\n\nan internal representation for the computer\na visible or external representation (how we type/input the data), and\na set of operations that allow us to manipulate the data.\n\nOperations on data come in three types: built-in operators, functions, and methods. For now, we’ll focus on built-in data types (int, float, str) and the built-in operators and functions for them. We’ll learn more about the rest later.\nReading code is as important as writing code: We spend a lot of time in class writing code, because it is a great way to learn. You may not be as attuned to the time you spend reading code (reading assignments, activity code snippets, debugging problems). But spending time learning to understand code by reading it, rather than by running it, is time well spent! Your understanding is greater if you don’t depend on the computer to help you.\n\n\n\nToday’s plan:\n\nGroup discussion of Ethics and Sci-Fi 1\nGroup discussion of readings for today and today’s Comprehension Quiz\nStatements and Expressions\nVariables and variable assignment\nBuilt-in functions in Python\nOperations on numbers + strings\n\n\n\nWhat is a statement, what is an expression?\n\nA statement is a complete instruction that causes some change, such as:\n\nprinting something: print(\"ABC\")\nassigning a variable to a value: x = 2 * (253 - 176)\nasking the user for something: z = input(\"What is your name: \")\n\nAn expression is a chunk of code that evaluates to a value.\n\nWe often type expressions into the Python Console because it will print the value automatically\nExpressions are often part of a larger statement, like the code that creates the value that we print, or the value that we assign to a variable\nExamples:\n\n\"ABC\"\n3 * (2 + x) - (3 * z)\nmax(55, 124, 93, -402)\ninput(\"What is your name: \")\n\n\n\n\n\nVariables: what are they and how do we use them\nVariables in programming are related to variables in mathematics and other contexts, but there are important differences in how we think about variables in programming, so be open to the differences!\nA variable is a name attached to a memory location, a “bin” that is just a place to store data.\n\nA variable does not have a fixed value. We can always change the data stored there.\nThink of the computer memory as being like the images in Figure 1: a lot of numbered bins, where we can attach a variable name (possibly more than one).\nThe variable names are the keys that allow us to access the bin. At any time, we can look at what is stored in the bin, or we can remove what is inside it and replace it with a new value.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Bins or mailboxes are a useful metaphor for how computer memory and variables work\n\n\n\n\n\nFunctions in Python\nWe have seen functions already (print, int, float, str), but haven’t really looked at them as a category before.\nFunctions are a key and important tool in programming. The idea of a function stems from functions in mathematics, where a function is defined with a name or descriptor, it takes one or two inputs, and it produces a value through evaluating some formula. For example, here is a simple math function: \\[f(x, y) = 3x + 2y\\].\nWhat is a function?:\n\n\nA function is a named set of statements to perform some task\nFunctions take zero or more inputs, often a specific number, sometimes any number\nFunctions can cause side-effects such as printing or can return a value. Thus a function call can be an expression or a statement.\nA function call (we say we are “calling” a function or “invoking” a function) always looks the same: functionName(   input1, input2, …)\nInputs to a function are called arguments, or input parameters, and can be any Python expression\n\n\n\nOperations on numbers\nRemember that there are two separate number types we will use: int and float. All the operations below work on both kinds of numbers, but sometimes the results differ depending on the type, so be cautious.\nArithmetic operators:\n\naddition +\nsubtraction -\nmultiplication *\ndivision (3 operators) / // %\nexponentiation **\nparentheses for grouping, just like in math class ( )\n\nWatch out! The caret ^ is actually an obscure operator, but it is not exponentiation!\nBuilt-in functions:\n\nFind the maximum or minimum of the group: max(5, 7, 2), min(5, 7, 2)\nAbsolute value function: abs(3), abs(-10)\nRounding function: round(3.7), round(-1.2), round(3.92253, 3)\nConversion functions: int(3.2), float(5)\n\n\n\nOperations on strings:\nStrings are a sequence type in Python, meaning that they are a linear collection of data. In this case, the data is just characters, the keys you can type on the keyboard, the letters that make up text. Python encodes its characters as Unicode, so we can theoretically include other symbols than typical American English ones.\nConcatenation operators:\n\nstr1 + str2 combine str1 and str2 to make one new string\nstr * reps makes reps copies of str, all stuck together as one string\n\nMembership operator:\n\nvalue in string asks the question: does substring value occur anywhere in string\n\nAccess operator: pull single characters out of the string\n\nstring[index] accesses the character in string at position index\n\nNote: strings are indexed left to right starting from zero, and right-to-left with negatives starting with -1. (see Table 1 to see how to index the example string \"AB CD!\")\n\n\n\nTable 1: Indices to reference individual characters in the string \"AB CD!\"\n\n\n\n\n\n\nA\nB\n\nC\nD\n!\n\n\n\n\npositive indices:\n0\n1\n2\n3\n4\n5\n\n\nnegative indices:\n-6\n-5\n-4\n-3\n-2\n-1\n\n\n\n\n\n\nString slicing: extract a subset of characters from the string\n\nstring[start:end] extracts the substring starting at index start and going up to index end\nstring[:end] extracts the substring starting at 0 and going up to index end\nstring[start:] extracts the substring starting at index start and going to the end of string\nstring[start:end:skip] extracts a substring starting ad index start, going to index end, and skipping every skip characters\n\nFunctions on strings:\n\nlen(string) reports the number of characters in the string\nmax(string) returns the alphabetically last character (ASCII)\nmin(string) returns the alphabetically first character (ASCII)\n\n\n\nOperations on Lists\nA list is a sequence type in Python, which strings are also. Because both lists and strings are sequences, their operations can look very similar.\nLists are containers that hold other data, keeping the data in a linear sequence.\nThe data in a list can be any kind of Python data (we’ve seen integers, floats, strings, functions, and lists, and they all can go in a list). It doesn’t all have to be the same kind of data, either.\nWe create a list by putting square brackets around the data we want the list to contain, or by calling the list function.\n\n# Here are some examples of lists:\nnumList = [5, 23, 10, -8, 74, 2]\nnames = [\"Amy\", \"Rafael\", \"Alisha\", \"Wilbur\"]\ndataList = [45, \"piggie\", -102.4, [23, 29, 10]]\neList1 = []       # an empty list\neList2 = list()   # an empty list\n\nConcatenation operators:\n\nlist1 + list2 combines list1 and list2 to make one new list\nlist * reps makes reps copies of list, all stuck together as one list\n\nMembership operator:\n\nvalue in list asks the question: does the value occur as an item list\n\nAccess operator: pull single characters out of the list\n\nlist[index] accesses the data in list at position index\n\nNote: lists are indexed left to right starting from zero, and right-to-left with negatives starting with -1, just like strings\nList slicing: extract a subset of data from the list\n\nlist[start:end] returns the sequence starting at index start and going up to index end\nlist[:end] returns the sequence starting at 0 and going up to index end\nlist[start:] returns the sequence starting at index start and going to the end of string\nlist[start:end:skip] returns a sequence starting at start, going up to end, selecting every skip items\n\nFunctions on strings:\n\nlen(list) reports the number of pieces of data in the list\nmax(list) reports the largest number (or string) in the list\nmin(list) reports the smallest number (or string) in the list"
  },
  {
    "objectID": "Documents/ClassNotes1.html#monday-september-8",
    "href": "Documents/ClassNotes1.html#monday-september-8",
    "title": "Comp 194 Class Notes - Weeks 0-3",
    "section": "Monday, September 8",
    "text": "Monday, September 8\n\nAnnouncements:\n\nMSCS Coffee Breaks: Starting next week, Thursdays, 11:15am, near MSCS department office\nMSCS Block Party, September 24, 4:45 - 6:30\n\nFor declared or intended MSCS majors\nGames, food, etc.\n\nAdvising: Set up appointments this week\nCollege skills: go to every professor’s office hours and get their signature\nStart working on Homework 1 during this week\n\nJoin the Github assignment\nClone the repository\nRead the problems\nBring questions to me, Jay, and Sam!\n\nStart readings and videos for Ethics and Sci-Fi 2 today!\nNotes about grading:\n\nMake individual “teams” for ICAs for now\nICAs may be handed in late with no penalty\nIncomplete ICAs will receive full credit\nThe other side of those coins:\n\nWatch out for falling too far behind!\nICA tasks are intended to help you learn, so if you skip too many of them, you might be missing something\n\nMoodle gradebook is an estimate, individual assignment ratings will be correct\nSpreadsheet shared with you is keeping track of your progress toward a specific final grade (let me know if it seems wrong)\nAdjustment to grading\n\nHow to account for discussions in class?\nFour options, asking for your input here (in all cases you must complete about 2/3 of the days/activities/discussions to earn full credit)\nOption 1: Count disucssions as part of in-class work, contributing to Miro OR submitting ICA count, 20/30 for full credit\nOption 2: Count discussions as part of prep-for-class: doing comprehension quiz OR contributing to discussion in Miro fulfills that requirement; 20/30 for full credit\nOption 3: Add discussions as separate element of prep-for-class, and increase the number to do to 40/60 from 20/30\nOption 4: Add discussions as separate element of in-class work, and increase the number to do to 40/60 from 20/30\n\n\n\n\n\nBig idea\nA module is nothing more than a Python code file. Any Python code file can be considered a module, and imported into any other Python code file. When that happens, the code inside the imported file is run, except for certain code blocks that are carefully marked to be run only when the code is running on its own, and not when it is imported into another file.\nBy convention, modules are structured in certain ways, but there are no rules limiting the import of one code file into another! We will learn how to create Python code that can be easily imported into other code files, by avoiding script elements that would run when imported, except when we want them to.\n\n\nToday’s plan:\n\nNew teams for this week!\n\nPatrick, Sydney G, Wheaton\nTene, Ethan, Skye\nWyatt, Lindsay, Sabrina\nRyder, Fiona, Lunga\nBowen, Sydney P, Elabe\nMohamud, Farihatou\n\nDiscussion of readings for today and Comprehension Quiz with new group\nDebugging\nModules\nOpenCV!\nFinish up ICAs (in-class activities) 1 and 2\nStart work on ICA 3: math module, random module, OpenCV basics\n\n\n\nDebugging\n\nCode you write typically does not work the first time\nComputers are not smart, and rigid\nHumans like ambiguity, metaphor, and flexibility\nErrors in code are called bugs\nDebugging is the process of removing errors from your code\nDebugging can be intensely frustrating\nYou want to start building debugging skills, because you will spend more time debugging than you will writing the original code\n\nHow to minimize frustration:\n\nBe systematic\n\nWork out the rough steps on paper before starting to code\nKnow exactly which steps you will try to do first\nPrepare a set of examples to test your code on, where you know the right values for each step\nMake sure you know what every line of code is supposed to do, and be prepared to check what it is actually doing\n\nGet something working and then modify it (“incremental development”)\n\nWrite only a few lines at a time, then run them and test\nUse lots and lots of print statements to see all the intermediate values you create (once you are convinced those code lines work, you can comment out or delete the print statements!)\nSlowly work up to the whole program\n\nTest thoroughly\n\nCheck your code on multiple examples\nThink of “boundary conditions”: examples that push the limits of the program, or that are valid but slightly odd, and make sure to test them\n\n\nTips:\n\nDon’t blame Python! The chances of you finding a bug in Python itself are vanishingly small. If the code doesn’t do what you want it to, it’s because you haven’t communicated what you want to Python correctly\nRead error messages carefully!\n\nError types tell you useful information\nMessage itself will give more details\nTraceback will tell you exactly which line of code was running when the bug was discovered (the bug may have originated from earlier)\n\nAdd print statements\n\nPrint multiple values on one line to save output\nInclude a descriptive string with every print statement to ensure that you know what values you are seeing\n\nComment out problematic code to figure out the original source of a bug, and to determine what is currently working correctly\n\nCommon errors:\n\nParseError or SyntaxError:\n\nThe code it was trying to run isn’t properly formatted Python code\nThis error may often have a source earlier than where it is discovered\nCan be helpful to comment out the line it references, to see if the error is there or earlier\n\nTypeError:\n\nYou tried to apply an operation to a data type that it doesn’t work for\nOR (more often) you tried to combine two incompatible types\nRead the error message carefully: it tells you the line number, and the types of the things that caused a problem. It even tells you the operator that was involved!\n\nNameError:\n\nUsually means you have used a variable name prior to it being defined\nMost often, there is a typo in the name, either on the line with the error, or the line where the variable was initialized\n\nValueError:\n\nHappens when you pass a function a value it can’t work with, like asking the int function to convert the string “b”\nCheck the values being passed to the function, and their types\n\n\n\n\nModules\nPython has hundreds of modules provided with the language, thousands that you can install\nA module is just a code file, providing global variables, functions, maybe even data representations\nWe explicitly import a module when we need its tools:\n\nmath module\n\nConstants: pi, e\nFunctions for computing logs, exponents, trigonometry, square-root, etc.\n\nrandom module\n\nFunctions for generating pseudo-random numbers (integer, float)\nFunctions for choosing a random element from a list\nDifferent random distributions (uniform, gaussian, etc.)\n\nnumpy module\n\nNew array/matrix data type\nFunctions, operators, and methods for efficient calculations with arrays and matrices\n\ncv2 module\n\nOpenCV module\nRepresentation of an image as a Numpy array\nThousands of image processing and computer vision algorithms and tools\n\n\nImporting a module:\nThere are three main forms for import statements, shown below.\n\n1import math\n2import numpy as np\n3from math import pi, sqrt\n4from cv2 import *\n\n\n1\n\nImport the math module, creating a module object called math\n\n2\n\nImport the numpy module, but rename the module object np\n\n3\n\nImport just pi and sqrt from math, without a module object\n\n4\n\nImport all of cv2 without a module object (bad idea!)\n\n\n\n\nThe basic import statement creates a variable in Python with the name of the module, and assigns to it a module object, which contains all of the constants and functions defined in the module.\nWe can also rename the module when we import it, as shown in the second example above. For some modules, like numpy, it has become standard to use a shorter name: most code examples you see that use numpy will import it in this way.\nUsing the from operation, we can import part or all of a module, without creating a module object. The third example shows how we can use this to import just one or two items from a module, and the fourth example shows how to import the full contents of a module without creating a module object.\nWarning: Using the last import format is discouraged, as the functions, constants, and data types defined in the module will live in the same global namespace as your own code, and can conflict with your code, without you even realizing. It is dangerous!\nUsing module constants, functions, operators:\nWhen we import a module normally, we must refer to the tools in the module as a part of the module. We do this by attaching the module name to the front of the variable/function reference: `.*. Try the examples below on your own computer to see how this works.\n\nimport math\nimport random\n\narea = math.pi * (25.0 ** 2)\nprint(\"Area of circle with radius 25.0 is\", area)\nr1 = random.random()\nr2 = random.random()\nprint(r1, r2)\n\nArea of circle with radius 25.0 is 1963.4954084936207\n0.8685235116587483 0.13992265798759396\n\n\nThis computes the area of a circle with radius 25.0 by referencing the math module’s contant pi, and it computes two random floats between 0.0 and 1.0 using the random function in the random module.\n\n\nStarting with OpenCV\nThe OpenCV module for Python is called cv2.\nCheck that OpenCV is installed and configured properly by trying the following script. If it prints a number, you are ready to go. If it doesn’t work, then ask for help immediately.\n\nimport cv2\n\nprint(cv2.__version__)\n\nReading and displaying images\nThe script below, added to the previous script, uses three OpenCV functions to read in and display an image.\n\nThe script below includes a relative path string, passed to imread. This expects that this code file will be in the same folder as the SampleImages folder, and that the chicago.jpg image is directly inside SampleImages. Verify both of these things\nRemember that cv2.imread reads an image file and creates and returns a BGR image array. You must save the returned array to a variable, as shown here, to be able to use it\nRemember that cv2.imshow and cv2.waitKey work together to display an image, which should be either OpenCV’s grayscale or its BGR format\n\n\ncityImage = cv2.imread(\"SampleImages/chicago.jpg\")\ncv2.imshow(\"City\", cityImage)\ncv2.waitKey()\n\n\n\nDigital colors and images\nColor representations\n\nColors are light waves at varying wavelengths in the visible light spectrum\nThere are many different ways to represent colors inside the computer. We choose a representation based on what is best for our use\nRGB (red-green-blue) is the most common representation, because it is used by computer displays\nOpenCV uses BGR (RGB backwards)\nThree 8-bit integers make up a color for BGR: one for each color channel\nChannel values therefore range from 0 to 255\n\nExamples:\n\n(0, 0, 255) – red\n(0, 255, 255) – yellow\n(128, 0, 0) – dark blue\n(128, 0, 128) – dark magenta\n(250, 250, 250) – very light gray, almost white\n(75, 75, 75) – very dark gray\n\n\n\nOther color representations:\n\nHSV/HSL: Color, hue, is the first channel, Saturation and Value or Saturation and Lightness handle brightness and intensity of color (good for matching color hues when light level is variable)\nYUV: Brightness is the first channel, and color is represented by the second two (good for standardizing image brightness)\n\nImage representations\n\nA pixel is the smallest unit of an image: a single color\nAn image is a grid of pixels with width (x-dimension) and height (y-dimension)\nOpenCV images are 3-dimensional Numpy arrays: first two array dimensions correspond to height and width, and channel is the third dimensions\nGrayscale images have just one channel, thus have only two dimensions in the Numpy array\n\n\n\nDrawing on images with OpenCV\n\nOpenCV provides basic tools for drawing on images\nWe can read in an image and then draw shapes on it, OR we can create image arrays with Numpy\nSee readings for details about how to use each drawing function.\n\nCreating blank image arrays\nIf we create a 3-dimensional Numpy array, where the numbers are 8-bit unsigned integers, then OpenCV will interpret it as an image. The zeros and ones functions in Numpy allow us to create these images.\n\nBoth functions take the same inputs: a tuple giving the dimensions for the array, and a Numpy constant telling what type of data the array should hold.\n\nIn the script below, npImage1 will be 400 pixels by 400 pixels, with three channels, it will hold 8-bit unsigned integers, and the array is initialized to be all zeros. The npImage2 array will be 300 pixels tall by 600 pixels wide, also with three color channels. The array returned by ones is filled with ones, and we then multiply by 128 to get an array that is completely filled by 128’s: a middle gray background color.\n\nimport numpy as np\nnpImage1 = np.zeros((400, 400, 3), np.uint8)\nnpImage2 = 128 * np.ones((300, 600, 3), np.uint8)\n\nThe script below uses drawing functions to draw shapes on these two images.\n\nimport cv2\nimport numpy as np\n\nnpImage1 = np.zeros((400, 400, 3), np.uint8)\nnpImage2 = 128 * np.ones((300, 600, 3), np.uint8)\n\n1cv2.rectangle(npImage1, (100, 10), (300, 390), (0, 150, 255), -1)\n2cv2.circle(npImage1, (200, 75), 50, (0, 0, 255), -1)\ncv2.circle(npImage1, (200, 200), 50, (0, 255, 255), -1)\ncv2.circle(npImage1, (200, 325), 50, (0, 255, 0), -1)\n\n3cv2.line(npImage2, (50, 50), (550, 50), (180, 0, 0), 3)\ncv2.line(npImage2, (550, 50), (550, 250), (180, 0, 0), 3)\ncv2.line(npImage2, (550, 250), (50, 250), (180, 0, 0), 3)\ncv2.line(npImage2, (50, 250), (50, 50), (180, 0, 0), 3)\n4cv2.putText(npImage2, \"Happy Day!\", (75, 175), cv2.FONT_HERSHEY_SIMPLEX, 2.5, (255, 255, 0))\n\ncv2.imshow(\"First\", npImage1)\ncv2.imshow(\"Second\", npImage2)\n\ncv2.waitKey()\n\n\n1\n\nDraw an orange rectangle\n\n2\n\nDraw red, yellow, and green circles\n\n3\n\nDraw a blue border\n\n4\n\nAdd text to the center of the image\n\n\n\n\nNote: To get the text the right size, and centered on the screen, I started with my best guess, and then ran and re-ran the code, making small changes to either position or size, until I was satisfied."
  },
  {
    "objectID": "Documents/ClassNotes1.html#wednesday-september-10",
    "href": "Documents/ClassNotes1.html#wednesday-september-10",
    "title": "Comp 194 Class Notes - Weeks 0-3",
    "section": "Wednesday, September 10",
    "text": "Wednesday, September 10\n\nAnnouncements:\n\nMSCS Coffee Breaks: Starting next week, Thursdays, 11:15am, near MSCS department office\nMSCS Block Party, September 24, 4:45 - 6:30\n\nFor declared or intended MSCS majors\nGames, food, etc.\n\nAdvising: Set up appointments this week\nCollege skills: go to every professor’s office hours and get their signature\nKeep/start working on Homework 1 during this week\n\nJoin the Github assignment\nClone the repository\nRead the problems\nBring questions to me, Jay, and Sam!\n\nEthics and Sci-Fi 2 due Friday at the start of class\n\n\n\nToday’s topics:\n\nThe for loop\nThe range function\nDifferent looping patterns\nAccumulator variables\n\n\n\nThe for loop\nLoops allow our programs to repeat the same set of steps over and over, without writing them out repeatedly. Loops are one kind of control structure.\nThe for loop repeats for a set number of times, either once for each value in a list or string (or other data types we’ll learn about later), or once for each number in a specified range.\nfor loop forms\n\nfor &lt;var&gt; in &lt;sequence&gt;:\n    &lt;statement sequence&gt;\n\nMeaning: Set variable to each value in the sequence in turn, and then, for each value, perform the indented steps in the statement sequence\n\nVariable set to first value in sequence\nPerform statement sequence\nVariable set to second value in sequence\nPerform statement sequence again\n…\n\nLooping over the values in a list:\n\nfor color in ['red', 'blue', 'yellow', 'green']:\n    ...\n\nThis code example:\n\nrepeats 4 times, because there are 4 elements in the list\ncolor assigned to the value 'red' for the first pass, then to 'blue' for the second, etc.\nindented body of loop may refer to color, and the value will change each time\n\nLooping over a range of integers:\n\nfor i in range(20):\n    ...\n\nThis code example:\n\nrepeats 20 times\ni takes on the values from 0 to 19 each time through the loop\nrange produces an iterator, an object that produces the next number each time it is asked\n\nDifferent forms of range:\n\nrange(stop), starts counting at 0 and goes up to but not including stop\n\n`range(25)\nrange(3)\n\nrange(start, stop), starts counting at start and goes up to but not including stop\n\nrange(5, 25)\nrange(1, 3)\n\nrange(start, stop, step), starts counting at start and goes up to but not including stop, skipping step numbers each time\n\nrange(25, 50, 5)\nrange(10, 0, -1)\n\n\n\n\nThe accumulator pattern\nWhen programming, there are common patterns that re-occur across a wide range of problem types. We can take advantage of these by recognizing them and then following the pattern (reducing our cognitive load again!).\nWhen to apply the accumulator pattern\n\nWhen you are writing a loop\nWhen each pass through the loop contributes information to a final answer that is being constructed, or accumulated\nIn a script or a function, anywhere\n\nExamples:\n\nYou want to add up the numbers in a list\nYou want to build a list that holds the squares of the numbers from 0 to N\nYou want to build a string containing the data from a list, each separated by a * from the next\n\nWhat is the pattern\n\nAlways has two parts: initialization and update\nAccumulator variables: holds the partial answers as the loop runs\n\nStart out empty\nEnds with the whole answer in it\n\nInitialization: set up the accumulator variable\n\nAdd an assignment statement before the start of the loop\nIn that statement, create the accumulator variable and assign it an empty initial value\nBe sure that the type of the initial value matches what you want to build (is the final result a number, a list, a string?)\nChoose the simplest form of that data type (0 for numbers, the empty list [] for lists, the empty string “” for strings) unless you know of some different starting value\n\n\nUpdate: inside the loop, modify the accumulator variable\n\nUsually update at the end of the loop\nAdd an assignment statement that has the accumulator variable on both left and right sides\nAssignment should take the old value of the variable and update it with information from this pass of the loop\nThen the result is stored back into the same variable\n\n\nExamples (what does it look like?)\nExamples:\n\nYou want to add up the numbers in a list\n\n\nnumList = [3, 1, 20, 15, -4]\nsumNums = 0\nfor num in numList:\n    sumNums = sumNums + num\n\n\nYou want to build a list that holds the squares of the numbers from 0 to N\n\n\nN = 10\nsqList = []\nfor i in range(N+1):\n    sqList = sqList + [i ** 2]\n\n\nYou want to build a string containing the data from a list, each separated by a * from the next\n\n\ndata = [\"Henry\", 20, \"Maura\", 73]\nansStr = \"\"\nfor dataVal in data:\n    ansStr = ansStr + str(dataVal) + '*'"
  },
  {
    "objectID": "Documents/ClassNotes1.html#friday-september-12",
    "href": "Documents/ClassNotes1.html#friday-september-12",
    "title": "Comp 194 Class Notes - Weeks 0-3",
    "section": "Friday, September 12",
    "text": "Friday, September 12\n\nAnnouncements:\n\nMSCS Coffee Breaks: Starting next week, Thursdays, 11:15am, near MSCS department office\nResume Workshop, sponsored by MSCS SAB, Wednesday, Sept 17, 4:40-5:30pm, OLRI 254\nPre-health Student Orientation, Wednesday, Sept 24, 4:45-5:30pm, OLRI 250\nThursday, 12:00-1:00pm: MSCS seminar / Puzzle Palooza with Ben Orlin!\n\nPlease join us for some math puzzles with the author of “Math With Bad Drawings”.\n\nMSCS Block Party, September 24, 4:45 - 6:30\n\nFor declared or intended MSCS majors\nGames, food, etc.\n\n\nFor this class:\n\nTurn off Inline Completion\n\nOpen up Settings\nLook at the Editor settings\nClick on General, and then Inline Completion\nUncheck Enable full line completion suggestions\n\nAdvising: Set up appointments this week\nCollege skills: go to every professor’s office hours and get their signature\nEthics and Sci-Fi 2 due TODAY at the start of class\nHomework 1 due in one week: work hard on it this weekend!\n\n\n\nToday’s topics:\n\nGroup discussion of Ethics and Sci-Fi 2\nThe Boolean data type\nConditionals: the if statement\n\n\n\nBoolean data type\n\n\n\nGeorge Boole From Science Photo Gallery\n\n\nGeorge Boole was an English mathematician who was interested in connecting the kind of reasoning in mathematics to the kind of logical reasoning that philosophers use. He invented a whole algebra based on True/False as values. This was very important for Computer Science, because everything we do with digital computers is based in 1’s and 0’s, which can be thought of as Trues and Falses. Also, when we write programs, we need them to ask questions about the data they work on, and make different actions based on the answers. This also fits with the True/False model.\nSo we named the True/False data type “Boolean”\nPython bool data type\n\nConstants: True False\nExpressions (many many): x &lt; 25, str[0] &lt; 'm'\nComparing numbers, comparing strings (based on the ASCII table), comparing lists\nOperators (and, or, not): (x &lt; 25) and (str[0] == 'a')\nShort-circuiting operators\n\nHow can we use boolean expressions?\nIf statements: control structures that choose alternative code to perform\n\nif &lt;test expression 1&gt;:\n    &lt;statements to do if test expr 1 is true&gt;\nelif &lt;test expression 2&gt;):\n    &lt;statements to do if this test expr is true&gt;\n…\nelse:\n    &lt;statements to do if none of the exprs are true&gt;\n\nYou can have just the if part, with one boolean test expression. Then the body statements are only performed if the test expression evaluates to True.\nYou can have an if and an else, with one boolean test expression. The first indented body is performed if the expression evaluates to True, and the second indented body is performed if the expression evaluates to False.\nBetween the if part and the else part, you can have as many elif parts as you wish. These ask new questions. Only one section of statements is performed: the one following the first boolean expression that evaluates to True! After that, no other expressions or statements are evaluated.\nIf you have a second if, that signals the end of the previous if statement and the start of a brand-new conditional, not at all linked to the previous one!\nThings that are “true-ish” or “false-ish”\nPython lets you put any kind of data in the test part of an if statement, or as an argument to a boolean operator like and, or, or not. (try the examples below) * * Things that are considered “false”: False, 0, 0.0, “”, [], None * Everything else is true\nExamples:\n\nfor dat in [True, False, 0, 5, -2, 0.0, 12.586, -0.000001, \"\", \"a\", \"False\", [], [True], [False], ['a', 'b', 'c']]:\n    if dat:\n        print(dat, \"= TRUE\")\n    else:\n        print(dat, \"= FALSE\")\n\nprint()\nprint(\"'a' and 'b' and 'c' =\", 'a' and 'b' and 'c')\nprint(\"'a' or 'b' or 'c' =\", 'a' or 'b' or 'c')\nprint(not 3)\nprint(not [])\nprint(not None)\n\nTrue = TRUE\nFalse = FALSE\n0 = FALSE\n5 = TRUE\n-2 = TRUE\n0.0 = FALSE\n12.586 = TRUE\n-1e-06 = TRUE\n = FALSE\na = TRUE\nFalse = TRUE\n[] = FALSE\n[True] = TRUE\n[False] = TRUE\n['a', 'b', 'c'] = TRUE\n\n'a' and 'b' and 'c' = c\n'a' or 'b' or 'c' = a\nFalse\nTrue\nTrue"
  },
  {
    "objectID": "Documents/ClassNotes1.html#monday-september-15",
    "href": "Documents/ClassNotes1.html#monday-september-15",
    "title": "Comp 194 Class Notes - Weeks 0-3",
    "section": "Monday, September 15",
    "text": "Monday, September 15\n\nAnnouncements:\n\nResume Workshop, sponsored by MSCS SAB, Wednesday, Sept 17, 4:40-5:30pm, OLRI 254\nPre-health Student Orientation, Wednesday, Sept 24, 4:45-5:30pm, OLRI 250\nMSCS seminar / Puzzle Palooza with Ben Orlin!, Thursday, 12:00-1:00pm, OLRI 254\n\nPlease join us for some math puzzles with the author of “Math With Bad Drawings”.\n\nMSCS Block Party, September 24, 4:45 - 6:30\n\nFor declared or intended MSCS majors\nGames, food, etc.\n\n\nFor this class:\n\nHomework 1 due Friday this week\nStart readings and videos for Ethics and Sci-Fi 3 today!\nMonday, September 22 is our first Coding Quiz\n\nSee Study Guide (still in development)\n\n\n\n\nNew Teams for this week:\n\nSydneyP, Tene, Elabe, Wyatt\nBowen, Mohamud, Patrick, Skye\nEthan, Farihatou, Sabrina\nWheaton, Lunga, Fiona\nLindsay, SydneyG, Ryder\n\n\n\nTopics for today:\n\nFunction calls\nDefining functions\nGlobal and local environments\n\n\n\nVocabulary about functions\n\nalgorithm: a sequence of steps that describe how to solve some problem\nargument: the data passed into a function for it to operate on\ncontrol structure: a compound statement that alters the usual top-to-bottom, step-by-step ordering of steps in a Python program (examples: for loops,…)\nfunction: a named piece of code that performs certain steps, given some data as input, and that sometimes returns a value\n\ncall a function/invoke a function\n\nfunction call: an expression or statement that passes input arguments to a function, so that it actually runs\nfunction definition: a structure that defines a new function that your program may use. The first line specifies the functions names, and variable names for its input values, and the indented block of statements below that are the body of the function, the statements that are performed when the function is called\ninput parameter variable: A variable used in a function definition as a placeholder for an input that will be passed in when the function is called\nlocal: variables inside a function are local, only visible and existing temporarily only during calls to the function\nmethods: functions that belong to an object and must be called by referring to the object they belong to\nparameter: an input to a function\npseudocode: structured natural language description of an algorithm\nvariable: a name for a location where we can store data\n\nset/assign/instantiate a variable\n\n\nA function is a procedural abstraction, ie, a function is a name for a set of instructions. A function is more abstract than a script because a function takes a set of pre-specified inputs compared to a script that has all the data it works on defined before the program is run.\nFunctions we define, like the scripts we have been writing before this, are a way of describing an algorithm to the computer. A function has the benefit of doing all its work in its own “space,” which is separate from the main, global space. The technical name for these “spaces” is environment. An environment has a set of variables and functions defined in it, and environments can be nested inside each other. You can think of an environment as a table with variable and function names in the first column, and the data values in the second column.\nWhen a function is called, a new environment is created, where the function keeps its own variables.\nWhile it is possible to refer to global variables from inside a function, the function’s own variables exist only inside the function, and only have values for the duration of a call. The function’s environment goes away at the end of the function call.\n\n\nFunction Calls\nAll function calls look the same: first, the name of the function followed by an open parenthesis (, then any input arguments for the function, and then a close parenthesis ). The function performs its task and sometimes returns a value. Below are some calls to built-in functions we have tried already. The first function call does not return a result, but the rest do. The return value replaces the function call in the larger expression or statement: so we can take the value of max and use it directly in an arithmetic example, as line 5 below does.\n\nimport random\n\nprint('hi there')\nprint(random.random())\nsumOfMaxs = max(35, 102, 91, 16) + max(-2, -9, 20, 5)\nsiz = len([1, 5, 2, 6, 7, 2, 8])\nprint(\"Sum of maxs:\", sumOfMaxs)\nprint(\"list size:\", siz)\n\nhi there\n0.7376323480228166\nSum of maxs: 122\nlist size: 7\n\n\n\n\nFunction Definitions\nA function definition creates the function object and stores it in the global environment. It does not cause the steps inside the function to run; that only happens afterwards when the function is actually called. A function definition needs to specify (1) the name of the function, (2) the inputs to the function, and (3) what should happen when the function is called including what value should be returned, if any. Below is an outline of what a function definition looks like–it’s not a real function, though.\n\n1def &lt;functionName&gt;(&lt;var1&gt;, &lt;var2&gt;, …):\n2    &lt;function body&gt;,\n\n\n1\n\nThe function header or “def” line, includes the function name and the input parameter variables\n\n2\n\nThe function body, indented statements that say what to do when the function is called\n\n\n\n\n\n\nTracing Functions by Hand\nTo gain a better understanding of how functions work, we will trace by hand what happens when a call is made to a function we have defined. We will also try other tools within Python and PyCharm and elsewhere such as the Online Compiler, Visual Debugger, and AI Tutor to help us visualize what is happening.\nConsider the following function, which takes in three numbers and returns the smallest difference between the three numbers.\n\ndef smallestDiff(x, y, z):\n    diff1 = abs(x - y)\n    diff2 = abs(y - z)\n    diff3 = abs(x - z)\n    minDiff = min(diff1, diff2, diff3)\n    return minDiff\n\nFigure 2 labels the key elements of this function.\n\n\n\n\n\n\nFigure 2: Labeled function smallestDiff\n\n\n\n\nx, y, and z are the (formal) input parameters.\ndiff1, diff2, diff3, and minDiff are local variables, only existing within the function (as are x, y and z).\nThis function calls other functions, built-in Python functions abs and min, to help do its job.\nThe return values of abs and min are stored into variables to keep track of them.\nThe return value of smallestDiff is the value of minDiff.\n\nSuppose we make the following call to the function:\n\nsmallestDiff(3, 9, 5)\n\n2\n\n\nLet’s walk through the steps in making this call.\nStep one: Python matches the function name from the call to the function definition for that name, and then matches each input parameter to the corresponding argument, as shown in Figure 3.\n\n\n\n\n\n\nFigure 3: Labeled function smallestDiff with function call\n\n\n\nStep two: Python then builds a local environment for the call, as shown in Table 2:\n\n\n\nTable 2: Local environment for call smallestDiff(3, 9, 5)\n\n\n\n\n\nVariables\nValues\n\n\n\n\nx\n3\n\n\ny\n9\n\n\nz\n5\n\n\n\n\n\n\nStep three: Each indented line in the function is executed, in order. New variables are added to the local environment table, one after the other as illustrated below.\nTable 3, after line 2 of the function:\n\n\n\nTable 3: Local environment for after executing statement diff1 = abs(x - y)\n\n\n\n\n\nVariables\nValues\n\n\n\n\nx\n3\n\n\ny\n9\n\n\nz\n5\n\n\ndiff1\n6\n\n\n\n\n\n\nTable 4, after line 3 of the function:\n\n\n\nTable 4: Local environment for after executing statement diff2 = abs(y - z)\n\n\n\n\n\nVariables\nValues\n\n\n\n\nx\n3\n\n\ny\n9\n\n\nz\n5\n\n\ndiff1\n6\n\n\ndiff2\n4\n\n\n\n\n\n\nTable 5, after line 4 of the function:\n\n\n\nTable 5: Local environment for after executing statement diff3 = abs(x - z)\n\n\n\n\n\nVariables\nValues\n\n\n\n\nx\n3\n\n\ny\n9\n\n\nz\n5\n\n\ndiff1\n6\n\n\ndiff2\n4\n\n\ndiff3\n2\n\n\n\n\n\n\nTable 6, after line 5 of the function:\n\n\n\nTable 6: Local environment for after executing statement minDiff = min(diff1, diff2, diff3)\n\n\n\n\n\nVariables\nValues\n\n\n\n\nx\n3\n\n\ny\n9\n\n\nz\n5\n\n\ndiff1\n6\n\n\ndiff2\n4\n\n\ndiff3\n2\n\n\nminDiff\n2\n\n\n\n\n\n\nWhen it reaches the last line of the function body, the value of minDiff is returned, and the local environment is deleted. Figure 4 shows how the value of minDiff will be passed back and assigned to s.\n\n\n\n\n\n\nFigure 4: Returning a value from call to smallestDiff"
  },
  {
    "objectID": "Documents/ClassNotes1.html#wednesday-september-17",
    "href": "Documents/ClassNotes1.html#wednesday-september-17",
    "title": "Comp 194 Class Notes - Weeks 0-3",
    "section": "Wednesday, September 17",
    "text": "Wednesday, September 17\n\nAnnouncements:\n\nResume Workshop, sponsored by MSCS SAB, Wednesday, Sept 17, 4:40-5:30pm, OLRI 254\nPre-health Student Orientation, Wednesday, Sept 24, 4:45-5:30pm, OLRI 250\nMSCS seminar / Puzzle Palooza with Ben Orlin!, Thursday, 12:00-1:00pm, OLRI 254\n\nPlease join us for some math puzzles with the author of “Math With Bad Drawings”.\n\nMSCS Block Party, September 24, 4:45 - 6:30\n\nFor declared or intended MSCS majors\nGames, food, etc.\n\n\nFor this class:\n\nHomework 1 due Friday this week\nStart readings and videos for Ethics and Sci-Fi 3 today!\nMonday, September 22 is our first Coding Quiz\n\nSee Study Guide\n\n\n\n\nNew Teams for this week:\n\nSydneyP, Tene, Elabe, Wyatt\nBowen, Mohamud, Patrick, Skye\nEthan, Farihatou, Sabrina\nWheaton, Lunga, Fiona\nLindsay, SydneyG, Ryder\n\n\n\nTopics for today:\n\nThe accumulator pattern\nProgram style\nUsing a main function or script\nFlow of execution\nIncremental development\nContinue with Function Basics activity, and move on to Function Practice\n\n\n\nBig Ideas:\nCoding “style” is for humans! We follow certain conventions when we write programs that are not important for the computer’s understanding, but are designed to make programs easier for the writer and other human readers to understand. In some languages, indentation is one of the pieces of style, but Python forces you to use indentation “properly” as part of the meaning of the program. But other aspects of style to pay attention to:\n\nWell-written comments\nVariable naming conventions: meaningful, short, camelcase or C-style\nUse of whitespace and blank lines (like separating paragraphs of text in a paper)\nFile organization: placement of import statements, functions, and script elements\n\n\n\nThe Accumulator pattern\nWhen programming, there are common patterns that re-occur across a wide range of problem types. We can take advantage of these by recognizing them and then following the pattern (reducing our cognitive load again!).\nWhen to apply the accumulator pattern\n\nWhen you are writing a loop\nWhen each pass through the loop contributes information to a final answer that is being constructed, or accumulated\nIn a script or a function, anywhere\n\nWhat is the pattern\n\nAlways has two parts: initialization and update\nAccumulator variables: holds the partial answers as the loop runs\n\nStart out empty\nEnds with the whole answer in it\n\nInitialization: set up the accumulator variable\n\nAdd an assignment statement before the start of the loop\nIn that statement, create the accumulator variable and assign it an empty initial value\nBe sure that the type of the initial value matches what you want to build (is the final result a number, a list, a string?)\nChoose the simplest form of that data type (0 for numbers, the empty list [] for lists, the empty string \"\" for strings) unless you know of some different starting value\n\nUpdate: inside the loop, modify the accumulator variable\n\nUsually update at the end of the loop\nAdd an assignment statement that has the accumulator variable on both left and right sides\nAssignment should take the old value of the variable and update it with information from this pass of the loop\nThen the result is stored back into the same variable\n\n\nExamples:\nYou want to add up the numbers in a list:\n\nlst = [25, 102, 78, 60, 291]\ntot = 0    # Initialize accumulator to zero (since we are adding)\nfor val in lst:\n    tot = tot + val    # Update step, adds to old value of accumulator\nprint(\"Final value:\", tot)\n\nFinal value: 556\n\n\nYou want to build a list that holds the squares of the numbers from 0 to N:\n\nN = 10\nsqList = []   # Initialize accumulator to [] (since we are building a list)\nfor x in range(N+1):\n    sqList = sqList + [x ** 2]   # Update accumulator\nprint(sqList)\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\nYou want to build a string containing the data from a list, each separated by a * from the next\n\nlst = [25, \"hello\", 2, 9, \"friends\"]\ns = \"\"    #Initialize accumulator to the empty string\nfor datum in lst:\n    s = s + str(datum) + '*'\nprint(s)\n\n25*hello*2*9*friends*\n\n\n\n\nWriting with good Python style\nFile layout:\n\nFirst: import statements and any program-wide global variables (this is unusual)\nSecond: function definitions in some organized order, with comments and blank lines/demarcations\nLast: script elements that call functions\n\nUsing spaces for readability\n\nUse spaces to separate elements of a list, variables in a function call or declaration, parts of arithmetic expressions\nUse blank lines between elements in your file, even sections of a function or script\nUse comment lines with visual separators to separate sections\nVisual separate is a good thing\n\nPycharm can nag your about Python style\nIf it is enabled in the settings, Pycharm will alert you with light tan warning messages when you are violating a standard Python style. You may pay attention or not, we won’t require you to follow the rules (especially around variable-naming conventions) but it can help to suggest readable code.\nDocumenting your code, and the help function\nPython has standard ways of documenting our programs. These can be used to generate webpage documentation, and can also be helpful when running your code, because Python provides a function called help that will print documentation from code files. See examples in the video.\n\n\nThe main program:\n\nYou may define a function that runs your whole program\n\nIt doesn’t need to be called main\nIt usually goes either first or last in the function definitions\nYou often put a call to this main function as the only script element at the bottom\n\nYou may, instead, define a script that runs your whole program\n\nThe if __name__ == '__main__': form\n\nWhat: put all script statements inside this statement, and make sure something is not commented out\nWhy: makes it easier to treat your program like a module\n\n\n\n\n\nFlow of execution\nThe term, flow of execution, refers to the order that statements in a program are executed, taking into account all the control structures, like loops and conditionals, as well as function definitions and calls. It is important that you be able to trace through the flow of execution by hand and determine exactly what the program would do when. If you can’t do that, then you don’t really understand what the code is doing. Practice this!\nExamine the program below\n\ndef funcA(x):\n    print(\"A\", x + 2)\n    return x + 2\n    \ndef funcB(y):\n    y = funcA(y)\n    print(\"B\", y)\n    y = funcA(y + 10)\n    \nprint(\"Script 1\")\nfor i in range(3):\n    funcB(i)\nprint(\"Script 2\")\n\nScript 1\nA 2\nB 2\nA 14\nA 3\nB 3\nA 15\nA 4\nB 4\nA 16\nScript 2\n\n\nWhat is the output from this function? Walk through it by hand, and determine what messages will print when. There should be 11 lines of output. I will walk through this in my video, but you should try it yourself"
  },
  {
    "objectID": "Documents/ClassNotes1.html#friday-september-19",
    "href": "Documents/ClassNotes1.html#friday-september-19",
    "title": "Comp 194 Class Notes - Weeks 0-3",
    "section": "Friday, September 19",
    "text": "Friday, September 19\n\nAnnouncements\n\nPre-health Student Orientation, Wednesday, Sept 24, 4:45-5:30pm, OLRI 250\nMSCS Block Party, September 24, 4:45 - 6:30\n\nFor declared or intended MSCS majors\nGames, food, etc.\n\nHomework 1 is due today!\nCome prepared to discuss Ethics and Sci-Fi 3\nToken “assignment” in Moodle to claim tokens for extra time on HW\nChange to how Homework 1 is posted in Moodle, no change in grading…\n\n\n\nToday’s topics\n\nToday is a “Catch-up” day. No new material, but\nDiscussion of Ethics and Sci-Fi 3\nQuestions from study guide\nOpportunity to work on existing activities\nChance to work on homework with peers, preceptors, and instructor present"
  },
  {
    "objectID": "Documents/GithubAssignment.html",
    "href": "Documents/GithubAssignment.html",
    "title": "Github Assignment Basics",
    "section": "",
    "text": "Github provides cloud-based storage for code, including version control. It lets us remember multiple versions of our code, store code safely in the cloud, and share and collaborate on code across multiple computers. It is one of the most commonly used tools in the computer science today.\nGithub uses a set of commands called Git to control the files. We can run those commands from a terminal, like Terminal on the Mac or the Command Prompt on Windows, but more often we use an application like Github Desktop or our IDE to manage the Git commands for us. In this class, we will use PyCharm to manage Github for us.\nYou will need to complete each of the following steps to be ready to work on your first Github Assignment:\n\nSet up an account on Github, using your Macalester email account\nConfigure PyCharm to use Git and your Github account\n\n\n\n\nYou will need a free account on Github, linked to your Macalester email account.\n\nGo to https://github.com\nClick on the Sign up button\nFill in the required information\n\nUse your Macalester email address, and not any other email you may have\nPlease choose a username that includes your name, so your instructor and preceptors can identify you\n\nLook for a verification email from Github, and follow its instructions\n\nI strongly encourage you to set up two-factor authentication rather than using “tokens” for your Github account!"
  },
  {
    "objectID": "Documents/GithubAssignment.html#setting-up-an-account-on-github",
    "href": "Documents/GithubAssignment.html#setting-up-an-account-on-github",
    "title": "Github Assignment Basics",
    "section": "",
    "text": "You will need a free account on Github, linked to your Macalester email account.\n\nGo to https://github.com\nClick on the Sign up button\nFill in the required information\n\nUse your Macalester email address, and not any other email you may have\nPlease choose a username that includes your name, so your instructor and preceptors can identify you\n\nLook for a verification email from Github, and follow its instructions\n\nI strongly encourage you to set up two-factor authentication rather than using “tokens” for your Github account!"
  },
  {
    "objectID": "Readings/index.html",
    "href": "Readings/index.html",
    "title": "Comp 194 Readings – ToC",
    "section": "",
    "text": "This lists the chapters for the Vision readings for Comp 194.\n\n\nVision Chapters\n\nChapter 0, Things to Know Before You Start\nChapter 1, Getting Started with OpenCV\nChapter 2, Images as Matrices, and Numpy Arrays\nChapter 3, Webcams and Videos\nChapter 4, Masks and Thresholds\nChapter 5, Image Transformations"
  },
  {
    "objectID": "Readings/Chapter5.html",
    "href": "Readings/Chapter5.html",
    "title": "Chapter 5, Image Transformations",
    "section": "",
    "text": "In this chapter, we will continue our examination of image transformations, starting with geometric transformations and then exploring several different kinds of filters. Geometric transformations are used to resize images, but also to translate, rotate, or warp image contents within the frame of an image. Filters take in an image and produce a feature map that looks like an image of the same, or similar size. Each pixel in the feature map is determined by some mathematical calculations done on the neighborhood surrounding the corresponding pixel in the original image.\nFilter tasks include blurring, morphological filters, and edge detection. These filters allow us to simplify images, drawing out interesting features while reducing the complexity of the data. Some of these filters use convolution: convolutional filters are central to modern deep learning networks that work on image data."
  },
  {
    "objectID": "Readings/Chapter5.html#translation",
    "href": "Readings/Chapter5.html#translation",
    "title": "Chapter 5, Image Transformations",
    "section": "2.1 Translation",
    "text": "2.1 Translation\nTo translate an image, we want to move every pixel the same distance in the x direction, and the same distance in the y direction. In math terms, this looks like:\n\\[x_{new} = x_{old} + t_x\\] \\[y_{new} = y_{old} + t_y\\]\nCompare this formula to the affine warping formula above, and you can see how we can choose values for \\(a\\), \\(b\\), \\(c\\), and \\(d\\) to make these formulas out of the original (Let \\(a= 1\\), \\(b = 0\\), \\(c = 0\\), and \\(d = 1\\)). Because the matrix for translation will always have this simple form, when we program it, we will have to make the matrix ourselves. Look at the 3x3 matrix shown above; since the bottom row is always fixed in value, we only have to specify the top two rows when doing an affine warp in OpenCV.\nIn the code below, we use the warpAffine function to translate the contents of the image 100 pixels to the right, and 50 pixels down. This function takes in an image, and a 2x3 matrix of floating-point values that specify the six values from the affine warping formulas/matrix. We also tell the function how large to make the output image: it is common to keep it the same size, but we can choose any size we want.\n\nimport cv2\nimport numpy as np\n\nimg = cv2.imread(\"SampleImages/antiqueTractors.jpg\")\n1(hgt, wid, dep) = img.shape\n2tMatrix = np.matrix([[1, 0, 100], [0, 1, 50]], np.float32)\n3newIm = cv2.warpAffine(img, tMatrix, (wid, hgt))\n\n\n1\n\nGets the size of the original, so we can set the new image to that size\n\n2\n\nMakes a 32-bit floating-point matrix with the values for translating in both x and y directions\n\n3\n\nCreates a translated image the same size as the original\n\n\n\n\nFigure 2 shows the result of this transformation.\n\n\n\n\n\n\nFigure 2: Tractor image translated to the right by 100 pixels and down by 50 using affine warping"
  },
  {
    "objectID": "Readings/Chapter5.html#rotation",
    "href": "Readings/Chapter5.html#rotation",
    "title": "Chapter 5, Image Transformations",
    "section": "2.2 Rotation",
    "text": "2.2 Rotation\nRotating an image is closely related to the rotation of axes, a topic you may have studied in school earlier (in the US, it is often covered in precalculus classes). In linear algebra terms, there is a rotation matrix that can perform a rotation. With affine warping, we could build and use a version of this rotation matrix to perform rotations.\nHowever, OpenCV is going to do some of the hard work for us! Instead of us remember the formulas for the affine warping rotation matrix, OpenCV implements a function, getRotationMatrix2d that calculates the correct rotation matrix for us. This function has three inputs: the (x, y) coordinates of the pixel that should be the center of rotation, the angle to rotate by (positive values rotate counter-clockwise), and a scaling factor (in case we want to resize the rotated image at the same time). Figure 3 shows what these inputs mean. We can choose any pixel in the image as the center of rotation. Think of this as a putting a pin at a specific pixel, and then rotating the image around that point. The angle, given in degrees, tells how far to rotate in the counter-clockwise direction.\n\n\n\n\n\n\nFigure 3: Rotation using getRotationMatrix2d with center of rotation and angle of rotation specified\n\n\n\nThe code example below rotates the image three different amounts, and #fig-rotExamples shows the resulting images.\n\norigIm = cv2.imread(\"SampleImages/canyonlands.jpg\")\n(hgt, wid, dep) = origIm.shape\n\nrot1Mat = cv2.getRotationMatrix2D((wid//2, hgt//2), 45, 1)\nimRot1 = cv2.warpAffine(origIm, rot1Mat, (wid, hgt))\n\nrot2Mat = cv2.getRotationMatrix2D((100, 100), -70, 1)\nimRot2 = cv2.warpAffine(origIm, rot2Mat, (wid, hgt))\n\nrot3Mat = cv2.getRotationMatrix2D((wid//2, hgt//2), 160, 0.75)\nimRot3 = cv2.warpAffine(origIm, rot3Mat, (int(1.5*wid), int(1.5*hgt)))\n\n\n\n\n\n\n\n\n\nOriginal image\n\n\n\n\n\n\n\nRotated counter-clockwise around center by 45 degrees\n\n\n\n\n\n\n\n\n\nRotated clockwise around (100, 100) by 70 degrees\n\n\n\n\n\n\n\nRotated counter-clockwise around center by 160 degrees, scaled down to 3/4 size, viewed on larger image\n\n\n\n\n\n\nFigure 4: Three different rotations of an image, demonstrating variations of angle, center point, and scaling."
  },
  {
    "objectID": "Readings/Chapter0.html",
    "href": "Readings/Chapter0.html",
    "title": "Chapter 0, Things to Know Before You Start",
    "section": "",
    "text": "As you look at resources online for OpenCV, or even printed textbooks, they often begin with detailed and complicated instructions for installing OpenCV. Beware of blindly following these instructions! Installation of OpenCV has changed dramatically in just a few years, and often instructions online are out of date. Instead, look for the resources and instructions provided by your instructor, as they will be more suitable.\nThe key things you will need are:\n\nA current installation of Python\nA Python programming environment (PyCharm is recommended)\nThe FFMPEG utility installed\nNumpy and OpenCV modules installed\n\nGet help from the instructor or preceptor on the best way to install each of these, or for help if you run into any difficulties.\n\n\n\nOpenCV is one of the most widely-used computer vision libraries. It was originally created by Intel as a project to show off the abilities of their processor chips, and was released in 1999 (see OpenCV, on Wikipedia for more details). OpenCV has always been an open-source project, which means that its source code is available to read, download, and modify, and it is updated and maintained by a community of ordinary people. Currently, OpenCV has both C++ and Python versions: we will use the Python one as it is much easier to learn.\nOpenCV implements hundreds of computer vision and image processing tools. We will explore a small percentage of what it offers. It integrates well with other libraries, including machine learning libraries.\nOpenCV has thorough documentation for all of its tools (outstanding quality compared to some other open-source projects). The documentation is not easy to read, but it is worth working at it, because you can learn how the tools work, how to use additional options, and even learning new tools that we won’t cover in class. I recommend that you use the following approach to the documentation:\n\nGo to the main documentation page\nUse the search tool and type the name of the function you want, or a description of it\nClick on the suggested options until you find the one you want\nRead through the description of how the function works: Be sure to look for the description of how it is called in Python (different from C++)\n\n\n\nFigure 1 shows the entry for the imshow function (we went to the main page, typed imshow into the search box, and chose the first option).\n\n\n\n\n\n\nFigure 1: OpenCV documentation for imshow function, with 3 key elements highlighted.\n\n\n\nThree parts of a typical documentation entry are marked:\n\nThis number marks the location of the python call interface. This describes the inputs to a call to imshow, and what values it returns. Here, we see that imshow takes in two inputs, called winname and mat, and it returns nothing. Both are required inputs: you have to pass two values of the right type to this function every time you call it!\nThis number marks the description of what this function does. It probably has more details than you need (including what happens if you don’t pass it a typical image array), but the start of the description usually summarizes the main purpose, only read further if you need/want to\nThis number explains what each input parameter means. Here, it tells us that winname is the name of the window (we might guess that this should be a string), and that mat is the image to be shown. The variable name mat here is short for “matrix” and typically is used to indicate an image array or matrix of some kind.\n\nThis function also includes a note that is important for using it correctly. While it has more technical detail than you might want, the key point is important: you must follow a call to imshow with a call to the waitKey function, because waitKey actually causes the window to be displayed.\n\n\n\nFigure 2 shows the start of the entry for the imread function. Examine the call interfaces shown for this function. We usually use the first form, so let us look more closely at it. Inside the parentheses, you see two variables, filename and flags, and you can see that there is a return value, called retval. The first variable, filename, is just inside the call parentheses: this indicates that filename is a required input. This is a string which contains the path and filename needed to find the file on the computer (see the next section for more details).\n\n\n\n\n\n\nFigure 2: OpenCV documentation for imread function, showing how optional inputs to functions are denoted\n\n\n\nThe second variable is inside square brackets. In the documentation, this indicates an optional input. Here, we can use the flags to read the data from the image file in different formats (BGR is the default, but we can also read in grayscale, or a format that preserves any alpha channel if the file has one).\nThe return value is named vaguely: retval is just short for return value. This is because the return value can be two different things. If you read through the description carefully, it tells you that retval is either the “matrix” (Numpy array) containing the image data, if the read was successful, and if the read failed, retval will be the special Python value, None.\n\n\n\n\nOn modern computers and other devices like phones and tables, a casual user may not know where files are stored, or how the computer knows the type of each file. The computer’s operating system hides those details from us, and we can use search functions to find and access our files for us.\nWhen we want to program our computers, however, we need to dig deeper and really understand how files are organized and labeled inside the computer. In this section, we will look at the hierarchical organization of files into folders, more formally called directories, and the use of filename extensions to indicate the type of the file.\n\n\nBoth Mac OS and Windows default to hiding certain very helpful information from us. To make your life easier, follow the steps below to make filename extensions on, and to make sure that important folders, like your home folder, are immediately visible when you use the Finder or File Explorer.\n\n\n\nOpen a Finder window by clicking on the Finder icon. If a window doesn’t automatically appear, command-N or New Finder Window under the File menu should work.\nSelect Settings from the Finder menu, and click on Sidebar, and make sure that the following items are checked: Desktop, Documents, Downloads, and your home folder (whose icon is a house, and it is labeled with your username)\nSelect the Advanced section from Settings, and check the option that says something like Show all filename extensions\nSelect the View menu from the menu bar (at the top of the window), and look for the Show Path Bar/Hide Path Bar option. Make sure it is set to show the path bar. This adds a bar at the bottom of the finder window that shows the whole path to the folder or file you have currently selected.\n\n\n\n\n\nOpen the File Explorer (from taskbar, the Start menu, or the Windows logo key)\nUnder the View menu, select Show/Hide and check the File name extensions option\nJust above the list of files in the current folder, the File Explorer has a “breadcrumb bar”. This bar shows the path to the current folder or file. You can right-click on this bar to copy the path.\nThe Windows “Home” folder is not a real folder, but rather a collection of recent folders/files you have visited. Your actual home directory can be reached by going to This PC and then looking in the Users folder (or there may be a shortcut on your Desktop)\n\n\n\n\n\nMost files on a computer have a filename that includes an extension at the end that defines the type of data in the file. The extension is usually 3-5 characters long, always at the end of the name, and is preceded by a period. For example, Microsoft Word documents use the extension .docx, and HTML documents use .html. Plain text files use .txt, and Python programs use .py. The computer uses the extension to figure out how to work with the file. When you double-click on a file that ends in .docx, the computer knows to open the file with Word. Both Windows and Mac OS will label files with a thumbnail icon that represents the type of data, so in our day-to-day use we don’t need to read the actual extension. However, when we work with files in programming, we have to remember that the extension is an actual part of the name of the file.\nImage files can be stored in many different formats, with PNG and JPEG the most common. Each format has its own way to store the data about the image, and uses its own method to compress the image data to make the file smaller. Thus, the computer has to know which format is used in order to read the data correctly.\nWhen we write a program that reads in data from a file, whether that data is text, a spreadsheet, images, or sounds, we have to use the full filename, including the extension, so that the computer knows how to read and interpret the file’s data.\nNote: You can’t change the formatting of the data in a file just by changing the extension on the file! You must use an appropriate tool to convert one type of file into another.\n\n\n\nComputers organize the files on them in a hierarchical way: with files in folders, and folders in folders. Folders are more correctly called directories in computer science. The term folder came about as a user-friendly metaphor, and can be used interchangeably with directory. The form of the hierarchy is called a tree, the directory tree, because it has a similar shape to a family tree. Figure 3 shows a partial directory tree on a Mac (including just a few file/folders)\n\n\n\n\n\n\nFigure 3: Mac user directory tree (partial) showing user folders & files in context\n\n\n\nThe top level of a computer is typically a directory containing a set of directories, one for each drive attached to the computer. Inside each of these folders is a hierarchy of folders and files organizing all the files stored on that device.\nYour own user space on the computer is its own folder. On both current Macs and current Windows machines, this folder is (usually) located inside the Users folder, which is at the top level of your main drive.\nBefore continuing, take a few minutes to experiment with the file system hierarchy on your computer.\n\n\n\nOpen a Finder window\nLook at the sidebar on the left, and find a section called Locations (if this is not visible, go into Settings and in the Sidebar section check all the options under *Locations)\nClick on the option that shows the name of your computer, with an icon that looks like your computer\nThis should show you a directory containing your hard drive, and any other drives connected to your computer (including Network drives, external drives, flash drives, etc.)\nClick on the hard drive option; you should see folders for Applications, Library, System, and Users\nFind your home folder from here, and explore other folders as well\nNotice the path bar at the bottom of the Finder window shows the sequence of enclosing directories (the folders from the top level down to the file or folder you’ve selected)\n\n\n\n\n\nOpen a File Explorer window\nSelect This PC; this should show you a directory containing the drives currently connected to your computer\nClick on the main C drive, and you should see the top-level folders, including Users among others\nFind your home folder from here, and explore other folders as well\nNotice the path bar at the bottom of the Finder window shows the sequence of enclosing directories (the folders from the top level down to the file or folder you’ve selected)\n\nWhen we write programs that read from files, we need to tell the computer how to find the files we want to read. We do this by listing the path of the file: a condensed representation of the sequence of directories that contain the file. This serves as directions for the computer: the path tells the computer how to go about finding the file.\nIn Python, as in many programming languages, paths are written as strings. Each string has a sequence of folder names, separated by a symbol. Mac OS and Windows use different symbols as dividers (of course they do!), but Python can make sense of the path even if you use the wrong symbols. On a Mac, we use the divide sign slash (/) to separate one folder from the folder it encloses, and we put a slash at the front of the string when we are giving the path from the top level (an absolute path, we will talk more about those a little bit later). On Windows, an absolute path starts with the identifier for the drive (for example, C:\\) and then gives the sequence of folders, separated by the backslash symbol (\\).\n\n\n\n\nSuppose that I have all my Pycharm projects in a folder called PycharmProjects that is stored in my home directory. I have a project for this class called Comp194 inside the PycharmProjects folder, and it contains a Python code file, hello.py. Figure 4 shows the Finder, as if I have found this file starting at the top level of the computer’s hard drive. Note that this example and the one after use the directory tree structure from Figure 3 earlier.\n\n\n\n\n\n\nFigure 4: Finder window showing the path to example file hello.py.\n\n\n\nNotice the path bar at the bottom shows the absolute path, starting with the Users folder.\nIf we write this absolute path in Python, it would look like this:\n\"/Users/susan/PycharmProjects/Comp194/hello.py\"\nOn a Mac, you can copy the path in this format, minus the quotation marks, by right-clicking (or holding control and clicking) on the name of the file in the path bar, and selecting Copy hello.py as pathname. On Windows, you can copy the path similarly by right-clicking on the breadcrumbs bar at the top of the window, or by typing shift-ctrl-c.\nTry this for yourself: copy the path for a file on your computer, and paste it into a document where you can read it.\n\n\n\nAn absolute path always starts at the top level of the drive where the data is stored. It completely specifies the location of a file or folder on the computer. It will always work, but it can get long and unwieldy to use. The example above was an absolute path.\nWhen we are programming or working with a shell tool on the computer (Terminal on the Mac, Command Prompt or PowerShell on Windows), the program always considers itself to be in or focused on, a particular folder (the current working directory). For example, when we program in Python, the program is by default *in** the folder where the .py file is stored. Using the example from the previous section, if we run the hello.py program, the running program would be in the Comp194 folder.\nBecause of the current working directory context, we can sometimes use a relative path instead of an absolute one. Instead of specifying the full path from the toop level folder on the computer, we may describe the location of a file or folder as relative to the current working directory: the path starts at the folder we are currently in. To indicate that something is a relative path, we leave off the leading slash (on Mac) or drive identifier (on Windows).\n\n\n\nExample 1: if the hello.py program wanted to read from the test.qmd file that is stored in the same folder, the relative path would just be \"test.qmd\", because the files are in the same folder: there is no need to travel through other folders to find test.qmd.\nExample 2: suppose the program wanted to read in an image, mushrooms.jpg, from the SampleImages folder that is inside the Comp194 folder. The absolute path to this file would be \"/Users/susan/PycharmProjects/Comp194/SampleImages/mushrooms.jpg\", whereas the relative path from the code file would be \"SampleImages/hello.py\".\nExample 3: Suppose the hello.py program wanted to open an image file, CampingUpNorth2017.jpg that is in the Desktop folder (see the directory tree in Figure 3). The Desktop folder sits inside the home folder, susan. Neither of these are inside the current folder Comp194, of course, so we somehow need to indicate in the path to go up the directory tree to a higher level.\nPaths use the special marker .. to mean “go up one level in the directory tree.” In this example, we could either give an absolute path (\"/Users/susan/Desktop/CampingUpNorth2017.jpg\") or a relative one (\"../../Desktop/CampingUpNorth2017.jpg\"). There are two copies of the .. marker because of the way folders are nested: The first .. tells the program to go up one level, from Comp194 to PycharmProjects. The second .. tells the program to go up one more level, from PycharmProjects to susan. From there we can continue the path downwards as normal.\nRemember: you can always use an absolute path safely, but relative paths can be shorter and easier to remember.\nYou will get lots of practice specifying paths and using filename extensions as we work with images."
  },
  {
    "objectID": "Readings/Chapter0.html#getting-ready-to-use-opencv",
    "href": "Readings/Chapter0.html#getting-ready-to-use-opencv",
    "title": "Chapter 0, Things to Know Before You Start",
    "section": "",
    "text": "As you look at resources online for OpenCV, or even printed textbooks, they often begin with detailed and complicated instructions for installing OpenCV. Beware of blindly following these instructions! Installation of OpenCV has changed dramatically in just a few years, and often instructions online are out of date. Instead, look for the resources and instructions provided by your instructor, as they will be more suitable.\nThe key things you will need are:\n\nA current installation of Python\nA Python programming environment (PyCharm is recommended)\nThe FFMPEG utility installed\nNumpy and OpenCV modules installed\n\nGet help from the instructor or preceptor on the best way to install each of these, or for help if you run into any difficulties."
  },
  {
    "objectID": "Readings/Chapter0.html#background-on-opencv",
    "href": "Readings/Chapter0.html#background-on-opencv",
    "title": "Chapter 0, Things to Know Before You Start",
    "section": "",
    "text": "OpenCV is one of the most widely-used computer vision libraries. It was originally created by Intel as a project to show off the abilities of their processor chips, and was released in 1999 (see OpenCV, on Wikipedia for more details). OpenCV has always been an open-source project, which means that its source code is available to read, download, and modify, and it is updated and maintained by a community of ordinary people. Currently, OpenCV has both C++ and Python versions: we will use the Python one as it is much easier to learn.\nOpenCV implements hundreds of computer vision and image processing tools. We will explore a small percentage of what it offers. It integrates well with other libraries, including machine learning libraries.\nOpenCV has thorough documentation for all of its tools (outstanding quality compared to some other open-source projects). The documentation is not easy to read, but it is worth working at it, because you can learn how the tools work, how to use additional options, and even learning new tools that we won’t cover in class. I recommend that you use the following approach to the documentation:\n\nGo to the main documentation page\nUse the search tool and type the name of the function you want, or a description of it\nClick on the suggested options until you find the one you want\nRead through the description of how the function works: Be sure to look for the description of how it is called in Python (different from C++)\n\n\n\nFigure 1 shows the entry for the imshow function (we went to the main page, typed imshow into the search box, and chose the first option).\n\n\n\n\n\n\nFigure 1: OpenCV documentation for imshow function, with 3 key elements highlighted.\n\n\n\nThree parts of a typical documentation entry are marked:\n\nThis number marks the location of the python call interface. This describes the inputs to a call to imshow, and what values it returns. Here, we see that imshow takes in two inputs, called winname and mat, and it returns nothing. Both are required inputs: you have to pass two values of the right type to this function every time you call it!\nThis number marks the description of what this function does. It probably has more details than you need (including what happens if you don’t pass it a typical image array), but the start of the description usually summarizes the main purpose, only read further if you need/want to\nThis number explains what each input parameter means. Here, it tells us that winname is the name of the window (we might guess that this should be a string), and that mat is the image to be shown. The variable name mat here is short for “matrix” and typically is used to indicate an image array or matrix of some kind.\n\nThis function also includes a note that is important for using it correctly. While it has more technical detail than you might want, the key point is important: you must follow a call to imshow with a call to the waitKey function, because waitKey actually causes the window to be displayed.\n\n\n\nFigure 2 shows the start of the entry for the imread function. Examine the call interfaces shown for this function. We usually use the first form, so let us look more closely at it. Inside the parentheses, you see two variables, filename and flags, and you can see that there is a return value, called retval. The first variable, filename, is just inside the call parentheses: this indicates that filename is a required input. This is a string which contains the path and filename needed to find the file on the computer (see the next section for more details).\n\n\n\n\n\n\nFigure 2: OpenCV documentation for imread function, showing how optional inputs to functions are denoted\n\n\n\nThe second variable is inside square brackets. In the documentation, this indicates an optional input. Here, we can use the flags to read the data from the image file in different formats (BGR is the default, but we can also read in grayscale, or a format that preserves any alpha channel if the file has one).\nThe return value is named vaguely: retval is just short for return value. This is because the return value can be two different things. If you read through the description carefully, it tells you that retval is either the “matrix” (Numpy array) containing the image data, if the read was successful, and if the read failed, retval will be the special Python value, None."
  },
  {
    "objectID": "Readings/Chapter0.html#image-files-and-paths",
    "href": "Readings/Chapter0.html#image-files-and-paths",
    "title": "Chapter 0, Things to Know Before You Start",
    "section": "",
    "text": "On modern computers and other devices like phones and tables, a casual user may not know where files are stored, or how the computer knows the type of each file. The computer’s operating system hides those details from us, and we can use search functions to find and access our files for us.\nWhen we want to program our computers, however, we need to dig deeper and really understand how files are organized and labeled inside the computer. In this section, we will look at the hierarchical organization of files into folders, more formally called directories, and the use of filename extensions to indicate the type of the file.\n\n\nBoth Mac OS and Windows default to hiding certain very helpful information from us. To make your life easier, follow the steps below to make filename extensions on, and to make sure that important folders, like your home folder, are immediately visible when you use the Finder or File Explorer.\n\n\n\nOpen a Finder window by clicking on the Finder icon. If a window doesn’t automatically appear, command-N or New Finder Window under the File menu should work.\nSelect Settings from the Finder menu, and click on Sidebar, and make sure that the following items are checked: Desktop, Documents, Downloads, and your home folder (whose icon is a house, and it is labeled with your username)\nSelect the Advanced section from Settings, and check the option that says something like Show all filename extensions\nSelect the View menu from the menu bar (at the top of the window), and look for the Show Path Bar/Hide Path Bar option. Make sure it is set to show the path bar. This adds a bar at the bottom of the finder window that shows the whole path to the folder or file you have currently selected.\n\n\n\n\n\nOpen the File Explorer (from taskbar, the Start menu, or the Windows logo key)\nUnder the View menu, select Show/Hide and check the File name extensions option\nJust above the list of files in the current folder, the File Explorer has a “breadcrumb bar”. This bar shows the path to the current folder or file. You can right-click on this bar to copy the path.\nThe Windows “Home” folder is not a real folder, but rather a collection of recent folders/files you have visited. Your actual home directory can be reached by going to This PC and then looking in the Users folder (or there may be a shortcut on your Desktop)\n\n\n\n\n\nMost files on a computer have a filename that includes an extension at the end that defines the type of data in the file. The extension is usually 3-5 characters long, always at the end of the name, and is preceded by a period. For example, Microsoft Word documents use the extension .docx, and HTML documents use .html. Plain text files use .txt, and Python programs use .py. The computer uses the extension to figure out how to work with the file. When you double-click on a file that ends in .docx, the computer knows to open the file with Word. Both Windows and Mac OS will label files with a thumbnail icon that represents the type of data, so in our day-to-day use we don’t need to read the actual extension. However, when we work with files in programming, we have to remember that the extension is an actual part of the name of the file.\nImage files can be stored in many different formats, with PNG and JPEG the most common. Each format has its own way to store the data about the image, and uses its own method to compress the image data to make the file smaller. Thus, the computer has to know which format is used in order to read the data correctly.\nWhen we write a program that reads in data from a file, whether that data is text, a spreadsheet, images, or sounds, we have to use the full filename, including the extension, so that the computer knows how to read and interpret the file’s data.\nNote: You can’t change the formatting of the data in a file just by changing the extension on the file! You must use an appropriate tool to convert one type of file into another.\n\n\n\nComputers organize the files on them in a hierarchical way: with files in folders, and folders in folders. Folders are more correctly called directories in computer science. The term folder came about as a user-friendly metaphor, and can be used interchangeably with directory. The form of the hierarchy is called a tree, the directory tree, because it has a similar shape to a family tree. Figure 3 shows a partial directory tree on a Mac (including just a few file/folders)\n\n\n\n\n\n\nFigure 3: Mac user directory tree (partial) showing user folders & files in context\n\n\n\nThe top level of a computer is typically a directory containing a set of directories, one for each drive attached to the computer. Inside each of these folders is a hierarchy of folders and files organizing all the files stored on that device.\nYour own user space on the computer is its own folder. On both current Macs and current Windows machines, this folder is (usually) located inside the Users folder, which is at the top level of your main drive.\nBefore continuing, take a few minutes to experiment with the file system hierarchy on your computer.\n\n\n\nOpen a Finder window\nLook at the sidebar on the left, and find a section called Locations (if this is not visible, go into Settings and in the Sidebar section check all the options under *Locations)\nClick on the option that shows the name of your computer, with an icon that looks like your computer\nThis should show you a directory containing your hard drive, and any other drives connected to your computer (including Network drives, external drives, flash drives, etc.)\nClick on the hard drive option; you should see folders for Applications, Library, System, and Users\nFind your home folder from here, and explore other folders as well\nNotice the path bar at the bottom of the Finder window shows the sequence of enclosing directories (the folders from the top level down to the file or folder you’ve selected)\n\n\n\n\n\nOpen a File Explorer window\nSelect This PC; this should show you a directory containing the drives currently connected to your computer\nClick on the main C drive, and you should see the top-level folders, including Users among others\nFind your home folder from here, and explore other folders as well\nNotice the path bar at the bottom of the Finder window shows the sequence of enclosing directories (the folders from the top level down to the file or folder you’ve selected)\n\nWhen we write programs that read from files, we need to tell the computer how to find the files we want to read. We do this by listing the path of the file: a condensed representation of the sequence of directories that contain the file. This serves as directions for the computer: the path tells the computer how to go about finding the file.\nIn Python, as in many programming languages, paths are written as strings. Each string has a sequence of folder names, separated by a symbol. Mac OS and Windows use different symbols as dividers (of course they do!), but Python can make sense of the path even if you use the wrong symbols. On a Mac, we use the divide sign slash (/) to separate one folder from the folder it encloses, and we put a slash at the front of the string when we are giving the path from the top level (an absolute path, we will talk more about those a little bit later). On Windows, an absolute path starts with the identifier for the drive (for example, C:\\) and then gives the sequence of folders, separated by the backslash symbol (\\).\n\n\n\n\nSuppose that I have all my Pycharm projects in a folder called PycharmProjects that is stored in my home directory. I have a project for this class called Comp194 inside the PycharmProjects folder, and it contains a Python code file, hello.py. Figure 4 shows the Finder, as if I have found this file starting at the top level of the computer’s hard drive. Note that this example and the one after use the directory tree structure from Figure 3 earlier.\n\n\n\n\n\n\nFigure 4: Finder window showing the path to example file hello.py.\n\n\n\nNotice the path bar at the bottom shows the absolute path, starting with the Users folder.\nIf we write this absolute path in Python, it would look like this:\n\"/Users/susan/PycharmProjects/Comp194/hello.py\"\nOn a Mac, you can copy the path in this format, minus the quotation marks, by right-clicking (or holding control and clicking) on the name of the file in the path bar, and selecting Copy hello.py as pathname. On Windows, you can copy the path similarly by right-clicking on the breadcrumbs bar at the top of the window, or by typing shift-ctrl-c.\nTry this for yourself: copy the path for a file on your computer, and paste it into a document where you can read it.\n\n\n\nAn absolute path always starts at the top level of the drive where the data is stored. It completely specifies the location of a file or folder on the computer. It will always work, but it can get long and unwieldy to use. The example above was an absolute path.\nWhen we are programming or working with a shell tool on the computer (Terminal on the Mac, Command Prompt or PowerShell on Windows), the program always considers itself to be in or focused on, a particular folder (the current working directory). For example, when we program in Python, the program is by default *in** the folder where the .py file is stored. Using the example from the previous section, if we run the hello.py program, the running program would be in the Comp194 folder.\nBecause of the current working directory context, we can sometimes use a relative path instead of an absolute one. Instead of specifying the full path from the toop level folder on the computer, we may describe the location of a file or folder as relative to the current working directory: the path starts at the folder we are currently in. To indicate that something is a relative path, we leave off the leading slash (on Mac) or drive identifier (on Windows).\n\n\n\nExample 1: if the hello.py program wanted to read from the test.qmd file that is stored in the same folder, the relative path would just be \"test.qmd\", because the files are in the same folder: there is no need to travel through other folders to find test.qmd.\nExample 2: suppose the program wanted to read in an image, mushrooms.jpg, from the SampleImages folder that is inside the Comp194 folder. The absolute path to this file would be \"/Users/susan/PycharmProjects/Comp194/SampleImages/mushrooms.jpg\", whereas the relative path from the code file would be \"SampleImages/hello.py\".\nExample 3: Suppose the hello.py program wanted to open an image file, CampingUpNorth2017.jpg that is in the Desktop folder (see the directory tree in Figure 3). The Desktop folder sits inside the home folder, susan. Neither of these are inside the current folder Comp194, of course, so we somehow need to indicate in the path to go up the directory tree to a higher level.\nPaths use the special marker .. to mean “go up one level in the directory tree.” In this example, we could either give an absolute path (\"/Users/susan/Desktop/CampingUpNorth2017.jpg\") or a relative one (\"../../Desktop/CampingUpNorth2017.jpg\"). There are two copies of the .. marker because of the way folders are nested: The first .. tells the program to go up one level, from Comp194 to PycharmProjects. The second .. tells the program to go up one more level, from PycharmProjects to susan. From there we can continue the path downwards as normal.\nRemember: you can always use an absolute path safely, but relative paths can be shorter and easier to remember.\nYou will get lots of practice specifying paths and using filename extensions as we work with images."
  },
  {
    "objectID": "Readings/Chapter3.html",
    "href": "Readings/Chapter3.html",
    "title": "Chapter 3, Webcams and Videos",
    "section": "",
    "text": "This chapter will introduce two main new concepts, one from Python and one from OpenCV. The Python concepts is indefinite looping (also called while loops). Unlike a for loop, which repeats a fixed number of times, while loops repeat until some condition changes. They can repeat any number of times, including zero times! The OpenCV concept is working with video. You might think of video as a completely different medium from regular still images, but to OpenCV, a video is just a series of images, and we can process them one by one.\nThis chapter will just touch on while loops, as there are readings elsewhere that will also cover them."
  },
  {
    "objectID": "Readings/Chapter3.html#what-is-a-while-loop-and-why-do-we-need-another-kind-of-loop",
    "href": "Readings/Chapter3.html#what-is-a-while-loop-and-why-do-we-need-another-kind-of-loop",
    "title": "Chapter 3, Webcams and Videos",
    "section": "1.1 What is a while loop, and why do we need another kind of loop?",
    "text": "1.1 What is a while loop, and why do we need another kind of loop?\nA while loop has a simpler structure than a for loop (in fact, you can duplicate the behavior of a for loop with a while loop, using accumulator variables. After the keyword while, we put a boolean expression. So long as that boolean expression evaluates to True (or any non-False value), the loop will continue.\n\nwhile &lt;boolean expression&gt;:\n    &lt;indented statements&gt;\n\nBefore each pass through the loop, the while statement evaluates the boolean expression over again. If the result is not True then the code stops looping and jumps to the next statement after the indented lines of the loop body. If the result is True, then the body of the loop is executed, and we repeat the process.\nNote: If we want a while loop to be able to end, then the boolean expression must include a variable whose value changes (or at least has the possibility of changing) during the\nWhat is the difference between an if statement and a while statement?\nAn if statement doesn’t repeat, it chooses among possible multiple code blocks, and performs one code block at most one time. A while loop repeats: it has one code block, and it repeats (1) evaluating the test expression, and (2) performing its code block, until the test expressions evaluates to False."
  },
  {
    "objectID": "Readings/Chapter3.html#the-break-and-continue-statements",
    "href": "Readings/Chapter3.html#the-break-and-continue-statements",
    "title": "Chapter 3, Webcams and Videos",
    "section": "1.2 The break and continue statements",
    "text": "1.2 The break and continue statements\nThere are two statements, break and continue that can alter the behavior of a loop. These apply to both for loops and while loops; we just haven’t introduced them before this point.\nKey points:\n\nBoth statements must occur inside a for or while loop (directly inside, in the same script or function)\nIf there are nested loops, these statements only affect the closest, innermost loop that contains them\nThe break statement causes the loop to end immediately\nThe continue statement causes Python to skip the rest of the loop body, and return to the next iteration of the loop\nUsually, break and continue statements occur inside an if statement that is inside the loop body (otherwise the loop would end on the first iteration)\n\nExamine the examples below before proceeding.\nBad uses of break and continue: the examples below show what happens if break or continue are placed, without being guarded by an if statement, inside a loop.\n\nfor i in range(5):\n    print(i, \"   (before break)\")\n    break\n    print(\"after break\")\nprint(\"---\")\nfor i in range(5):\n    print(i, \"   (before continue)\")\n    continue\n    print(\"after contine\")\n\n0    (before break)\n---\n0    (before continue)\n1    (before continue)\n2    (before continue)\n3    (before continue)\n4    (before continue)\n\n\nUsing break and continue in a single loop: The first example stops the while loop if the user enters 'quit', and the second example skips negative numbers in adding up the contents of a list.\n\nnames = []\nwhile True:   # A way to specify \"loop forever\"\n    nextName = input(\"Enter the next name, or quit to end: \")\n    if nextName == 'quit':\n        break\n    names.append(nextName)\nprint(names)\n\n\ntotal = 0\nfor v in [25, 101, 3, -2, 40, -35, -1023]:\n    if v &lt; 0:\n        continue\n    total = total + v\nprint(total)\n\n169\n\n\n**Using break and continue in nested loops: The first example uses break to stop the inner loop whenever the inner loop variable is greater than the outer loop variable.\n\nfor i in range(4):\n    print(\"i =\", i)\n    for j in range(4):\n        print(\"  j =\", j)\n        if j &gt; i:\n            break\n        print(\"  i - j =\", i - j)\n\ni = 0\n  j = 0\n  i - j = 0\n  j = 1\ni = 1\n  j = 0\n  i - j = 1\n  j = 1\n  i - j = 0\n  j = 2\ni = 2\n  j = 0\n  i - j = 2\n  j = 1\n  i - j = 1\n  j = 2\n  i - j = 0\n  j = 3\ni = 3\n  j = 0\n  i - j = 3\n  j = 1\n  i - j = 2\n  j = 2\n  i - j = 1\n  j = 3\n  i - j = 0\n\n\nThe second example uses continue instead, causing the inner loop to continue, without completing the last step.\n\nfor i in range(4):\n    print(\"i =\", i)\n    for j in [2, 0, 1, 3]:\n        print(\"  j =\", j)\n        if j &gt; i:\n            continue\n        print(\"  i - j =\", i - j)\n\ni = 0\n  j = 2\n  j = 0\n  i - j = 0\n  j = 1\n  j = 3\ni = 1\n  j = 2\n  j = 0\n  i - j = 1\n  j = 1\n  i - j = 0\n  j = 3\ni = 2\n  j = 2\n  i - j = 0\n  j = 0\n  i - j = 2\n  j = 1\n  i - j = 1\n  j = 3\ni = 3\n  j = 2\n  i - j = 1\n  j = 0\n  i - j = 3\n  j = 1\n  i - j = 2\n  j = 3\n  i - j = 0\n\n\n\n1.2.1 Strategic use of infinite loops\nOne of the examples above showed how to build an infinite loop. If a while loop has True as the boolean expression for its test, then it cannot every stop looping naturally. However, we can include conditions checked by if statements inside the loop, and we can break out of the loop when we need to.\n\nwhile True:\n    ...\n    if &lt;test&gt;:\n        break\n    ...\n\nRemember that the test of a while loop is evaluated before running the loop even one time. This means that (1) we have to have all values for the boolean expression ready to evaluate before the loop, and (2) there is a chance that the loop body will not even execute one time. The infinite loop form above (while True) ensures that the body of the loop will execute at least once, allowing us to delay the evaluation of the test condition until later inside the loop."
  },
  {
    "objectID": "Readings/Chapter3.html#allow-the-user-to-quit-the-program",
    "href": "Readings/Chapter3.html#allow-the-user-to-quit-the-program",
    "title": "Chapter 3, Webcams and Videos",
    "section": "2.1 Allow the user to quit the program",
    "text": "2.1 Allow the user to quit the program\nThe sample program in the previous section had one major flaw: there was no way to quit the program without using the Stop button in Pycharm. Otherwise, the program would run until the camera itself disconnected. We would like to add a mechanism for the user to quit the program, and also for us to interact with programs like this while they are running. We can do this by using the return value of the waitKey function.\nWe have ignored the return value of waitKey up to this point. But it does return a value, one of these two:\n\nIt returns -1 if the user pressed no key\nIt returns a number representing the keyboard key pressed by the user\n\nRemember the ASCII table, which maps small integers to keyboard characters. The original ASCII values, developed for English uses, used the numbers from 0 to 127. The extended ASCII set adding character bindings for the numbers from 128 to 255, including many more common international symbols that use the same general alphabet. In recent years, Unicode has become popular, as it has the capacity to represent multiple alphabets, but the basic English/roman alphabet symbols, as defined by the ASCII table, are still the same in Unicode.\nThe waitKey function returns the decimal integer associated with the key the user hit (or -1 if no key was pressed). Look at the Dec column in the table. We need to be able to convert that number into the corresponding character. Python provides two helpful functions for just this purpose: chr converts an integer between 0 and 255 into the character equivalent, and ord converts a character into its integer equivalent.\nThe example program below adds in lines that:\n\nSave the return value of waitKey into a variable\nCheck if that variable was -1 (in which case it does nothing)\nIf not, then it converts the value to a character with chr\nIt prints the character value, along with its numeric value\nIf the user typed a 'q', then it breaks out of the loop\n\n\nimport cv2\n\ncap = cv2.VideoCapture(0)\n\nwhile True:\n    ret, img = cap.read()\n    if not ret:\n        break\n        \n    cv2.imshow(\"Webcam\", img)\n    x = cv2.waitKey(10)\n    if x != -1:\n        ch = chr(x)\n        print(x, chr(x))\n        if ch == 'q':\n            break\n\ncap.release()"
  },
  {
    "objectID": "Homework/Homework1.html",
    "href": "Homework/Homework1.html",
    "title": "Homework 1",
    "section": "",
    "text": "This assignment is individual work!\n\nDo not share or borrow solutions from other students.\nDo not use AI assistants to generate code for you.\nDo ask preceptors and instructors for help with the code, including what to write and debugging.\nDo ask peers or AI assistants for help in understanding error messages, but not for help in writing or debugging your work.\n\nThis homework assignment will ask you to demonstrate your skills at understanding, debugging, planning, and creating python scripts and function. The list of topics for this assignment include:\n\nScripts, statements, expressions, variables\nFor loops\nConditionals (if statements)\nFunctions\nColor and image representations in OpenCV, reading and displaying images\nDrawing on images using OpenCV tools\n\nTo hand in: You will use the Homework 1 Github Assignment to set up this assignment, and to push your code to save it to the cloud, to hand it in.\nHandling images: We don’t need to include all the images in the SampleImages folder in every Github repo we make. Therefore, you should copy the folder into this project, but do not add them to the repo. That way, they won’t be included in the cloud stored version. One exception: If you choose for question 4 or question 6 to use your own background images, copy the image into this project and do add your images to the repo, or else your graders won’t be able to run your code the way you want."
  },
  {
    "objectID": "Homework/Homework1.html#specifications-for-question-1",
    "href": "Homework/Homework1.html#specifications-for-question-1",
    "title": "Homework 1",
    "section": "Specifications for Question 1",
    "text": "Specifications for Question 1\nBase specifications:\n\nEach line of code is followed by a descriptive comment\nEach line comment accurately describes all effects of the line\nA comment at the top describes the overall purpose of the script\n\nExtended specifications:\n\nThe descriptive comment at the top is a triple-quoted string\nAdd your name to the top comment\nRemove TODO comments as they are completed\nEach line comment has spaces at the front to indent the comment for easier reading\nAll TODO comments have been removed (because they have been completed)\n\nRatings:\n\nTo receive a gold rating, complete all base specifications, and at least 2 of the extended specifications.\nTo receive a silver rating, complete at least two base specifications.\nTo receive a bronze rating, complete at least one base specification."
  },
  {
    "objectID": "Homework/Homework1.html#specifications-for-question-2",
    "href": "Homework/Homework1.html#specifications-for-question-2",
    "title": "Homework 1",
    "section": "Specifications for Question 2",
    "text": "Specifications for Question 2\nBase specifications:\n\nIdentify/mark one actual bug\nMarks the first bug with a comment that accurately describes the bug and its correction\nCorrect the first bug\nIdentify/mark a second actual bug\nMark the second bug with a comment that accurately describes the bug and its correction\nCorrect the second bug\nIdentify/mark a third actual bug\nMark the third bug with a comment that accurately describes the bug and its correction\nCorrect the third bug\nIdentify/mark a fourth actual bug\nMark the fourth bug with a comment that accurately describes the bug and its correction\nCorrect the fourth bug\nIdentify/mark a fifth actual bug\nMark the fifth bug with a comment that accurately describes the bug and its correction\nCorrect the fifth bug\n\nExtended specifications:\n\nAdd your name to the top comment\nRemove TODO comments as they are completed\nIdentify/mark the sixth and final bug\nMark the sixth bug with a comment that accurately describes the bug and its correction\nCorrect the sixth bug\n\nRatings:\n\nTo receive a gold rating, complete all base specifications, and at least 3 of the extended specifications.\nTo receive a silver rating, complete at least 12 specifications, at least 10 base.\nTo receive a bronze rating, complete at least 10 specifications, at least 8 base."
  },
  {
    "objectID": "Homework/Homework1.html#your-task-an-algorithm-to-draw-circles-on-an-image",
    "href": "Homework/Homework1.html#your-task-an-algorithm-to-draw-circles-on-an-image",
    "title": "Homework 1",
    "section": "Your task: an algorithm to draw circles on an image",
    "text": "Your task: an algorithm to draw circles on an image\nYour goal is to plan out, in pseudocode, an algorithm that would take in an image and the number of circles, and it would draw that many circles on the image. Each circle should have a random location (its center point may be anywhere within the image), a random radius between 10 and 50, and a random color.\nThere are two main ways for you to make random colors.\n\nOne approach would be to make a palette, a list containing color tuples that you have selected. Then your algorithm would choose one of the tuples from the list randomly, for each circle.\nThe other approach is to generate random values for red, green, and blue, each one between 0 and 255. This would allow you to generate any possible color, but some of those colors might be very dark, very light, or just plain ugly.\n\nThis is your choice. Decide on it, and write your pseudocode so it is clear which approach you chose.\nPut your pseudocode for this question in the q3Pseudocode.txt file (note that it is not a Python file)."
  },
  {
    "objectID": "Homework/Homework1.html#specifications-for-question-3",
    "href": "Homework/Homework1.html#specifications-for-question-3",
    "title": "Homework 1",
    "section": "Specifications for Question 3",
    "text": "Specifications for Question 3\nBase specifications:\n\nStart pseudocode with an algorithm “declaration” line that shows the name and the inputs\nThe lines of the algorithm are not written in Python notation\nThe algorithm includes a loop for drawing multiple circles\nThe algorithm has roughly 7-10 steps\nThe algorithm is substantially correct, describes a correct process for determining and drawing the circles\n\nExtended specifications:\n\nThe pseudocode uses indentation to indicate steps that are part of a loop or conditional\nThe pseudocode contains comments to explain its purpose, and to highlight the phases in the code\n\nRatings:\n\nTo receive a gold rating, complete all base specifications, and at least 1 of the extended specifications.\nTo receive a silver rating, complete at least 4 specifications in all, at least 3 base specifications.\nTo receive a bronze rating, complete at least 3 base specifications."
  },
  {
    "objectID": "Homework/Homework1.html#specifications-for-question-4",
    "href": "Homework/Homework1.html#specifications-for-question-4",
    "title": "Homework 1",
    "section": "Specifications for Question 4",
    "text": "Specifications for Question 4\nBase specifications:\n\nUse a for loop effectively to repeatedly draw circles\nGenerate x position random value as an integer in the correct range\nGenerate y position random value as an integer in the correct range\nGenerate radius random value as an integer in the correct range\nGenerate random color value as tuple of integers in the correct range\nDraw filled in circles of random sizes, positions, and colors\nProgram works correctly, as described above:\n\nReads in a background image\nAsks the user for how many circles\nUses drawCircles to draw that many circles randomly (as defined above)\n\n\nExtended specifications:\n\nAdd your name to the top comment\nRemove TODO comments as they are completed\nGive parameter variables meaningful variable names\nInclude a descriptive comment as a triple-quoted string just below the def line that describes what the function does\n\nRatings:\n\nTo receive a gold rating, complete all base specifications, and at least 2 of the extended specifications.\nTo receive a silver rating, complete at least 7 total specifications, at least 5 base.\nTo receive a bronze rating, complete at least 5 total specifications, at least 3 base."
  },
  {
    "objectID": "Homework/Homework1.html#step-1-examine-and-understand-the-starter-code",
    "href": "Homework/Homework1.html#step-1-examine-and-understand-the-starter-code",
    "title": "Homework 1",
    "section": "Step 1: Examine and understand the starter code",
    "text": "Step 1: Examine and understand the starter code\nWork through the steps below that guide you in making sense of the starter program\n\nRun q5Rainbows.py. It should produce an output that looks like Figure 3.\n\n\n\n\n\n\n\nFigure 3: The final image from the starter code\n\n\n\n\nNotice that the red rectangles are drawn where we ultimately want the rainbows to be drawn\nExamine the script at the bottom of the file.\n\nIt reads in the image\nThen, it has a pair of nested for loops that iterate over (x, y) coordinates where we want to draw rainbows\nIt calls the function drawRainbow once for each (x, y) pair\nIt then displays the image\nThe call to waitKey here is passed the value 100, this causes the program to pause for 100 milliseconds and then to go on, not to wait indefinitely for the user to hit a key\n\nYou don’t need to modify the main script. Just understand what parts of the problem it does for us (placing rainbows in a grid and displaying the image)\nNext, examine the function drawRainbow.\n\nIt takes in the image and the (x, y) position to center the rainbow on (this will be the center point of the full ellipse, so when we draw a half-ellipse this point will sit on the bottom of the half-ellipse)\nNotice the defined list colors: this defines colors for the seven ROY-G-BIV rainbow colors\nNotice the call that draws the red rectangle: do you understand why we pass the two points the way we do?"
  },
  {
    "objectID": "Homework/Homework1.html#step-2-change-rectangle-for-half-ellipse",
    "href": "Homework/Homework1.html#step-2-change-rectangle-for-half-ellipse",
    "title": "Homework 1",
    "section": "Step 2: Change rectangle for half-ellipse",
    "text": "Step 2: Change rectangle for half-ellipse\nWe will use incremental development to change the program one step at a time toward what we want.\nFor this step, we want to change the red rectangle to a red half-ellipse that is centered on the (x, y) position that is a parameter of the function, and that has currSize for both horizontal and vertical axes. It should draw only the upper half of the ellipse (that might take some experimentation).\nRemove the call to rectangle and add a call to ellipse, changing the inputs accordingly. (Make sure you keep the assignment of currSize to 100, we will need that later!)\nThe result of this step should look like Figure 4; don’t go on until you are producing this result.\n\n\n\n\n\n\nFigure 4: The resulting image from step 2"
  },
  {
    "objectID": "Homework/Homework1.html#step-3-add-the-other-colors",
    "href": "Homework/Homework1.html#step-3-add-the-other-colors",
    "title": "Homework 1",
    "section": "Step 3: Add the other colors",
    "text": "Step 3: Add the other colors\nFor this last step, we are going to draw a series of ellipses centered at the same location, each one smaller than the one before, and each one the next color in the rainbow (and the colors list).\n\nBetween the definition of currSize and the call to ellipse, insert a for loop that iterates over the colors in the colors list.\nIndent the call to ellipse so it is part of the loop body.\nUse the loop variable in place of the current color in the call to ellipse (If you run the code at this point, you should see violet half-ellipses instead of red ones.)\nThe last step is to reduce the size of the half-ellipse for each iteration of the for loop. To do this we will turn currSize into an accumulator variable, by subtracting 15 from its value inside the loop. Add a line after the call to ellipse. Make sure the new line is indented to match the ellipse call. On that line, update currsize to have the value of currSize - 15.\n\nTry running the program at this point. If you’ve done each step correctly, you should see the target picture."
  },
  {
    "objectID": "Homework/Homework1.html#specifications-for-question-5",
    "href": "Homework/Homework1.html#specifications-for-question-5",
    "title": "Homework 1",
    "section": "Specifications for Question 5",
    "text": "Specifications for Question 5\nBase specifications:\n\nCall to rectangle has been replaced with a call to ellpse\nEllipses are drawn as a half-circle, currSize by currSize, the top half of the circle, filled in\nCode includes a for loop that iterates over the colors in the colors list\nColors of the ellipses are the rainbow colors in order, as given in the colors list\nThe program works correctly, producing the goal image shown above\n\nExtended specifications:\n\nAdd your name to the top comment\nRemove TODO comments as they are completed\nMake the descriptive comment at the top be triple-quoted\n\nRatings:\n\nTo receive a gold rating, complete all base specifications, and at least 1 of the extended specifications.\nTo receive a silver rating, complete at least 5 specifications overall, at least 3 base.\nTo receive a bronze rating, complete at least 4 specifications overall, at least 2 base."
  },
  {
    "objectID": "Homework/Homework1.html#specifications-for-question-6",
    "href": "Homework/Homework1.html#specifications-for-question-6",
    "title": "Homework 1",
    "section": "Specifications for Question 6",
    "text": "Specifications for Question 6\nBase specifications:\n\nThe program must load a background image\nUse at least three different drawing functions (circles, rectangles, ellipses, lines, etc.)\nThe tree must have at least 5 elements (at least five calls to drawing functions)\nUse at least three distinct colors (use a color picker to pick attractive colors)\nThe program must draw a recognizable tree (or part of a tree)\nInclude a descriptive comment at the top like we used for earlier questions, that gives the file name, author, and a description of what your program will draw\n\nRatings:\n\nTo receive a gold rating, complete all base specifications.\nTo receive a silver rating, complete at least 4 base specifications.\nTo receive a bronze rating, complete at least 3 base specifications."
  },
  {
    "objectID": "In-Class-Activities/ICA1-BasicPython.html",
    "href": "In-Class-Activities/ICA1-BasicPython.html",
    "title": "ICA: Basic Python and PyCharm",
    "section": "",
    "text": "Overview\nToday you will learn a bit about Python, and some basic kinds of data Python can manipulate. You’ll learn how to store values in variables, and how to build expressions that can be evaluated to produce a value. You will learn how to put sequences of Python statements and expressions in a file, called a script, which can be saved and re-run at a later point.\nWhat to hand in: This activity will use a Github assignment to distribute code to you (see the How to Use Github and Git Through PyCharm document for details). You will modify some of the files provided to you, and you will add two new files, bikescript.py and flowers.py. You will then push your code to the Github assignment to hand it in.\n\n\nPython\nPython provides an interactive shell that we use to communicate with it, much like a calculator provides an interface that we use to communicate with it. With Python, you can type a series of Python statements into the shell, and get immediate responses to each one. You can also package up a series of statements as a script, in a file. When you run the script, Python executes each statement in order.\n\n\nPyCharm\nThere are many different applications we could use when writing Python programs, much as there are many different text editor and word processor applications for writing papers. Your books may refer to a program editor called IDLE, which typically comes with Python when you download it. We will not use IDLE this semester. Instead, we will use an editor called PyCharm.\nFirst, look at the Getting Started with Python and PyCharm document and work through the sections on starting up PyCharm, setting up a project, and creating a Python file.\nIf you haven’t already done so, create a project for this activity. You should then see several areas in the PyCharm window, similar to Figure 1. At the left is the Project panel, where you can see the project and the files that are in it. On the right, the largest panel is the editor, where you can create program files.\n\n\n\n\n\n\nFigure 1: PyCharm Layout, annotated\n\n\n\nThe panel at the bottom in Figure 1 is used to display the output when we run a Python code file, but it can also be used to interact with Python through the Python Console. Typically, you can find and open the Python Console by looking for the Python Icon (!Images/ICA-1-Images/PyConsoleIcon.png) and clicking on it. If you cannot find it, ask for help!\nClick in the Python Console area, where you see the &gt;&gt;&gt; symbol. That symbol is a prompt, it is Python’s way of telling you that it is ready to accept input from you. Note that you can change the size of each area in the window by clicking and dragging in the space between regions.\n\n\nTry these examples\nTry the examples below in PyCharm’s console, typing each one in turn. Note: variables in computer science are similar to variables in math, but not identical. Think of a variable as being a name for a box in the computer’s memory, where you can stick a value of some kind.\n\n5 + 2                   # Computes the sum of two numbers\nx = 100                 # Assigns the value 100 to variable x\n(2 * x) - 33            # Computes the value 2x-33\n2 ** 4                  # Computes the value $$2^4$$, (** means exponentiation)\nz = (x - (5 * 4))       # Assigns the value of the expression to variable z\nprint(10 * 3, x, z)     # Prints the values of each expression on a line\nstrng = 'Hello there'   # Assigns variable strng to be the string\nprint(strng)            # Print the values of the strng variable\n\n30 100 80\nHello there\n\n\nA variable in a programming language represents a piece of the computer’s memory, where we can store data. In Python any variable can hold any kind of data, no matter the size or type. A **variable assignment statement*, like x = 100 above, assigns the name x to a particular location in memory, and stores the value of 100 in it. Only the value of the righthand side of the assignment is stored. We can reassign any variable to a new value at any time, just by writing another assignment statement.\nExperiment with this by adding to this script in PyCharm: insert two lines after the first print statement in the script. Reassign x to have the value 250, and then copy the print statement a second time after that. What happened to the value of z?\nThere is nothing to hand in for this part.\n\n\nCreating scripts\nNext, let’s experiment with the editor pane. We can write a series of Python statements in the editor pane, and save them to a file. Then we can ask Python to perform the entire set of statements one after the other.\nTo create a new Python code file, you can either (1) select New… from the File menu , (2) right-click (control-click on Mac) on either the project folder name or one of the code file names and select New, or (3) use the keyboard shortcut (command-N on Mac, alt-Insert on Windows). Make sure to select Python File as the type of new thing to create, and give a name for the file when prompted. PyCharm will add the .py extension to the filename if you leave it off.\nCreate a new Python file called bikescript.py, and copy the Python statements below into that file. The script below calculate how many days a bicycle trip will take, if you can bike 50 miles each day.\n\ntripDist = 420   # total miles in the trip\nbikePerDay = 50   # miles you can bicycle in a day\ntripDays = tripDist / bikePerDay\nprint(\"To bike\", tripDist, \"miles, \", bikePerDay, \"miles per day,\")\nprint(\" takes\", tripDays, \"days.\")\n\nTo bike 420 miles,  50 miles per day,\n takes 8.4 days.\n\n\nTo run this script, either select Current File as the current run option, and then click the green arrow run button (both in the upper right corner of the window), or right-click on the background of the editor panel and select Run. Once you have run the program once, you can use the right arrow in the bottom left or the upper right to run it again. Holding down control-shift-r will also run the script.\nRun your script, and make sure that you get the same result as is displayed above.\nTo hand in: You will hand in this script file when you are done, so don’t erase it or overwrite the script contents!\n\n\nDebugging Programs\nYour project should already have a folder called buggyScripts that contains five Python code files. Each of these files has a bug of one kind or another in it.\nJust as when you write a paper, you must take time to proofread it to find typos and other mistakes, when you write a program, you must debug it to find all errors in your scripts. But because you are communicating with a machine, not a person, you have to be exact: the computer cannot understand you at all if there are errors, bugs, in your code. Or the computer may do exactly what you wrote, but not what you meant to do.\nIt is also important that you learn to read code, and to predict what will happen when you run the code. Just like learning a human language, you must learn to read if you want to learn to write!\nYour reading talked about three kinds of errors in a program: syntax errors, runtime errors, and semantic errors. Look at each of the scripts stored in files scriptA.py through scriptE.py, in the buggyscripts folder. Open each script in PyCharm, and find the bug or bugs in it. Change the script to correct the bug (or at least to stop it from happening). Add a comment to the file that describes what you did.\nHow do you find the bugs? Take it step by step:\n\nStart by seeing if PyCharm itself finds anything wrong, and read what it says. Look for a red squiggly line under code, or a red horizontal line at the right edge of the edit panel. Hover over the red line, and it will pop up an explanation of what it sees as wrong.\nTry running the program, and read any error message that appears (printed in red). It will specify the kind of error, and tell you on what line of the code the error was detected.\nAdd print statements before the line where the error, if any, took place, and display the values of variables, or just a message to tell you that the program got to that line.\nRead through the program line by line and predict what should happen, then check if it really is what is happening.\nIf no error is detected by PyCharm, and no error occurs when you run the program, the last step is to check if the output of the program is correct. Logical errors occur when we calculate something incorrectly: always check if the output is correct!\n\nTo hand in: Hand in these scripts, with corrections and comments added (as described above).\n\n\nCreate your own script\nSuppose I want to plant a garden bed with flowers. Each flower must sit in the middle of a 6 inch by 6 inch square to ensure it has enough room to grow. Because I am obsessive about order, I want the flowers laid out in a perfect grid: rows and columns. If my garden bed is 10 feet long, and 2 feet wide, how many flowers would I need to buy to make my grid? (For those new to American units, there are 12 inches in a foot.)\nYou can compute how many rows of flowers will fit in the bed, and how many columns for each row. Then multiply to find the total number of flowers.\nCreate a new script file called flowers.py. In that file, define a variable bedLen to hold the value 10 (the length in feet of my garden bed), and define variable bedWidth to be the value 2 (the width in feet of my garden bed). Then write a Python expression to calculate how many rows of flowers will fit in the bed, and how many columns of flowers. Define variables to hold each of these values. Then compute and print the total number of flowers, along with an explanatory string.\nRun the script, and use the tools from earlier sections to debug your program until it computes the right value.\nChange bedLen to be 30 and bedWidth to be 3.5, and test your program. Does it correctly calculate the number of flowers for this new garden bed size? Make your program general enough to work for any reasonable length and width.\nTo hand in: The flowers.py file should be saved, not deleted or overwritten, to hand in.\n\n\nHanding in this assignment\nOnce you have finished editing all the Python files for this activity, you will need to Commit and then Push your code. See the appropriate section of the How to Use Github and Git Through PyCharm for details, and ask for help if you need it."
  },
  {
    "objectID": "In-Class-Activities/ICA3-Modules-OpenCVBasics.html",
    "href": "In-Class-Activities/ICA3-Modules-OpenCVBasics.html",
    "title": "ICA: Modules and OpenCV basics",
    "section": "",
    "text": "In this activity, you will practice the basics of importing and using modules while exploring the math and random modules. You will then jump into using OpenCV to read and display images.\nTo hand in: You will use Github Assignment to set up this assignment, and to push your code to save it to the cloud, to hand it in."
  },
  {
    "objectID": "In-Class-Activities/ICA3-Modules-OpenCVBasics.html#an-extra-challenge-if-you-have-time",
    "href": "In-Class-Activities/ICA3-Modules-OpenCVBasics.html#an-extra-challenge-if-you-have-time",
    "title": "ICA: Modules and OpenCV basics",
    "section": "An extra challenge if you have time",
    "text": "An extra challenge if you have time\nTry any of these if you have time and interest:\n\nDraw multiple objects in your picture, not just one\nPick a landmark (x, y) coordinate on your stick-figure person, and describe all other coordinates as offsets from that landmark. Once you have done that, you can move the whole stick figure around, or draw multiple copies, just by changing the starting landmark coordinates. Draw stick figures at random locations on your background image.\nMake a simple animation with 3-4 frames by clearing and redrawing after each call to waitKey, with small differences between each frame."
  },
  {
    "objectID": "In-Class-Activities/ICA6-FunctionBasics.html",
    "href": "In-Class-Activities/ICA6-FunctionBasics.html",
    "title": "ICA: Function Basics",
    "section": "",
    "text": "This activity starts by reviewing how function calls work, and then moves on to examine simple function definitions. Be sure to look at all readings and videos, including the class notes document. before jumping into this activity!\nKey ideas:\nFunctions are names for a set of instructions that operate on provided data.\nA function has:\n\nA name\nA set of input parameters: to run, the function needs a value for each input parameter\nA body, which is the set of statements to perform when the function is called.\n\n\n\nRemember the format for a function definition. A function definition needs to specify (1) the name of the function, (2) the inputs to the function, and (3) what should happen when the function is called including what value should be returned, if any. Below is an outline of what a function definition looks like–it’s not a real function, though.\n\ndef functionName(var1, var2, …):\n    function body, indented statements that say what to do when the function is called\n\nA function definition has a header line that defines the function name and its input parameters. It then has an indented body, the statements to run. The function does not run when you make a definition. It only runs when you call the function.\nThink of this metaphor:\n\n\n\nFunctions\nCooking\n\n\n\n\nfunction definition\nrecipe\n\n\nfunction call\ncook makes the food!\n\n\n\n\n\n\nAn environment is the set of variables and function names that are defined during the run of a program. * Environment is a table mapping variable/function names to their values\n\nGlobal environment: All global variables, all functions defined at the global level, are stored here. It lasts throughout the run of the program\nLocal environment: A local environment is made when we call a function, holding the function’s variables. It is created at the start of the function call, and lasts until the function call ends."
  },
  {
    "objectID": "In-Class-Activities/ICA6-FunctionBasics.html#function-definitions",
    "href": "In-Class-Activities/ICA6-FunctionBasics.html#function-definitions",
    "title": "ICA: Function Basics",
    "section": "",
    "text": "Remember the format for a function definition. A function definition needs to specify (1) the name of the function, (2) the inputs to the function, and (3) what should happen when the function is called including what value should be returned, if any. Below is an outline of what a function definition looks like–it’s not a real function, though.\n\ndef functionName(var1, var2, …):\n    function body, indented statements that say what to do when the function is called\n\nA function definition has a header line that defines the function name and its input parameters. It then has an indented body, the statements to run. The function does not run when you make a definition. It only runs when you call the function.\nThink of this metaphor:\n\n\n\nFunctions\nCooking\n\n\n\n\nfunction definition\nrecipe\n\n\nfunction call\ncook makes the food!"
  },
  {
    "objectID": "In-Class-Activities/ICA6-FunctionBasics.html#environments",
    "href": "In-Class-Activities/ICA6-FunctionBasics.html#environments",
    "title": "ICA: Function Basics",
    "section": "",
    "text": "An environment is the set of variables and function names that are defined during the run of a program. * Environment is a table mapping variable/function names to their values\n\nGlobal environment: All global variables, all functions defined at the global level, are stored here. It lasts throughout the run of the program\nLocal environment: A local environment is made when we call a function, holding the function’s variables. It is created at the start of the function call, and lasts until the function call ends."
  },
  {
    "objectID": "In-Class-Activities/ICA9-NumpyAndImageArith.html",
    "href": "In-Class-Activities/ICA9-NumpyAndImageArith.html",
    "title": "ICA: Numpy Arrays and Image Arithmetic",
    "section": "",
    "text": "In this activity, we will take a closer look at images as matrices and what we can do with them in that context. You will practice with basic Numpy tools operating on both image arrays and smaller practice arrays. We will look at how to use simple arithmetic operations on matrices to change colors, brightness, and more. We will examine how to access the channels of an image, and will create regions of interest, subsections of images that we want to focus on.\nThe Github repository for this assignment will contain a starter code file, activ9.py. Put your code in this file, as directed by the TODO comments."
  },
  {
    "objectID": "In-Class-Activities/ICA9-NumpyAndImageArith.html#creating-arrays",
    "href": "In-Class-Activities/ICA9-NumpyAndImageArith.html#creating-arrays",
    "title": "ICA: Numpy Arrays and Image Arithmetic",
    "section": "Creating arrays",
    "text": "Creating arrays\nThe list of functions below allows us to create Numpy arrays from scratch. With this, we can make a blank canvas to use the Numpy drawing functions, create synthetic images, or just make a black and white mask or frame to apply to an image.\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\narray\nTakes a sequence data type (list, string, tuple, or Numpy array), and builds a Numpy array with the same shape. Optional input allows us to specify the type of data for the array.\n\n\nzeros\nTakes in a tuple giving dimensions, and an optional input for the type of data, and it makes an array with the given dimensions and type, all filled with zeros.\n\n\nones\nSimilar to zeros but it fills the array with the value 1.\n\n\n\nTry this to hand in: Create a function blackCanvas that takes in two inputs, the width and height for the canvas, and it creates a new color Numpy array all filled with black, with the given width and height. It should return the new image array. In your main script, try several test calls to this function with different sizes of images, and draw a square centered in each.\nTry this to hand in: Create a function rgbStripes that takes in two inputs, the width and height for the new image. It should create a new image array of the given size. Then it should fill the first 1/3 of rows with red, the second 1/3 of rows with green, and the remaining rows with blue. There are at least four different ways of filling in the values (iterate over each row and column with nested for loops, iterate over each row and use slicing to assign the whole row at once, use slicing to select the whole region to be red, or green, or blue, or build a list the shape of the image and then convert it to a Numpy array). Pick the approach that suits you the best!"
  },
  {
    "objectID": "In-Class-Activities/ICA9-NumpyAndImageArith.html#subtracting-images",
    "href": "In-Class-Activities/ICA9-NumpyAndImageArith.html#subtracting-images",
    "title": "ICA: Numpy Arrays and Image Arithmetic",
    "section": "Subtracting images",
    "text": "Subtracting images\nWe can perform a simple kind of motion detection on frames from a video, by subtracting one frame from its predecessor. The Numpy module tells Python how to interpret the minus sign when applied to Numpy arrays. OpenCV has two functions for taking the difference: subtract and absdiff. The first one just does subtraction, the second one computes the absolute value of the difference for each corresponding value in the arrays.\nTry this to hand in: In the script section of the starter code file, add a script to experiment with subtracting two frames from a video (this video is one we will work with later, it shows Prof. Fox holding an orange ball and moving it around in the air):\n\nStart by reading in frame1.jpg and frame2.jpg\nUse imshow to display the two images; notice that frame 1 is slightly different from frame 2\nDefine a new image diff1 to be the result of calculating frame 1 minus frame 2, using the minus sign (-)\nDefine another new image diff2 to hold the result of OpenCV’s subtract function applied to frame 1 and frame 2\nDefine a third new image diff3 to hold the result of OpenCV’2 absdiff function\nUse imshow to display all three diff images\nExamine the results. Based on what you know about how Numpy and OpenCV handle arithmetic, and how subtract and absdiff differ from each other, explain why the three difference images look the way they are, and how they are different. Write this explanation in the starter code file, as a comment"
  },
  {
    "objectID": "In-Class-Activities/ICA9-NumpyAndImageArith.html#blending-images",
    "href": "In-Class-Activities/ICA9-NumpyAndImageArith.html#blending-images",
    "title": "ICA: Numpy Arrays and Image Arithmetic",
    "section": "Blending images",
    "text": "Blending images\nWe can use image arithmetic to blend two images together, using the addWeighted function from OpenCV. To blend two images, we want to look at corresponding pixels, and average their two red values to make a new red value, and do similarly with green and blue channel values. (It is kind of amazing that this works, actually!)\nResizing images\nIn order to blend two images, we need to make them the same size and shape. We could do that using the Numpy slicing operators, but here we will take a look at a function that lets you resize an image either by scaling it to a specific size, or by scaling it by given factors in the x and y directions.\n\ncv2.resize(&lt;img&gt;, (&lt;wid&gt;, &lt;hgt&gt;), fx=?, fy=?)\n\nThe resize function takes in the image to be resized, and a tuple giving the new size as width followed by depth, and it returns a new image of the new size. However, if we set the width and height in the tuple to be zero, then we can provide optional inputs that give the new size as a factor of the original. The optional input fx specifies the factor in the x dimension, and fy in the y dimension. If we set fx to 0.5, for example, then the new image will have a width one half the size of the original’s width.\nThe examples below illustrate different ways of calling resize.\n\n\n\n\n\n\n\nExamples\nMeaning\n\n\n\n\ncv2.resize(src, (100, 100))\nReturns a new stretch/squashed image that is 100 x 100 pixels\n\n\ncv2.resize(src, (0, 0), fx = 2, fy = 2)\nReturns a new image twice the size of the original\n\n\ncv2.resize(src, (0, 0), fx = 0.5, fy = 1.0)\nReturns a new image whose width is half the original size\n\n\n\nTry this to hand in: In the script section of the activity code file, read in three images from SampleImages (any ones you choose). Use the resize command to change the second and third images to match the size of the first. Be sure to imshow the images so that you can check your work. Call these images img1, img2, and img3.\nBlending with arithmetic\nExamine the code fragment below (also reproduced in your activity code file).\n\nblendImg1 = cv2.add(img1, img2)\ncv2.imshow(\"Blend by adding\", blendImg1)\n\nTry this fragment on the resized images you created in the previous section, and observe the results. If we just add the two images, the result is too bright, and would have tons of overflow artifacts if we used Numpy addition. We want to average the two image values, not just add them. But consider this: if we first add the images, and then divide by 2 (the way we typically think about computing an average) the result will be distorted. Even OpenCV’s addition operator avoids overflow by capping the values at 255 when they would have added up to more than 255. That means that adding and then dividing by 2 will produce a different result than dividing each original image by 2 and then adding.\nTry the code below on the images you resized, and compare blend1 and blend2.\n\nsumImg = cv2.add(img1, img2)\nblend1 = cv2.divide(sumImg, 2)\n\ndivImg1 = cv2.divide(img1, 2)\ndivImg2 = cv2.divide(img2, 2)\nblend2 = cv2.add(divImg1, divImg2)\n\nWe can also use Numpy commands to compute the average more easily, so long as we remember to divide first, and then add, to avoid overflow artifacts. Try this:\n\navgImg = 0.5 * img1 + 0.5 * img2\nblend3 = avgImg.astype(np.uint8)\n\nWeighted averages\nA normal average (add the two numbers and divide by 2) weights both pixels/images equally: 50% from one image and 50% from another. The previous example multipled each image by 0.5: by shifting from division to multiplication we can see that we are really multiplying each image by a weight, the percentage of the final image that should come from each image.\nWe can change the percentages, by changing the weights. Just make sure they are each between 0.0 and 1.0 and that they add up to 1.0, so that the resulting image has the same brightness as the originals.\nTry varying the weights for the example above, and examining the resulting blend.\nThe addWeighted function\nOpenCV actually provides a function, addWeighted, to perform a weighted average of two images.\n\nblend4 = cv2.addWeighted(img1, 0.5, img2, 0.5, 0)   \n\nThe addWeighted function has 5 required inputs: the first image to blend, the weight to multiply the first image by, the second image to blend, the weight for the second image, and a constant to add the result. In other words, the function computes this mathematical formula:\n\\[newIm = \\alpha \\cdot img1 + \\beta \\cdot img2 + \\gamma\\]\nTry this as an alternative to the Numpy arithmetic version, and compare the results.\nTry this to hand in: Create a function phaseBlend that takes in two images presumed to be the same size. This function should include the following steps:\n\nSet up one weight value, w, to be 0.0 (w is an accumulator variable foer this loop)\nRepeat with a for loop, ehough times for w to go to zero (experiment or calculate)\nInside the for loop, use w and 1 - w as the weights, and blend the two input images, assigning the result to a variable\nAlso in the loop, imshow the blended result, and include a waitkey\nFinally, in the loop, add a small amount to w to change the weight for next time (use 0.1 or 0.05, or similar)\nOptional extension: Instead of trying to time the loop stopping to when w gets to 1.0, we could change the direction of the blend and start reducing w each time (until it gets to 0.0). To do this, we need another accumulator variable, deltaW, to hold the amount to change w by each time. It will stay at 0.1 or 0.05 until w reaches 1.0, and then it should change to be -0.1/-0.05."
  },
  {
    "objectID": "In-Class-Activities/ICA10-WhileAndVideo.html",
    "href": "In-Class-Activities/ICA10-WhileAndVideo.html",
    "title": "ICA: While Loops and Webcams/Video",
    "section": "",
    "text": "In this activity, we will explore how to use the while loop to loop an uncertain, indefinite, number of times, and we will use while loops to help us to work with webcam video feeds, or stored video files.\nThe Github repository for this assignment will contain a starter code file, activ10.py. Put your code in this file, as directed by the TODO comments."
  },
  {
    "objectID": "In-Class-Activities/ICA10-WhileAndVideo.html#first-example",
    "href": "In-Class-Activities/ICA10-WhileAndVideo.html#first-example",
    "title": "ICA: While Loops and Webcams/Video",
    "section": "First example",
    "text": "First example\nThis function takes in an integer input, and it prints every other number from that input value down to zero. Then it prints Done!.\n\ndef printEveryOther(x):\n    while x &gt;= 0:  # x is the loop variable\n        print(x)\n        x = x - 2\n    # when indentation stops, while loop is over\n    print(\"Done!\")\n\n\nWhat happens when you put a typical value into this function?\nWhat happens if you put a negative value into the function?\nWhat happens if you change the boolean test to be x &gt;= 5?\n\nWork through a call to this function by hand, figuring out the effect of each and every line and repetition; consider a call like printEveryOther(7).\nTry this to hand in: Make a copy of printEveryOther function, called printEveryFifth, that prints every fifth value from x down to zero. Below are a couple of sample calls to show how this function should work:\n\nprintEveryFifth(20)\nprintEveryFifth(11)\n\n20\n15\n10\n5\n0\nDone!\n11\n6\n1\nDone!"
  },
  {
    "objectID": "In-Class-Activities/ICA10-WhileAndVideo.html#second-example",
    "href": "In-Class-Activities/ICA10-WhileAndVideo.html#second-example",
    "title": "ICA: While Loops and Webcams/Video",
    "section": "Second example",
    "text": "Second example\nThe next example shows the indeterminate nature of a while loop. In this case, the loop repeats until the user enters a negative number, printing the square of each number the user enters.\n\ndef squareUserNums():\n    # Initialize loop variable \n    userInp = input(\"Enter the next number (negative to quit): \")\n    userNum = int(userInp)\n    while userNum &gt;= 0:\n        print(userNum, \"squared is\", userNum ** 2)\n        userInp = input(\"Enter the next number (negative to quit): \")\n        userNum = int(userInp)\n\nExperiment with this function. Notice that the first two lines of the function are repeated again inside the while loop. Why is that?"
  },
  {
    "objectID": "In-Class-Activities/ICA10-WhileAndVideo.html#accumulator-variables",
    "href": "In-Class-Activities/ICA10-WhileAndVideo.html#accumulator-variables",
    "title": "ICA: While Loops and Webcams/Video",
    "section": "Accumulator variables",
    "text": "Accumulator variables\nWe can use accumulator variables with while loops just like we do with for loops. The accumulator is set to some initial value before the loop, and then updated each time through the loop. See the examples below.\n\ndef sumToN(topNum):\n    \"\"\"Takes in a number and computes and returns the sum of the numbers\n    from zero to the input number.\"\"\"\n    currVal = 0   # the loop variable\n    total = 0     # the accumulator variable\n    while currVal &lt; topNum:\n        total = total + currVal # add next value to accumulator\n        currVal = currVal + 1  # update the loop variable\n    return total\n\nExperiment with this function. Walk through what happens if you call this with some small value, like 4.\n\nWalk through the function by hand with your teammate/neighbor\nTry either adding print statements to see what happens in the loop, or using the debugger to watch how total and currVal change\n\n** Try this to hand in:** Write a function addUserNums that has no input arguments. Here are the steps for this function, written in pseudocode:\n\nInitialize sumOfNums, an accumulator variable, to zero\nAsk the user for a number (be sure to convert their input from string to number)\nLoop until the user enters the value 0\n\nUpdate sumOfNums by adding the user’s number to it.\nAsk again for the user to enter a number.\n\nreturn sumOfNums"
  },
  {
    "objectID": "In-Class-Activities/ICA10-WhileAndVideo.html#the-break-statement",
    "href": "In-Class-Activities/ICA10-WhileAndVideo.html#the-break-statement",
    "title": "ICA: While Loops and Webcams/Video",
    "section": "The break Statement",
    "text": "The break Statement\nSometimes you want the option to stop looping if special circumstances occur, before the natural end of the loop. The break statement causes the current loop to stop immediately at the point where the break occurred. The program continues on with any Python statements that come after the loop.\nThe program below loops over characters in a string, adding them to an accumulator variable. It breaks out of the for loop when the next character is a space, tab, or newline, and returns the string it has built so far.\n\ndef nextWord(text):\n    \"\"\"Takes in a string of text and builds and returns a new string\n    that is the next \"word\" in the text. In other words, the next\n    sequence of characters up to a space, tab, or newline.\"\"\"\n    wordStr = \"\"\n    i = 0\n    for ch in text:\n        if ch in \" \\t\\n\":  # if character is space, tab (\\t), or newline (\\n)\n            break\n        else:\n            wordStr = wordStr + ch\n    return wordStr\n\nTry this to hand in: We’re going to rewrite the squareUserNums function from earlier to avoid repeating the two lines that get the next number from the user. To do so, we will use a common: while True combined with break.\nDo this first:\n\nCopy the definition of squareUserNums from earlier and change its name to squareUserNums2.\nRemove the two lines before the while loop (the call to input and the call to int).\nChange the boolean expression test of the while statement to be just the boolean value True, as shown below:\n\n\ndef squareUserNums2():\n  while True:\n    ...\n\nUsing True as the test expression is a way to create a loop that never ends. Inside the loop, we can use an if statement to break out of the loop when conditions are right.\nNext, move around the pieces inside the while loop, and add an if statement:\n\nInside the while loop in squareUserNums, move the last two lines (where userInp and userNum are defined) to be the first statements inside the while loop.\nAfter those two lines, and before the print call, add an if statement. If userNum is less than zero, then break.\n\nThis function should behave just like the earlier one, but without the copied lines."
  },
  {
    "objectID": "In-Class-Activities/ICA10-WhileAndVideo.html#ending-the-program-with-key-input",
    "href": "In-Class-Activities/ICA10-WhileAndVideo.html#ending-the-program-with-key-input",
    "title": "ICA: While Loops and Webcams/Video",
    "section": "Ending the program with key input",
    "text": "Ending the program with key input\nBe sure to check the readings for today for how to use waitKey to get the key the user pressed.\n\nModify the code above like the example in Chapter 3 of our Vision readings, so that it catches the value returned by waitKey and checks it to see if the value is -1. If not, convert it to a character with chr and see if the user typed 'q'. Break out of the loop if so.\nAdd a function called processImage to the file. It should take in an image and return an image. For now just have it return the image it is passed (we will add functionality in later steps).\nInsert a call to processImage in between the vidCap.read() line and the cv2.imshow line. Pass img to processImage, and assign the returned image to img2.\nChange the displayed image to be img2.\n\nNow that you have a functioning video streaming program, let’s start making improvements.\nTry to hold something up in front of the camera while your program is running, and then move the object to the different corners of the video image. Did you find yourself moving the wrong way? We often have trouble with left and right movements on a video feed, because we are more used to seeing a mirror image of ourselves. We can use the OpenCv function flip to flip the image. This function will flip an image upside down, or left-to-right.\n\nflippedIm = cv2.flip(img, flipCode)\n\nThe flip function takes in an image and a flip code which specifies whether to flip around the horizontal axis, or around the vertical one. It returns a new image. A flip code of 0 will flip a picture upside down (around the horizontal axis), and a flip code of 1 will flip a pictures left-to-right (around the vertical axis).\nTry this to hand in: For this task, you will add an option of display the flipped version of the video feed.\n\nModify your processImage function so that it takes in an extra input: doFlip. When doFlip is True, the function should call the flip function, using flip code 1, and should return the resulting image. When doFlip is False, the function should return the original image.\nIn your main program, you will need to set up a boolean flag variable. This is a special kind of accumulator variable that just holds True or False. We call it a flag variable because it signals when a certain condition holds\n\nBefore the while True loop, set up the flag variable to be False\nInside the loop, add the flag variable to the call to processImage\nAdd to the if statement that checks the user’s input key: if the user hits the f key, we want to toggle the value of the flag variable: if it was False, it should become True, and vice versa.\n\n\nTry this to hand in: Suppose that you wanted to be able to save individual frames from the video feed to image files.\n\nAdd to the if statement that checks the user’s input key, so that it checks if the user hits the s key\nWhen the user hits that, save the current image to a file, using the cv2.imwrite function. This function takes two inputs: (1) a string for the filename of the file to save to, including .jpg or .png as the filename extension, and (2) the image you want to save.\n\n\ncv2.imwrite(\"screenshot.jpg\", frame)\n\nFor an extra, optional challenge, give each screenshot a unique filename, so that you can save any number you want. (Adding a counter to the loop, and attaching the counter to the filename is a great way to do this.)\nTry this to hand in: Let’s apply the color shuffle function from the previous activity to the video feed.\n\nFind your implementation of colorShuffle and copy it into this code file (if you didn’t complete it, ask for help from a partner, preceptor, or instructor).\nAdd a call to colorShuffle to your processImage function. For this one, we won’t require that the user hit a key to trigger it, it should just get called every time.\n\nWhat happens?\nWhat should have happened was a bit of chaos: the color scheme should flicker from frame to frame into different color patterns. How could we fix this?\nOptional fix: A better model than just random shuffling every frame might be to trigger a shuffle pattern every time the user hits a particular key, and then keep that shuffle pattern from then on until the user selects another pattern. A shuffle pattern needs to tell us which of the original channels should go in which new channel position. For example, if the pattern was [0, 2, 1] then the blue channel would stay in the same place, but the red and green channels would be swapped. Every ordering of the values 0, 1, and 2 in the list corresponds to a unique shuffle, and all shuffles can be represented by a pattern. We would need to decode the pattern to determine how to split and re-merge the frame’s channels.\nIf you have time and interest, here are steps you could implement for this.\n\nSet up a pattern accumulator variable before the while loop, and initialize it to be [0, 1, 2], which is the normal view of channels (each channel goes back into its normal slot).\nAdd the pattern as an additional input to the processImage function.\nRespond to the user in the while loop: if the user presses the space bar, randomly shuffle pattern.\nIn processImage, after any other changes to the input image are made, do these steps to reshuffle the color channels:\n\nCall the cv2.split function, and save the tuple in a variable called channels.\nAssign three variables, ch0, ch1, and ch2, to hold the channel from channels based on the index in the shuffle pattern variable: ch0 = channels[pattern[0]], etc.\nBuild a new tuple to hold these variables: newChannels = (ch0, ch1, ch2).\nReturn the result of cv2.merge called on newChannels."
  },
  {
    "objectID": "In-Class-Activities/ICA5-Conditionals.html",
    "href": "In-Class-Activities/ICA5-Conditionals.html",
    "title": "ICA: Booleans and Conditionals",
    "section": "",
    "text": "In this activity, we will practice with the Boolean data type, which allows us to reason about statements as true or false, and we will explore how to effectively use the if statement. An if statement is called conditionals because the actions taken are “conditional” on the value of the boolean expression in it. The conditional asks a question, or a series of questions, and it performs the set of actions associate with the first question that is true. The if statement syntax is more complex than the for loop:\n\nif &lt;test1&gt;:\n    &lt;statements to do (once) if test1 is true&gt;\nelif &lt;test2&gt;:\n    &lt;statements to do (once) if test1 is false and test2 is true&gt;\n...\nelse:\n    &lt;statements to do (once) if all tests are false&gt;\n\nNote: Complex statements in Python, like these, always have a first line that starts with the keyword that defines the statement (if) and the first line always ends with a colon (:).\nA key distinction to remember: if statements select indented code to be executed one time, they do not loop."
  },
  {
    "objectID": "In-Class-Activities/ICA5-Conditionals.html#boolean-expressions",
    "href": "In-Class-Activities/ICA5-Conditionals.html#boolean-expressions",
    "title": "ICA: Booleans and Conditionals",
    "section": "Boolean expressions",
    "text": "Boolean expressions\nWe can ask questions using functions that return true/false answers, or with a set of boolean comparison operators. These form boolean expressions that evaluate to True or False. The most common boolean operators are shown in the table below.\n\n\n\n\n\n\n\nA == B\nIs equal to takes two expressions, A and B, and evaluates to True if the value of A is equal to the value of B\n\n\nA != B\nIs not equal to takes two expressions, A and B, and evaluates to True if the value of A is not equal to the value of B\n\n\nA &lt;= B\nIs less than or equal to takes two expressions, A and B, and evaluates to True if the value of A is less than or equal to the value of B\n\n\nA &lt; B\nIs less than takes two expressions, A and B, and evaluates to True if the value of A is strictly less than the value of B\n\n\nA &gt;= B\nIs greater than or equal to takes two expressions, A and B, and evaluates to True if the value of A is greater than or equal to the value of B\n\n\nA &gt; B\nIs greater than takes two expressions, A and B, and evaluates to True if the value of A is greater than the value of B\n\n\nA in B\nIs in or Is an element of takes two expressions, A and B, and evaluates to True if the value of A occurs in the value of B * For strings this asks if A is a substring of B * For lists, this asks if A is an element of B\n\n\nA is B\nIs takes two expressions, A and B, and evaluates to True if both are references to the same exact data object. Some examples:\n\n25 is 25 is True (two identical ints are always the same)\n25 is 25.0 is False (int and float are always different)\n\"Frog\" is \"Frog\" is True (identical strs are the same)\n[5, 2] is [5, 2] is False (lists are complicated!)\n\n\n\n\nFor each boolean expression, below, examine it and see if you can describe what question is being asked, and what the answer should be. Type each of the statements or expressions below in the Python console, or make a script file, where you print the value of each expression. Where you are wrong about the outcome, discuss with a neighbor, and ask for help!\n\n# first we’ll assign three variables to values\nx = 25\ny = 30\ns = 'boolean'\nnums = [15, 20, 25, 30]\n# now we’ll ask questions about them\nprint(\"x &lt;=y is\", x &lt;= y)\nprint(\"y - 10 &gt; nums[1] is\", y - 10 &gt; nums[1])\nprint(\"x % 2 == 0 is\", x % 2 == 0, \"(is x even)\")\nprint(\"s &gt; 'bodwaddle' is\", s &gt; 'bodwaddle')\nprint(\"len(s) == 7 is\", len(s) == 7)\nprint(\"'e' in s is\", 'e' in s)\nprint(\"'c' in s is\", 'c' in s)\nprint(\"'boo' in s is\", 'boo' in s)\n\nx &lt;=y is True\ny - 10 &gt; nums[1] is False\nx % 2 == 0 is False (is x even)\ns &gt; 'bodwaddle' is True\nlen(s) == 7 is True\n'e' in s is True\n'c' in s is False\n'boo' in s is True\n\n\nTry this to hand in: Copy the script above into a Python file, and add to it with this part. Write the following boolean expressions, using print to output the result (along with explanatory text):\n\nAsk if the difference between x and y is less than 10\nAsk if \"apple\" is less than the variable s\nAsk if the variable x is in the list [35, 20, -15, -25, 30]\nAsk if the variable y is less than 0\nAsk if the variable y is greater than 100"
  },
  {
    "objectID": "In-Class-Activities/ICA5-Conditionals.html#boolean-logical-operators",
    "href": "In-Class-Activities/ICA5-Conditionals.html#boolean-logical-operators",
    "title": "ICA: Booleans and Conditionals",
    "section": "Boolean logical operators",
    "text": "Boolean logical operators\nWe can also put boolean expressions like the ones above together using the boolean logical operators: and, or, and not. The table below describes how these operators work.\n\n\n\n\n\n\n\nA and B\nEvaluates to True if both the value of A and the value of B are True, otherwise it evaluates to False\n\n\nA or B\nEvaluates to True if at least one of A or B evaluates to True, otherwise it evaluates to False\n\n\nnot A\nEvaluates to True if the value of A is False, and to False if the value of A is True\n\n\n\nAdd the lines below to the script you started for the previous section. These depend on the variables defined earlier. Which of the following are True, and which False? Can you explain why each one produces the value it does? Discuss with a teammate, and ask if you are unsure.\nRecall that the percent sign means to take the remainder of the first operand divided by the second operand. Also recall that the square bracket notation extracts single characters from a string based on position, where the first character is at position zero.\n\nprint(\"Are x and y multiples of 5?   \", (x % 5 == 0) and (y % 5 == 0))\nprint(\"Does s start with b, or is it more than 10 long?   \", (s[0] == 'b') or (len(s) &gt;= 10))\nprint(\"Does s not contain the character i?   \", 'i' not in s)\nprint(\"Is the 2nd character in s not an a?   \", not (s[1] == 'a'))\nprint(\"Is x in nums, and y not?   \", (x in nums) and not (y in nums))\nprint(\"Is x between 15 and 50, inclusive  \", (x &gt;= 15) and (x &lt;= 50))\n\nAre x and y multiples of 5?    True\nDoes s start with b, or is it more than 10 long?    True\nDoes s not contain the character i?    True\nIs the 2nd character in s not an a?    True\nIs x in nums, and y not?    False\nIs x between 15 and 50, inclusive   True\n\n\nTry this to hand in: Save your answer for this activity into a new Python file. Practice with boolean expressions that have boolean operators here:\n\nCheck if x is less than 0 or greater than 100\nCheck if either 'a' or 'e' are in s\nCheck if both x and y are less than 50\nCheck if nums has a length greater than 1, and (if so) if its zero-index element is less than its one-index element"
  },
  {
    "objectID": "In-Class-Activities/ICA5-Conditionals.html#user-selecting-images-to-show",
    "href": "In-Class-Activities/ICA5-Conditionals.html#user-selecting-images-to-show",
    "title": "ICA: Booleans and Conditionals",
    "section": "User selecting images to show",
    "text": "User selecting images to show\nTry this to hand in: By now you have probably had a typo in the name or path for an image you wanted to read in and display. OpenCV does not generate an error when it fails to read in an image, though it does print a warning, and the imread function returns the special Python value None. If a script has a hard-coded path to a file, we programmers can debug the program until we fix the path. But what if we want the user to select the image to read? Then we need to be more clever, and an if statement that checks what imread has returned is what we need. Do the following:\n\nMake a new script file, and at the top import cv2\nUse the input function to ask the user to enter the name of a file in SampleImages (save their result to a variable)\nUsing string operations, add SampleImages/ to the front of the user’s string (be sure to save it to a variable)\nRead in the image given by the string you have built, saving it to a variable img\nUse an if statement to check whether img is an image or not: if img is None:\nIf this is true, in the indented section, print a message that the program couldn’t find the file, and then call the special exit(0) function, which causes the program to end immediately\nIf the if test is false, then use imshow and waitKey to display the image the user entered."
  },
  {
    "objectID": "In-Class-Activities/ICA5-Conditionals.html#slideshow",
    "href": "In-Class-Activities/ICA5-Conditionals.html#slideshow",
    "title": "ICA: Booleans and Conditionals",
    "section": "Slideshow",
    "text": "Slideshow\nTry this to hand in: If we combine an if statement and a for loop, we can write a program that displays a slideshow of all the images in a folder, in an efficient way. We will create a program that displays all the images in SampleImages, one by one. The user should type a key in the image window to move from one picture to the next.\nWe will use a function, listdir, from the os module to get a list of all the files and folders that are a part of the SampleImages folder. The function returns a list of strings. We will then loop over that list, and for each string, check if it has a filename extension of jpg or png. If so, we will read the image and display it, and it not, we will just go on to the next item in the list. Below are the steps to complete, in more detail.\nMake a new Python file, and do the following:\n\nStart by importing cv2 and the os module\nUse os.listdir(\"SampleImages\") to get a list of the files and folders in SampleImages. Save the returned value into a variable called allFiles.\n\nBefore moving on, temporarily add a print statement, and print the value of allFiles. Examine it, make sense of what the list contains, and make sure it is doing the right thing (ask for help if it isn’t)\n\nNext, write a for loop that loops over the strings in allFiles: call the loop variable name.\n\nAgain, before moving on, temporarily add a print statement and print the loop variable. It should be a file or folder name from SampleImages\n\nInside the loop, add an if statement to check if the current name is an image file:\n\nUse this string slicing to extract the last three characters: name[-3:]\nUse or to perform two comparisons: Compare the sliced substring to jpg, and separately compare it to png\n\nIf the test of the if is True, then:\n\nAttach the folder name to the file name like this: \"SampleImages/\" + name\nRead in the image using the path string you created\nDisplay the image in the \"Slideshow\" window\nWait for the user to type a key\n\n\nMake sure that the if statement and all of its parts are indented inside the for loop.\nBe sure to test your program all the way through to make sure it works for every image\nDoes the structure of this program make sense to you? If so, great! If not, ask for help!"
  },
  {
    "objectID": "In-Class-Activities/ICA5-Conditionals.html#user-control-of-shape-on-image",
    "href": "In-Class-Activities/ICA5-Conditionals.html#user-control-of-shape-on-image",
    "title": "ICA: Booleans and Conditionals",
    "section": "User-control of shape on image",
    "text": "User-control of shape on image\nTry this to hand in: Next we will write a program that will allow the user to control the position of a shape on a background image. This will teach you how to use more information from the waitKey function, setting us up to work with video camera feeds very soon!\n\nMake a copy of your solution to the flying saucer program from the previous activity (if you didn’t finish that part, ask your teammates or work on it first).\nWe are going to change the x and y variables so that they are accumulator variables:\n\nDefine x to be 10 before the for loop\nDefine y to be 10 before the for loop\nRemove the two lines inside the for loop that set the values of x and y according to the value of i\nChange the waitKey call by removing the time input, and assign a variable to hold the value returned by waitKey\nPrint the value of that new variable so that you can see what waitKey returns\n\n\nEvery typical keyboard character, including control characters that are typically not printable, is represented inside the computer by a one-byte integer value as defined by the ASCII table (Python uses the much larger Unicode representation, but ASCII is a subset of that, and it’s all we will focus on). Open a copy of the ASCII table.. Focus on the Dec and Char columns in this table. The Dec column shows the decimal value from 0 to 127, and the Char column shows the character that corresponds to that integer value. The ones shown in all-caps are non-printable characters, like control characters. ASCII only uses half of the byte, a nibble, to represent typical characters, the values from 128 to 255 are special “extended” characters that we won’t need for now. Look for the values of alphabetic characters, upper and lower case, and the digits.\nOnce you have looked at the ASCII table, run the program you’ve created above, and try typing different keys: the value returned from waitKey is the integer that corresponds to the key you typed.\nWe can convert between a character and its integer counterpart using the ord and chr functions: ord takes a character and returns its integer value, chr takes an integer and returns its character value:\n\na1 = 67\na2 = 111\nn3 = 'o'\nn4 = 'L'\nprint(a1, chr(a1))\nprint(a2, chr(a2))\nprint(n3, ord(n3))\nprint(n4, ord(n4))\n\n67 C\n111 o\no 111\nL 76\n\n\n\nAdd a line after the waitKey and assign a variable c to hold the result of calling chr on the returned value from waitKey\nAdd an if statement to respond to the key the user pressed. We will respond to w-a-s-d. \n\nCreate an if-elif statement with four separate tests: comparing c to 'w', comparing it to 'a', comparing it to 's', and comparing it to 'd'\nIn the 'w' case, we will want the saucer to move up on the screen\nIn the 's' case, we will want the saucer to move down on the screen\nIn the 'a' case, we will want the saucer to move left on the screen\nIn the 'd' case, we will want the saucer to move right on the screen\nYou can leave out the else clause, or include one and print a message that the program didn’t understand what the user typed\nAs a first step, just put a print statement in each indented block of the if statement that prints which direction we want to move the saucer, given the key the user pressed\n\nFinally, in each of the four cases of our if statement, you will change either the x or the y variable, updating it to complete the accumulator patterns\n\nIn the up case, subtract a fixed amount from y\nIn the down case, add to y that fixed amount\nIn the left case, subtracts a fixed amount from x\nIn the right case, add the fixed amount to x\n\n\nNow your program should be complete."
  },
  {
    "objectID": "In-Class-Activities/ICA5-Conditionals.html#optional-challenge-bouncing-ball-animation",
    "href": "In-Class-Activities/ICA5-Conditionals.html#optional-challenge-bouncing-ball-animation",
    "title": "ICA: Booleans and Conditionals",
    "section": "Optional challenge: Bouncing-ball animation",
    "text": "Optional challenge: Bouncing-ball animation\nFor this optional challenge, you will create a program to draw a moving circle on the screen, and have it bounce off the edges of the screen. We do this by keeping accumulator variables for the x and y center position of the ball, and separately keeping accumulator variables, deltaX and deltaY, for the changes in position in x and y directions (how much the x value should change from one frame to the next, and similarly how much the y direction should change). When the ball reaches one of the edges of the background image, we will change deltaX or deltaY or both, so that the ball moves in a different direction.\nHint: For this to work, you will need to know the width and height of the background image. You can either look this up yourself by clicking on the image in PyCharm, and then hard-coding the values into your program. Or, you can access the size of the image (if it were in variable img) like this: (height, width, depth) = img.shape.\nStart, as before with the flying saucer program from last time: * As in the previous program, initialize x and y to be 10 before the for loop, and remove the lines inside the loop that compute x and y in terms of i. * Add a definition of deltaX to be 5 and deltaY to be 3 before the for loop as well * Change what is drawn each time from an ellipse to a circle to simplify matters * Increase the number of iterations of the for loop so that the program will run longer * Make sure that the waitKey call is passed a number for the millisecond delay, we want this program to run without user input * On the lines below the call to waitKey, add two lines to update x and y by adding deltaX and deltaY to them, respectively * Below that, add four if statements (not an if-elif, but separate statements) * In the first if statement, check to see if x plus the circle’s radius is &gt;= the image width * If it is, then set deltaX to be -5 * No else needed for this conditional * In the second if statement, check to see if x minus the circle’s radius is &lt;= 0 * If it is, then set deltaX to be 5 (this can only happen if the circle is moving left in the x direction, so deltaX must currently be -5). * No else needed for this conditional * Implement the other two if statements similarly for the y variable, using -3 and 3 as the values for deltaY\nA link to a video showing what this should look like will be available through Moodle."
  },
  {
    "objectID": "In-Class-Activities/ICA8-MoreStringsAndLists.html",
    "href": "In-Class-Activities/ICA8-MoreStringsAndLists.html",
    "title": "ICA: More Lists and Strings",
    "section": "",
    "text": "We’re going to take a closer look at lists and strings, particularly the methods that each data type has. Methods are like functions, but they belong to the data object, and they have access to the object’s information. Python provides many useful and powerful methods for manipulating strings and lists.\nKey idea for strings: Strings are immutable, you cannot modify an existing string, but you can construct a modified copy of the string. Many string methods build new, modified versions of the original string.\nKey idea for lists: Lists are mutable, you can modify an existing list. They can hold any kind of data, including numbers, strings, other lists and tuples, and even functions. Many list methods actually modify the list they apply to.\nThis activity will first ask you to try out some of the operations described in the reading, and then it will ask you to write a series of functions that operate on stings and lists.\nThe Github repository contains a starter code file, activ8.py. Add all your work to this file, as directed below and by the TODO comments in the file."
  },
  {
    "objectID": "In-Class-Activities/ICA8-MoreStringsAndLists.html#string-review-operators-selection-slicing-functions-loops",
    "href": "In-Class-Activities/ICA8-MoreStringsAndLists.html#string-review-operators-selection-slicing-functions-loops",
    "title": "ICA: More Lists and Strings",
    "section": "String review: operators, selection, slicing, functions, loops",
    "text": "String review: operators, selection, slicing, functions, loops\nEarlier in the term you learned a number of tools to manipulate strings: the + and * operators, the selection operator and slicing (square bracket operations), len function, and the accumulator pattern for strings. Here you will practice writing functions that operate on strings, using the tools you already know.\n\nString operators & functions\n\n\n\n\n\n\n\nExample\nMeaning\n\n\n\n\nlen('foo')\nReturns the number of characters in its argument\n\n\n'foo' + 'bar'\nConcatenates the two strings together\n\n\n'foo' * 3\nConcatenates the string with itself the number of times given\n\n\n'mom' in s\nChecks if first string occurs in second string\n\n\ns[3]\nReturns the character at the given position, zero-based\n\n\ns[3:5]\nReturns a substring starting at 3 and ending before 5\n\n\n\n\n\nLoops with strings\nfor loop over characters\n\nstring = \"my string\"\nfor ch in string:\n    print(ch)\n\nm\ny\n \ns\nt\nr\ni\nn\ng\n\n\nfor loop over indices\n\nstring = \"my string\"\nfor i in range(len(string)):\n     print(string[i])\n\nm\ny\n \ns\nt\nr\ni\nn\ng\n\n\nString accumulator pattern\n\ndef copyStr(string):\n    ansStr =  \"\"                 # initialize accumulator to empty string\n    for c in string:\n        ansStr = ansStr + c     # update ansStr\n    return ansStr\n\n\n\nPractice\nChoose one of these functions to complete, until you have worked through the whole activity, then return and use the remaining functions for extra practice.\nTry this to hand in: Practice using string operators, functions, and loops by completing one of the following two exercises. Do not use string methods here.\n\nCreate a Python function symbolPattern that takes 2 input parameters. The first, str, should be a string, the second, num, should be an integer. The function should build a new string where each character in the input string, str, is repeated num times. The new string should be returned. Use the accumulator pattern for strings as the base for this function. You will also need the string operators * and + to accomplish this task.\n\n\nprint(symbolPattern(\"*!*!\", 5))\nprint(symbolPattern(\"@$&\", 3))\nprint(symbolPattern(\"(*)\", 4))\n\n*****!!!!!*****!!!!!\n@@@$$$&&&\n((((****))))\n\n\n\nCreate a Python function firstVowel that takes a string as its input. It should use a loop to iterate over the string looking for vowels - ‘aeiou’. It should return the index of the first vowel in the string. The in operator is helpful here.\n\n\nprint(firstVowel(\"strings\"))\nprint(firstVowel(\"myth busters\"))\nprint(firstVowel(\"equal\"))\n\n3\n6\n0"
  },
  {
    "objectID": "In-Class-Activities/ICA8-MoreStringsAndLists.html#review-of-basic-list-operations",
    "href": "In-Class-Activities/ICA8-MoreStringsAndLists.html#review-of-basic-list-operations",
    "title": "ICA: More Lists and Strings",
    "section": "Review of basic list operations",
    "text": "Review of basic list operations\nEarlier in the term you learned a number of tools to manipulate lists: the + and * operators, the selection operator (square brackets, used to select a value from the list) and list slicing, and the accumulator pattern for lists. Here you will practice writing functions that operate on lists, using the tools you already know.\nRemember that strings and lists may be indexed from right to left with negative integers: -1 is the index of the rightmost element in a string or list.\n\n\n\n\n\n\n\nExample\nMeaning\n\n\n\n\nlen([25, 12, 19])\nReturns the number of characters in its argument\n\n\n['a', 'b'] + ['c', 'd', 'e']\nConcatenates the two strings together\n\n\n[5, 3] * 3\nConcatenates the string with itself the number of times given\n\n\n'mom' in lst\nChecks if first string occurs in second string\n\n\nlst[3]\nReturns the character at the given position, zero-based\n\n\nlst[3:5]\nReturns a substring starting at 3 and ending before 5\n\n\n\n\nLoops with lists\nfor loop over list elements\n\nlst = ['cat', 'fish', 'dog', 'pig']\nfor val in lst:\n    print(val)\n\ncat\nfish\ndog\npig\n\n\nfor loop over indices\n\nlst = ['cat', 'fish', 'dog', 'pig']\nfor i in range(len(lst)):\n     print(lst[i])\n\ncat\nfish\ndog\npig\n\n\nList accumulator pattern\n\ndef perfectSquares(n):\n    ansList =  []                  # initialize accumulator to empty list\n    for i in range(n):\n        ansList = ansList + [i*i]  # update ansList\n    return ansList\n\n\n\nPractice\nTry this to hand in: For these problems use only list functions (len), operators (+, *, [ ], in). Do not use list methods yet.\nChoose one of these functions to complete, until you have worked through the whole activity, then return and use the remaining functions for extra practice.\n\nCreate a Python function everyOther that takes a list as its input. It should build a new list that contains every other value from the original input list. The easiest solution is to use list slicing (look up list slicing to recall how it works), but you could also loop over the list or its indices and use an accumulator variable.\n\n\nprint(everyOther([1, 2, 3, 4, 5]))\nprint(everyOther(['d', 'e', 'f', 'g']))\nprint(everyOther([]))\n\n[1, 3, 5]\n['d', 'f']\n[]\n\n\n\nCreate a Python function sumPositive that takes a list of numbers as its input. Your function should use a for loop to iterate over the values in the list. If the number is positive then it should be added to an accumulator variable that holds the number that is the sum.\n\n\nprint(sumPositive([-1, -3, 4, 2, -6, 6]))\nprint(sumPositive([-10, -20, -30]))\nprint(sumPositive([1, 1, 1, 1, 1, 1]))\nprint(sumPositive([]))\n\n12\n0\n6\n0"
  },
  {
    "objectID": "In-Class-Activities/ICA8-MoreStringsAndLists.html#practice-2",
    "href": "In-Class-Activities/ICA8-MoreStringsAndLists.html#practice-2",
    "title": "ICA: More Lists and Strings",
    "section": "Practice",
    "text": "Practice\nTry this to hand in: Create a function changeStart that takes a value and a list as inputs. It should not build a new list. It should modify the input list by changing zeroth value to be the input value. Below is an example of what should happen:\n\ntList = ['a', 'b', 'c', 'd', 'e', 'f']\nchangeStart('X', tList)\nprint(tList)\n\n['X', 'b', 'c', 'd', 'e', 'f']"
  },
  {
    "objectID": "In-Class-Activities/ICA8-MoreStringsAndLists.html#string-methods",
    "href": "In-Class-Activities/ICA8-MoreStringsAndLists.html#string-methods",
    "title": "ICA: More Lists and Strings",
    "section": "String methods",
    "text": "String methods\nYour reading had a partial list of string methods. I recommend looking at the Python Documentation for String Methods for the complete list. I’ve broken down the list of (most) string methods by category below. Define the example strings below, and then try each of the string methods in the examples to see what it does.\n\ns1 = \"banana\"\ns2 = \"FROG\"\ns3 = \"Glimmer\"\ns4 = \"The Man From Mars\"\n\n\nCapitalization-related\nThe methods here are used both to check on the capitalization of a string, and to change its capitalization. None of these take any inputs, but they do return values.\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\n\n\nislower\nReturns True if all characters in its string are lowercase and False otherwise\n\n\nisupper\nReturns True if all characters in its string are uppercase, and False otherwise\n\n\nistitle\nReturns True if the string is a title with every first character capitalized and no others, and it returns False otherwise\n\n\ncapitalize\nReturns a copy of the string with its first character capitalized and the rest lowercase\n\n\nlower\nReturns a copy of the string with all characters lowercased\n\n\nupper\nReturns a copy of the string with all characters uppercased\n\n\ntitle\nReturns a copy of the string with the first character of each word capitalized and all the rests lowercased\n\n\nswapcase\nReturns a copy of the string with the case of each letter swapped: lower to upper and upper to lower\n\n\n\nHere are some examples that show how to call these methods, assuming the four strings defined above.\n\nprint(\"line 1:\", s1.islower(), s3.islower())\nprint(\"line 2:\", s4.isupper(), s2.isupper())\nprint(\"line 3:\", s1.istitle(), s4.istitle())\nnews1 = s1.capitalize()\nnews2 = s2.capitalize()\nprint(\"line 6:\", news1, news2)\ns3L = s3.lower()\ns4L = s4.lower()\nprint(\"line 9:\", s3L, s4L)\ns4Alt = s4L.title()\ns1Alt = s1.title()\nprint(\"line 12:\", s4Alt, s1Alt)\ns4Swap = s4.swapcase()\ns2Swap = s2.swapcase()\nprint(\"line 15:\", s4Swap, s2Swap)\n\nline 1: True False\nline 2: False True\nline 3: False True\nline 6: Banana Frog\nline 9: glimmer the man from mars\nline 12: The Man From Mars Banana\nline 15: tHE mAN fROM mARS frog\n\n\n\n\nAdjusting string spacing\nThese methods are used to add or remove spaces (or other characters) from the front or end of the string to change the spacing around the main contents of the string.\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\ncenter\nTakes in a new width and an optional fill character, and it returns a new string where the original string is centered in the new one. By default extra characters are filled with spaces, or with the l fill character if given. If width is shorter than the string, then the original string is returned.\n\n\nljust\nSimilar to center, but it adds spaces/fill chars to the right end\n\n\nrjust\nSimilar to center, but it adds spaces/fill chars to the left end\n\n\nstrip\nTakes in an optional string. If given no input, it removes whitespace from front and end of string. If input string is provided, then it removes those characters, if they occur, from front and end of string.\n\n\nlstrip\nSimilar to strip, but only removes from front of string\n\n\nrstrip\nSimilar to strip, but only removes from end of string\n\n\n\nHere are some examples that show how to call these methods, assuming the four strings defined above.\n\nprint(\"*\" + s1.center(20) + \"*\")\nprint(s3.center(5, \"X\"))\nprint(s2.ljust(10, '-'))\nprint(s1.rjust(30))\ns1Stripped = s1.strip(\"ab\")\nprint(s1Stripped)\ns5=\"   foobar   \"\ns5S = s5.strip()\ns5LS = s5.lstrip()\ns5RS = s5.rstrip()\nprint(\"*\" + s5S + \"*\" + s5LS + \"*\" + s5RS + \"*\")\n\n*       banana       *\nGlimmer\nFROG------\n                        banana\nnan\n*foobar*foobar   *   foobar*\n\n\n\n\nCheck string contents\nThe following set of methods ask about the contents of the string, and are useful for determining whether a string is in a useful format or not. None of these methods take in any inputs.\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nisalpha\nReturns True if all the characters in its string are alphabetic\n\n\nisalnum\nReturns True if all the characters in its string are either alphabetic or numerical\n\n\nisdigit\nReturns True if all the characters in its string are digits\n\n\nisspace\nReturns True if all the characters in its string are “whitespace:” space, tab, or newline\n\n\n\nHere are some examples that show how to call these methods, assuming the four strings defined above.\n\nprint(s2.isalpha())\nprint(\"Foo23\".isalnum())\nprint(s4.isalpha())\nprint(\"12092\".isdigit())\nprint(\"-35\".isdigit())\nprint(s1.isspace())\n\nTrue\nTrue\nFalse\nTrue\nFalse\nFalse\n\n\n\n\nSearching and replacing in strings\nThese methods look for certain substrings or characters in a string, and sometimes replace them with new strings. Remember that they always generate a new string to do a replacement, they do not ever change the input string, because strings are immutable.\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nfind\nTakes in a string, and returns the index of the leftmost occurrence of that string inside its string or -1 if it isn’t there\n\n\nrfind\nSimilar to find, but returns the index of the rightmost occurrence\n\n\nendswith\nBasic version takes in a string and return True if its string ends with the input string. For options, see documentation.\n\n\nstartswith\nBasic version takes in a string and return True if its string starts with the input string. For options, see documentation.\n\n\nindex\nAnother name for find for compatibility with list methods\n\n\nrindex\nAnother name for rfind for compatibility with list methods\n\n\ncount\nTakes in a string, and returns the number of occurrences of that string in its string (no overlaps)\n\n\nreplace\nTakes in two strings, and it builds a new string where every occurrence in its string of the first input has been replaced by the second input\n\n\n\nHere are some examples that show how to call these methods, assuming the four strings defined above.\n\nprint(s1.find(\"n\"))\nprint(s1.rfind(\"n\"))\nprint(s4.find(\"Ma\"))\nprint(s2.find(\"GG\"))\nprint(s3.startswith(\"Gl\"))\nprint(s3.endswith(\"ar\"))\nprint(s1.count(\"an\"))\nprint(s1.replace(\"a\", \"uba\"))\n\n2\n4\n4\n-1\nTrue\nFalse\n2\nbubanubanuba\n\n\n\n\nBreaking strings into pieces\nOften when we have a piece of text, we want to break it up into words or lines. Or if we have other structured data like CSV files, we might want to split it by commas or tabs. These methods let you separate a string into parts.\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nsplit\nTakes an optional input, a character. Returns a list of strings, created by splitting up its string. By default it splits on whitespace, but with an input it splits on that character.\n\n\nsplitlines\nSimilar to split but it only splits on newline, returning a list of strings for each line\n\n\n\nHere are some examples that show how to call these methods, assuming the four strings defined above.\n\nprint(\"line 1:\", s4.split())\ns5 = \"red,green,blue\"\nprint(\"line 3:\", s5.split(\",\"))\ntext = \"\"\"ABC\nDEF\nGHIJK\"\"\"\nprint(\"line 7:\", text.splitlines())\n\nline 1: ['The', 'Man', 'From', 'Mars']\nline 3: ['red', 'green', 'blue']\nline 7: ['ABC', 'DEF', 'GHIJK']\n\n\n\n\nPractice\nTry this to hand in:\nChoose one of these functions to complete, until you have worked through the whole activity, then return and use the remaining functions for extra practice.\nThe first two functions here are very simple and can be done with just one or two applications of string methods. The third example is a bit more complex.\n\nDefine a function shout that takes one input, a string. The function should return a new string that is the same as the input string, but with all letters in uppercase. See examples below.\n\n\nnewS = shout(\"What are you doing?\")\nprint(newS)\nprint(shout(\"i saw a frog in my bathtub\"))\n\nWHAT ARE YOU DOING?\nI SAW A FROG IN MY BATHTUB\n\n\n\nDefine a function nameSubst that takes two inputs. The first input is a string representing a name, and the second input is a piece of text (also a string). The function should look for an occurrence of the special string \"ZZZ\" in the text, and it should build a new string that has substituted the input name for \"ZZZ\" in the text. It should return this new string.\n\n\nsallie = nameSubst(\"Sallie\", \"My friend, ZZZ, won an award.\")\nprint(sallie)\nprint(nameSubst(\"Fred\", \"Jamie and ZZZ flew over the trees.\"))\n\nMy friend, Sallie, won an award.\nJamie and Fred flew over the trees.\n\n\n\n(Optional challenge question) Create a function countWords that takes two strings as input. One string is a word, the other is longer piece of text. It should break up the text into words (using the split method), and then loop over the list of words. Use an accumulator variable to count how many times the first input string is a whole word in the text (not a part of a larger word, for example, if you are counting the occurrences of \"ban\" then don’t count it when it is in \"banana\"). Hint: don’t use in to look for the word, use ==.\n\nFor an extra challenge, make the function ignore capitalization.\nFor even more of a challenge, remove punctuation from the start and end of each word before comparing it to the input.\n\n\n\ncount1 = countWords(\"ban\", \"I ban bananas, but I don't ban peaches\")\nprint(count1)\nprint(countWords(\"aba\", \"abaa bba ab aba bbb aba baba aba ba ba ab a aaabbaa\"))\n\n2\n3"
  },
  {
    "objectID": "In-Class-Activities/ICA8-MoreStringsAndLists.html#list-methods",
    "href": "In-Class-Activities/ICA8-MoreStringsAndLists.html#list-methods",
    "title": "ICA: More Lists and Strings",
    "section": "List Methods",
    "text": "List Methods\nLists, like strings, have useful methods for manipulating them. The Python documentation for lists has a nice short summary of list operations.\nNote: Because lists are mutable, changeable, most list methods, unlike string methods, modify the list, rather than returning a new list.\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nappend\nTakes an item as input, adds it to the end of the list (modifying the list!)\n\n\nextend\nTakes a list (or similar) as input, and adds the list contents to the end of the original list\n\n\ninsert\nTakes an index and a value, and inserts the value into the list at the given index, moving the old values one position down, starting at the given index through the end of the list.\n\n\nremove\nTakes a value and removes the first occurrence of that value from the list, raising an error if no such value exists in the list.\n\n\npop\nTakes in an optional position, and removes the value at that position from the list. If no position is specified, it removes the last values from the list.\n\n\nclear\nRemoves all items from the list.\n\n\nindex\nTakes in a value, and optionally a starting position and an ending position. The starting and ending positions define the range of the list to be searched: if not specified, then the whole list is searched. It returns the index of the leftmost occurrence of the value in the search range. If no occurrence is found, then an error is raised.\n\n\ncount\nTakes in a value, and returns the number of times that value appears in the list (as a full element, not inside another list element).\n\n\nsort\nSorts the data in the list, rearranging the list elements. By default, data is sorted in increasing order, but optional arguments allow us to change the search criteria and ordering.\n\n\nreverse\nReverse the elements in the list, modifying the list.\n\n\ncopy\nReturns a new list that contains the same data items as the original.\n\n\n\nTry out the examples below in the Python console, to see how these methods work. Look at the list whose method has been called after each call to see how it has changed.\n\nlist1 = [5, 6, 7]\nlist2 = [4, 3, 2, 1]\nlist1.append(8)\nprint(\"line 4:\", list1, list2)\nlist2.extend([0, -1])\nprint(\"line 6:\", list1, list2)\n# list1.extend(5)   # this should generate an error, why?\nlist1.insert(0, 4.5)\nprint(\"line 9:\", list1, list2)\nlist2.insert(2, 3.5)\nprint(\"line 11:\", list1, list2)\nlist1.remove(7)\nprint(\"line 13:\", list1, list2)\nlist2.pop(1)\nprint(\"line 15:\", list1, list2)\nprint(\"line 16:\", list1.index(8), list2.index(2))\nprint(\"line 17:\", list1.count(5), list2.count(0))\nlist1.reverse()\nprint(\"line 19:\", list1, list2)\nlist2.sort()\nprint(\"line 21:\", list1, list2)\nlist3 = list2.copy()\nprint(\"line 23:\", list2, list3, list2 == list3, list2 is list3)\n\nline 4: [5, 6, 7, 8] [4, 3, 2, 1]\nline 6: [5, 6, 7, 8] [4, 3, 2, 1, 0, -1]\nline 9: [4.5, 5, 6, 7, 8] [4, 3, 2, 1, 0, -1]\nline 11: [4.5, 5, 6, 7, 8] [4, 3, 3.5, 2, 1, 0, -1]\nline 13: [4.5, 5, 6, 8] [4, 3, 3.5, 2, 1, 0, -1]\nline 15: [4.5, 5, 6, 8] [4, 3.5, 2, 1, 0, -1]\nline 16: 3 2\nline 17: 1 1\nline 19: [8, 6, 5, 4.5] [4, 3.5, 2, 1, 0, -1]\nline 21: [8, 6, 5, 4.5] [-1, 0, 1, 2, 3.5, 4]\nline 23: [-1, 0, 1, 2, 3.5, 4] [-1, 0, 1, 2, 3.5, 4] True False\n\n\nCan you answer these questions: * What is the difference between append and extend? * What is the difference between remove and pop?"
  },
  {
    "objectID": "In-Class-Activities/ICA8-MoreStringsAndLists.html#practice-4",
    "href": "In-Class-Activities/ICA8-MoreStringsAndLists.html#practice-4",
    "title": "ICA: More Lists and Strings",
    "section": "Practice",
    "text": "Practice\nTry this to hand in: Create a function onBeyond that takes in a number, and a list of numbers in sorted order. The input number must be larger than the last number in the list. The function should modify the list to add to the end of the list all the integers between the last number in the list and the input number. See the examples below for help:\nHint: The last number in the list might not be an integer. The first number to be added to the list, then, should be calculated using this more general form, where \\(x\\) is the last number in the list: \\(\\lfloor x + 1 \\rfloor\\).\nAlso, if you are clever, the function can be defined with 2-4 lines of code in total.\n\nnl1 = [1, 3, 5, 6, 9]\nnl2 = [-2.5, 0, 1.372, 4.7]\nnl3 = [15.2]\nprint(\"Before:\")\nprint(nl1)\nprint(nl2)\nprint(nl3) \nonBeyond(15, nl1)\nonBeyond(7, nl2)\nonBeyond(20, nl3)\nprint(\"After:\")\nprint(nl1)\nprint(nl2)\nprint(nl3)\n\nBefore:\n[1, 3, 5, 6, 9]\n[-2.5, 0, 1.372, 4.7]\n[15.2]\nAfter:\n[1, 3, 5, 6, 9, 10, 11, 12, 13, 14, 15]\n[-2.5, 0, 1.372, 4.7, 5, 6, 7]\n[15.2, 16, 17, 18, 19, 20]"
  },
  {
    "objectID": "In-Class-Activities/ICA8-MoreStringsAndLists.html#practice-5",
    "href": "In-Class-Activities/ICA8-MoreStringsAndLists.html#practice-5",
    "title": "ICA: More Lists and Strings",
    "section": "Practice",
    "text": "Practice\nTry this to hand in:\nChoose one of these to complete, until you have worked through the whole activity, then return and use the remaining ones for extra practice.\n\nCreate a function timesN that takes a number and a list of numbers. Use a list comprehension to build a new list that has multiplied each of the original numbers in the list by the input number. Return the new list.\nCreate a function removeAll that takes in an item and a list, and it builds a new list with all occurrences of the item removed from the list. Use a list comprehension, and use the if extension to keep only those values not equal to the item."
  },
  {
    "objectID": "In-Class-Activities/ICA2-PythonDataTypes.html",
    "href": "In-Class-Activities/ICA2-PythonDataTypes.html",
    "title": "ICA: Basic Python Data Types",
    "section": "",
    "text": "Overview\nThis activity will introduce one of the true “core concepts” of computer science: the idea of data types. Every piece of data in a computer is stored as a collection of binary bits: ones and zeros. In order for the computer to manipulate data correctly, it is crucial that it keep track of what type the data is, so that it can correctly interpret the binary bits. When programming, it is also essential to pay close attention to data types.\nIn this activity, you will look at several simple built-in types of data in Python. First you will learn about numbers, which may be separated into integers and floating-point (real) numbers. Then you will explore strings, which allow us to represent text data. And finally you will learn about lists, which store collections of other data.\nTo hand in: You will use Github Assignment to set up this assignment, and to push your code to save it to the cloud, to hand it in.\n\n\nNumbers\nPython has two main kinds of numbers: integers, and real, or floating point, numbers (There are other kinds of numbers, as well, but we probably won’t use any of them). The official names for these types are int and float. Table 1 shows basic numeric operations and functions. Many more common mathematical operations are in the math module, which you can add in when you need it.\n\n\n\nTable 1: Basic built-in arithmetic operations, and functions on numbers\n\n\n\n\n\n\n\n\n\nExample\nMeaning\n\n\n\n\n3 + 12\nAdds two numbers, returning the result\n\n\n45 - 19\nSubtracts second from first, returning the result\n\n\n5 * 100\nMultiplies two numbers, returning the result\n\n\n55.0 / 2\nDivides first by the second, returning the result as a float\n\n\n55 // 2\nDivides first by the second, returning the quotient portion as an int\n\n\n30 % 4\nComputes the remainder of first divided by second\n\n\n2 ** 3\nRaises first to the power of the second\n\n\nmax(1, 5, 3)\nA function that returns the largest of values passed to it\n\n\nmin(1, 5, 3)\nA function that returns the smallest of values passed to it\n\n\nabs(-3)\nA function that returns the absolute value of its argument\n\n\nround(3.2)\nA function that rounds its argument\n\n\nint(3.2)\nConverts its argument to an integer\n\n\nfloat(2)\nConverts its argument to a floating-point number\n\n\n\n\n\n\nIntegers and floats are treated as different, though related, kinds of data. This is why we have explicit operators to convert from one type to the other.\nIn general, arithmetic operators follow this rule: If both operands are integers, then the result is an integer. If at least one operand is a floating-point number, then the result is a float, too. The single-slash, decimal division operator is an exception: it always returns a float.\nThere are three division-related operators: decimal division (/), quotient division (//), and remainder (`%). Decimal division gives the normal calculator result for dividing two numbers. Quotient division returns only the integer part, the quotient of the division. It cuts off any part after the decimal point (another way of thinking about it is that it takes the floor, it rounds down to the nearest integer less than the value). The remainder operator gives the remainder of the division of its two operands.\nExamine the code below, which runs each of the examples above and prints their results, along with explanatory text. Can you correctly predict each result?\n\nprint(\"3 + 12 =\", 3 + 12)\nprint(\"45 - 19 =\", 45 - 19)\nprint(\"5 * 100 =\", 5 * 100)\nprint(\"55.0 / 2 =\", 55.0 / 2)\nprint(\"55 // 2 =\", 55 // 2)\nprint(\"30 % 4 =\", 30 % 4)\nprint(\"2 ** 3 =\", 2 ** 3)\nprint(\"max(1, 5, 3) =\", max(1, 5, 3))\nprint(\"min(1, 5, 3) =\", min(1, 5, 3))\nprint(\"abs(-3) =\", abs(-3))\nprint(\"round(3.7) =\", round(3.7))\nprint(\"int(3.7) =\", int(3.7))\nprint(\"float(2) =\", float(2))\n\n3 + 12 = 15\n45 - 19 = 26\n5 * 100 = 500\n55.0 / 2 = 27.5\n55 // 2 = 27\n30 % 4 = 2\n2 ** 3 = 8\nmax(1, 5, 3) = 5\nmin(1, 5, 3) = 1\nabs(-3) = 3\nround(3.7) = 4\nint(3.7) = 3\nfloat(2) = 2.0\n\n\nCreate a new Python file in your project for this activity, and try copying this code and running it. Do you get the same results? Experiment with changing the values, especially changing int to float and vice versa, and examining the results. Ask questions if you aren’t sure what is happening here, or why you are getting a particular result.\nTry this to hand in: Suppose you have a banana that is 15.5 cm long. If you had 5,100 such bananas, how many meters would they cover, laid end to end? Create a new Python file and put your answer in the file. Start with a Python statement to define variables bananaLength and a variable numBananas, and then create a statement that computes how long they would be, in meters. Make sure to print the final result, including units and explanatory text.\n\n\nStrings\nStrings are collections of characters, and characters are keyboard symbols; each character represents a single keyboard key. Strings allow us to incorporate text into our programs, making them more readable. Programs can also perform text processing, though we will get to that later on.\nStrings and characters are written the same in Python. A character is just a string of length 1. Strings are written with quotes before and after them. You can either use double-quotes (\") or single-quotes ('), as the examples below show. You can also make triple-quoted strings that use three single-quotes or three double-quotes. Triple-quoted strings are the only ones that can be written over multiple lines, and we use them for program documentation as well.\nBelow is a script that demonstrates various ways of writing strings, and printing their values.\n\nprint('Hi there')\nprint(\"Hi there\")\nprint(\"I contain an apostrophe, don't I?\")\nprint('I was told, \"Double quotes go inside single quotes!\"')\ns1 = \"cat\"\ns2 = \"dog\"\ns3 = 'hi mom'\nlongStr = \"\"\"As I was going to St. Ives,\nI met a man with seven wives.\nEach wife had seven sacks,\nEach sack had seven cats,\nEach cat had seven kits.\nKits, cats, sacks, and wives:\nHow many were going to St. Ives?\"\"\"\nprint(s1, s2, s3)\nprint(longStr)\n\nHi there\nHi there\nI contain an apostrophe, don't I?\nI was told, \"Double quotes go inside single quotes!\"\ncat dog hi mom\nAs I was going to St. Ives,\nI met a man with seven wives.\nEach wife had seven sacks,\nEach sack had seven cats,\nEach cat had seven kits.\nKits, cats, sacks, and wives:\nHow many were going to St. Ives?\n\n\nCopy the script above to a test file in PyCharm, and experiment with it. What happens if you don’t match quotation marks, or you put a line break in a string that isn’t triple-quoted?\nThe table below lists basic string operations. With these we can pull strings apart and put them together again, check their size, and ask about substrings within the larger string. When we concatenate two or more strings, we put them together as one big string. We slice a string when we extract a particular substring, based on its indices.\nStrings are indexed starting with 0 at the left end, and increasing as you go right. We can also use negative numbers to index characters from the right end going left (see Table 2 to see how to index the example string \"AB CD\")\n\n\n\nTable 2: Indices to reference individual characters in the string \"AB CD!\"\n\n\n\n\n\n\nA\nB\n\nC\nD\n!\n\n\n\n\npositive indices:\n0\n1\n2\n3\n4\n5\n\n\nnegative indices:\n-6\n-5\n-4\n-3\n-2\n-1\n\n\n\n\n\n\nAdd the script below to the script from earlier. You need the variable definitions for this to work.\n\n1print(len('foo'), len(s1), len(longStr))\n2print(s1 + \"fish\", 'a' + 'b' + 'c')\n3print('X' * 10, 3 * s2)\n4print('kits' in longStr, 'mom' in s3, 'Hi' in s3)\n5print(s1[0], s3[3], s2[-1])\n6print(s1[1:3], s2[0:2], s3[3:5], longStr[36:39])\n\n\n1\n\nlen returns the number of characters in its argument\n\n2\n\n+ concatenates strings together\n\n3\n\n* concatenates a string with itself N times (N * s or s * N)\n\n4\n\nin checks if the first string occurs in the second string\n\n5\n\nAccessing with [n] returns the character at position n\n\n6\n\nSlicing with [s:e:j] returns the substring fromsup toe, skipping byj`\n\n\n\n\n3 3 198\ncatfish abc\nXXXXXXXXXX dogdogdog\nTrue True False\nc m g\nat do mo man\n\n\nExperiment with this script, changing which strings, positions, substrings are included. Ask questions if any result or operation does not make sense to you.\nTry this to hand in: Make a new Python file, and write a program as described below to automate the writing of a thank-you note.\nFirst, define a variable with the name of the person who has given you a gift.\n\nkindPerson = 'Aunt Judi'\n\nBuild a second variable that holds your thank-you note, using the + operator so that instead of including a specific gift-giver’s name, you insert the variable kindPerson. Print the final string, which should look like:\nDear Aunt Judi,\nThank you for the graduation present. I can’t wait to use it. I\nhope you are enjoying your summer. You’re the best, Aunt Judi!\nLove, Mittens\n\n\nLists\nA list is a linear collection of data. That means that it is a container that holds multiple pieces of data, lining them up in some kind of order. In Python, lists can hold any type of data, including other lists, with varying data types even within a single list.\nYou write a list by surrounding the data with square brackets. Both lists and strings share some of the same operations; see the examples below.\n\n1lst1 = [5, 1, 16, 2]\nlst2 = ['Nauru', 'Kiribati', 'Vanuatu']\n2print(lst1, lst2)\n3print(len(lst1), len(lst2))\n4lst3 = lst1 + lst2\nlst4 = ['a', 'b'] * 5\n5print('Kiribati' in lst2, \"Fiji\" in lst2)\nprint(6 in lst1, 5 in lst1, 'K' in lst2)\n6print(lst1[0], lst2[2], lst4[-2])\n7print(lst1[2:3], lst2[1:], lst1[:2])\nprint(lst4[0:10:2], lst4[::-1])\n\n\n1\n\nDefining lists of numbers and strings\n\n2\n\nPrinting lists\n\n3\n\nlen returns the number of elements in a lists\n\n4\n\nDefining new lists with concatenation\n\n5\n\nChecking if an element is in a list\n\n6\n\nAccessing with [n] returns the element at position n\n\n7\n\nSlicing with [s:e:j] returns a sublist of elements from s to e skipping by j\n\n\n\n\n[5, 1, 16, 2] ['Nauru', 'Kiribati', 'Vanuatu']\n4 3\nTrue False\nFalse True False\n5 Vanuatu a\n[16] ['Kiribati', 'Vanuatu'] [5, 1]\n['a', 'a', 'a', 'a', 'a'] ['b', 'a', 'b', 'a', 'b', 'a', 'b', 'a', 'b', 'a']\n\n\nA note about slicing: Slicing is an incredibly versatile operation. We can use it to select a sequential sublist, or to pull out every 3rd element, or other similar patterns. If we want to start or end at an end of the string, we can leave out the value on that side of the colon (:).\nCopy this script into a new file in your activity project. Look closely at each operation, and its result. Experiment with changing the numbers in the slicing, adding numbers where they are missing, or removing them. Ask questions if any operation or result is confusing to you.\nTry this to hand in: Create a script that starts by defining a variable to hold a list of 6 numbers. From the list, pull out three values, at positions 0, 2, and 4 (use the square bracket access operator). Using arithmetic operators, add the three values together, and assign the result to the variable evenSum. This can be done in one line of Python, it you are careful. In another variable, oddSum, calculate the sum of the numbers at positions 1, 3, and 5. Print these two results. Make sure your script works correctly and prints the correct sums of odd and even values, even if you change the values in the original list!\n\n\nOptional Challenge Question for Those Who Get This Far\nConsider the problem of making change: figuring out how many bills and coins to give someone to make a specific amount of money. This example asks you to make a script to solve this problem. You might start by discussing this question with a neighbor, and developing together your ideas for how to solve the problem, in English or pseudocode. The key idea to making change is to take the quotient and remainder of an amount by the next monetary unit.\nConsider an example. If we start with $7.32, for simplicity (and to avoid floating-point numbers) we will represent it as 732 cents. If we take the quotient of 732 by 100 (for one dollar bills), then we get 7, and the remainder of 732 divided by 100 is 32. That means 32 cents is the part left over after paying 7 dollar bills. Then using the left over 32, repeat for the next coin: quarters. Divide 32 by 25, and get 1, and the remainder is 7 cents. Continue in this manner.\nNow, see if you can write a Python script, a series of expressions or statements in Python, that do this calculation and print out the results. Open a new Python file, Define a variable, money, that contains a money amount in cents (like 732 for $7.32, for example).\nThen, create a series of Python statements that calculate and print how to give change for the money value, in dollars, quarters, dimes, nickels, and pennies. The best solution will use integer division and the remainder operation.\nBelow is an example of what might print when this script is run:\nMaking change for 732 cents:\nDollars: 7\nQuarters: 1\nDimes: 0\nNickels: 1\nPennies: 2\nOnce you get the script working for 732, change the value of money and test your script on other values to be sure it works more generally.\n\n\nWhat to hand in\nYou should have multiple Python files for this activity. You might have files containing the example scripts for each data type, along with your experiments. At the very least, you must have:\n\nA file containing your solution for the banana problem\nA file containing the thank you note script\nA file containing the odd-even list addition problem\n(Optional: the script for the change-making challenge question\n\nUse commit and push to copy your code to Github to submit this work."
  },
  {
    "objectID": "In-Class-Activities/ICA7-FunctionPractice.html",
    "href": "In-Class-Activities/ICA7-FunctionPractice.html",
    "title": "ICA: Function Practice",
    "section": "",
    "text": "Overview\nThis activity follows on the earlier functions activity, giving you more practice with defining functions, including some with nested for loops and accumulator variables. It will also ask you to practice with writing functions that are called by other functions.\nSave all the functions you write into a single file for this activity: this will be the pattern going forward. Your file should have all necessary import statements at the top, followed by the function definitions, with explanatory comments included. At the bottom of the file, you should include the main script, using the if __name__ == \"__main__\": conditional, with all your script elements indented as a part of the conditional.\n\n\nFunctions with nested loops\nAny Python construct can be put inside any other Python construct. You can put loops inside of functions, and loops inside of loops. Nested loops are a very useful pattern.\nCopy the function below into your file.\n\ndef printPairs(n, m):\n    \"\"\"Prints pairs of numbers, the first number varies from 0 to n-1\n    and each first number is paired with each second number. The second\n    number varies from 0 to m-1\"\"\"\n    for i in range(n):\n        for j in range(m):\n            print( \"(\", i, j, \")\" )\n\nAdd calls to printPairs to your file. Try small values like 3 and 5, and figure out what happens.\nThe outer loop repeats n times, the inner loop repeats m times for each pass of the outer loop.\nThus, the number of lines printed is \\(n\\cdot m\\).\nTry this to hand in: Write a function called drawGrid, which takes in an image and two numbers. The function will draw a grid of squares on the input image, starting at (20, 20). The first number parameter, size is an integer that indicates how many squares to draw in each row and column, and the second number parameter is the width in pixels of each square. Make a gap of 20 pixels between each square.\n\nYou will need two nested for loops for this function: an outer loop that iterates over the rows (i goes from 0 to size - 1, and an inner loop that iterates over each columns (j goes from 0 to size - 1)\nBefore starting to code, work through an example or two by hand with a teammate, until you can figure out how to calculate the upper-left and lower-right corners for each square from i, j, the square size, and the 20-pixel gaps. Figure 1 gives the start of one example, where the square size is 40 pixels.\n\n\n\n\n\n\n\nFigure 1: Example for drawGrid, for square size of 40\n\n\n\n\nInside each square in Figure 1 is written the loop variable values for that square\nNotice that, no matter what the upper-left corner (x, y) coordinates are, the lower-right will always just be (x + 40, y + 40)\nThe upper-left x values for the first row would be: 20, 80, 140, 200, 260, …\nThe upper-left y values stay the same for the first row, but increase for each row: 20, 80, 140, 200, 260, …\nWrite out a formula to compute the upper-left x in terms of i and the same for upper-left y in terms of j\nWrite the two for loops as described above, one indented inside the other.\nInside the outer loop, compute the upper-left y value according to your formula\nInside the inner loop, computer the upper-left x value according to your formula\nCall cv2.rectangle to draw the square (you can pick the color)\n\nOther than the color of the rectangles, your results should match the two examples in Figure 2\n\n\n\n\n\n\n\n\ndrawGrid(img, 6, 50) results\n\n\n\n\n\n\n\ndrawGrid(img, 10, 10) results\n\n\n\n\n\n\nFigure 2: Results from two example calls to drawGrid: (a) created a 6x6 grid with squares 50 pixels wide, and (b) created a 10x10 grid with squares 10 pixels wide.\n\n\n\n\n\nAccumulator variables\nWe have already been using the accumulator pattern, so here we will look at it in the context of a function, and we will focus on practicing debugging skills.\nBelow is an example of a function that includes a for loop and an accumulator variable. It has three bugs in it. Some might be syntax errors, or will cause a runtime error, some may be logical errors.\nThis function is supposed to add up the numbers in a list, and return the sum at the end.\n\ndef sumListNums(dataList):\n    total = 0\n    for val in len(dataList):\n        if type(val) == int or type(val) = float:\n            total = total + val\n        return total\n\nTry this to hand in:\n\nWrite 4 sample calls to sumListNums and try running them, include lists that are all numbers and mixed lists\nWhat happens if you pass an empty list into the function?\nUse one of the tracing methods you learned last time to trace this function and find the three bugs\nMark each buggy line, and correct the bug\nAsk for help if you get stuck!\n\n\n\nFunctions that call other functions\nWe build programs in Python out of collections of functions. One function calls another function to do part of the work.\nBecause writing programs accurately is difficult and time-consuming, one program design principle is to avoid writing the same code over and over. If you write the exact same statements in more than one place, then you have to debug each place separately. It is often worth your time to package those statements as a function, so that you can debug it once, and then only have to call the function for every use. Because functions have meaningful, descriptive names, calling functions can also improve the readability of your code, by substituting a single descriptive name for lines of code.\nTry this to hand in: You have been provided with a starter program in stickMonsters.py. This program has 5 functions, plus a main script. We have provided three of functions for you: drawStickFigure, drawMonster, and computeHeadOffsets. You will implement the other two: drawOneHead and drawHeads. Below we have provided the drawStickFigure function, as a core element of the code.\n\ndef drawStickFigure(img, startPos, color):\n    \"\"\"Takes in the image to draw on, a reference point on the stick figure (at the base of the neck/shoulders),\n    and a color, and it draws the stick figure at that position.\"\"\"\n    (sx, sy) = startPos\n1    drawHead(img, (sx, sy - 50), color)\n2    cv2.line(img, (sx, sy - 10), (sx, sy), color, 2)\n3    cv2.line(img, (sx, sy), (sx, sy + 100), color, 2)\n4    cv2.line(img, (sx, sy), (sx - 50, sy + 50), color, 2)\n5    cv2.line(img, (sx, sy), (sx + 50, sy + 50), color, 2)\n6    cv2.line(img, (sx, sy + 100), (sx - 50, sy + 175), color, 2)\n7    cv2.line(img, (sx, sy + 100), (sx + 50, sy + 175), color, 2)\n\n\n1\n\nDraw the head, 50 pixels up from reference point\n\n2\n\nDraw the neck, connecting head to reference point\n\n3\n\nDraw the main body line\n\n4\n\nDraw the left arm\n\n5\n\nDraw the right arm\n\n6\n\nDraw the left leg\n\n7\n\nDraw the right leg\n\n\n\n\nSpend some time examining the drawStickFigure function: make sure you understand how we are using offsets from the reference point, which is where the neck meets the shoulders. You will need to do something similar for the functions you implement!\nNotice that drawOneHead, drawHeads, and computeHeadOffsets are helper functions, because they are called from other functions. For testing purposes, we can call them directly from our main script, but they also need to serve the other functions well.\nFigure 3 shows four sample outputs of this program. In each case, we varied the number of heads to draw on the monster. While your face features may vary from this, the placement of the heads should match this output.\n\n\n\n\n\n\n\n\nstickMonsters with 1 head passed to drawMonster\n\n\n\n\n\n\n\nstickMonsters with 2 heads passed to drawMonster\n\n\n\n\n\n\n\n\n\nstickMonsters with 3 heads passed to drawMonster\n\n\n\n\n\n\n\nstickMonsters with 6 heads passed to drawMonster\n\n\n\n\n\n\nFigure 3: Results from 4 runs of stickMonsters, changing the number of heads passed to the call to drawMonster.\n\n\n\nImplement drawOneHead\nYour first task is to implement the drawOneHead function. It takes in an image to draw on, the coordinates for the center of its circle, and the color for the head. It should do the following:\n\nExtract the x and y values from the center coordinates, much like we do at the start of drawStickFigure or drawMonster.\nDraw a filled-in circle centered on center, in the given color, and with a radius of 40\nDraw a left eye and a right eye, in black, as circles. Compute their locations as offsets from the center x and y\nDraw a smile, using 2, 3 or more lines, in black. Again, compute the line endpoints as offsets from the center x and y\n\nRun the program repeatedly to check your work on the head and to debug it. When working, your output should match the cyan head and red stick figure fairly closely (You can choose different eye sizes or positions, and smile detaiils).\nImplement drawHeads\nThe drawHeads function will draw a series of heads and their associated necks. It will make a function call to drawHead for the actual head drawing. We want to evenly spread the heads out up to 100 pixels to the right or 100 pixels to the left of the stick figure’s center line. Follow the steps below to implement this.\n\nExtract the x and y values from refPos, similar to what we did before.\nCall the helper computeHeadOffsets, and pass it numHeads, and 100 for the “spread” we want. This function will return two values, so put two variables on the left side of an assignment = to catch the two return values. The first return value is the “left X offset” and the second return value is the region size.\nAdd a for loop: the loop variable here will be the x offset for the next head to draw (we will add this to the x coordinate of the reference point). Use the range function here, with the “left X offset value” as the starting value, 100 as the stop value, and the region size as the step value).\nInside the for loop, call drawOneHead and pass it the image. the correct (x, y) coordinates are:\n\nthe center x plus the loop variable\ny - 50 (because we want the head to draw 50 pixels above the reference point)\n\nAfter drawing the head, add in a line for the neck. Use the same x value as the head, but y - 10, which is the bottom of the head, as the starting point, and draw the line back to the reference point refPos\n\nTest your function on 1 through 6 heads on your monster. Use the tracing methods you learned earlier to help you debug your new program.\n\n\nWhat to hand in\nYou should have two files for this activity, one that contains your work, plus the edited stickMonsters.py:\n\nYour file containing definitions of printPairs and drawGrid and the debugged version of sumListNums\nThe completed stickMonsters.py file\n\nUse commit and push to copy your code to Github to submit this work."
  },
  {
    "objectID": "In-Class-Activities/index.html",
    "href": "In-Class-Activities/index.html",
    "title": "Comp 194 In-Class Activities – ToC",
    "section": "",
    "text": "Class activities for Comp 194 are stored in here.\n\n\nIn-Class Activities\n\nICA 0 - Lego Activity\nICA 1 - Basic Python and PyCharm\nICA 2 - Basic Python Data Types\nICA 3 - Modules and OpenCV Basics\nICA 4 - Loops and Images\nICA 5 - Booleans and Conditionasl\nICA 6 - Function Basics\nICA 7 - Function Practice\nICA 8 - More Lists and Strings\nICA 9 - Numpy Arrays and Image Arithmetic\nICA 10 - While Loops and Webcams/Videos"
  },
  {
    "objectID": "In-Class-Activities/ICA4-LoopsAndImages.html",
    "href": "In-Class-Activities/ICA4-LoopsAndImages.html",
    "title": "ICA: Loops and Images",
    "section": "",
    "text": "Overview\nIn this activity, you will practice with for loops and closely related ideas about sequences and accumulator variables, particularly applying them to images. This is our first control structure, programming tools that change the line-by-line, step-by-step process of evaluating a program. In this case, a for loop allows us to repeat a set of statements over and over again. Loops, like other control structures, are essential for making our code concise and efficient to write.\nTo avoid repeated typing, and the chance for errors to creep in, we use loops to tell the computer to repeat some actions. The for loop in Python is very convenient. It has a very specific syntax (the parts shown with angled brackets around them are placeholders, not part of the syntax:\n\n1for &lt;var&gt; in &lt;sequence&gt;:\n2    &lt;statements to be repeated (indented)&gt;\n\n\n1\n\nLoop variable and collection to loop over\n\n2\n\nLoop body The word after for must be a variable name. This special variable is the loop variable. The next word must be in, and then we must specify an iterable data type. Sequences like lists and strings are iterable, and functions like the range function are iterable as well (when called by the loop, it produces a sequence of values).\n\n\n\n\nNote: Complex statements in Python, like these, always have a first line that starts with the keyword that defines the statement (for, in this case) and the first line always ends with a colon (:).\n\n\nExploring the range function\nThe range function is used in for loops to generate a sequence of integers. It works in a way similar to string or list slicing, though not with the same syntax.\nTry each of the following, by copying it into a code file in PyCharm and running it. Vary the values and try to predict the output.\nA simple use of range to count:\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\nCounting upward, but not starting at 0:\n\nfor i in range(20, 26):\n    print(i)\n\n20\n21\n22\n23\n24\n25\n\n\nCounting while skipping:\n\nfor i in range(0, 15, 2):\n    print(i)\n\n0\n2\n4\n6\n8\n10\n12\n14\n\n\nTry this to hand in: Make a new script file, and create the following for loops that use the range function:\n\nCreate a for loop like the ones above that prints the values from 100 to 200\nCreate a for loop like the ones above that prints the values from 1000 to 2000\nCreate a for loop like the ones above that prints the multiples of five starting at zero and going up to include 100\nCreate a for loop that counts down from 10 to 0 (challenge one)\n\n\n\nRepeating an action N times\nThe for loops in the previous section are the simplest form: just using a loop variable to repeat something a fixed number of times. We often use simple variable names for the loop variables with this kind of loop, like i, j, or k.\nHere you will practice with using this kind of loop when drawing on an image.\nTry this to hand in: Examine the starter code shown below, and provided in flowerScatter.py.\n\nimport cv2\nimport random\n\nbkgrndImg = cv2.imread(\"SamppleImages/wildColumbine.jpg\")\n\n\n1cx = 150\ncy = 150\n2cv2.ellipse(bkgrndImg, (cx + 15, cy), (25, 16), 0, 0, 360, (252, 202, 252), -1)\ncv2.ellipse(bkgrndImg, (cx, cy + 15), (25, 16), 90, 0, 360, (252, 170, 252), -1)\ncv2.ellipse(bkgrndImg, (cx - 15, cy), (25, 16), 0, 0, 360, (252, 202, 252), -1)\ncv2.ellipse(bkgrndImg, (cx, cy - 15), (25, 16), -90, 0, 360, (252, 170, 252), -1)\n3cv2.circle(bkgrndImg, (cx, cy), 15, (114, 236, 242), -1)\n\ncv2.imshow(\"Flowers\", bkgrndImg)\ncv2.waitKey()\n\n\n1\n\nSets the center point of the flower\n\n2\n\nDraws four ellipses for petals, each a fixed offset in a different direction from center point\n\n3\n\nDraws the flower center\n\n\n\n\nRun the flowerScatter.py program and see what it does.\nFirst, we are going to change how the center point is specified. In the original code, cx and cy are set to a fixed value: every time you run the program, the flower appears in the same place. We are going to change those two lines, so that cx and cy are set to random values in the range of the width and height of the image. This image is 640 pixels by 480 pixels. Use the randint function from the random module to generate a value for cx between 0 and 639, and a value for cy that is between 0 and 479. (If you don’t remember how to use randint: ask for help!)\nNext, we are going to add a for loop to repeat all the lines from line 6 to line 12. Add the loop before line 6, using the loops from the previous section as models. Make it loop 10, 20, or even 50 times. Select the lines from 6 to 12 that we want to repeat, and indent them by hitting tab on your keyboard.\nTest your program until it does what you want. You should see something like the picture in Figure 1.\n\n\n\n\n\n\nFigure 1: Typical output when loop repeats 50 times\n\n\n\n\n\nLooping over lists\nAnother common pattern for a for loop is to build a list of data, and then use that as the sequence for the loop. When we do this, the loop variable is assigned to the values in the list, one at a time, and it repeats the loop body once for each value in the list. We typically choose a name for the loop variable that describes what it contains, even if that is just val. This helps human readers to distinguish this kind of loop from the earlier type (Python doesn’t care).\nTry the example below to see how this kind of loop works.\n\nfor name in ['Cindy', 'Marco', 'Fatima', 'Thomas', 'Yutong']:\n    print(\"Hello and welcome\", name)\n\nHello and welcome Cindy\nHello and welcome Marco\nHello and welcome Fatima\nHello and welcome Thomas\nHello and welcome Yutong\n\n\nTry this to hand in: Start with the code snippet shown below, and included in the squares.py file. It creates a blank image using zeros and sets it to a light beige-yellow color. Notice the squareSizes list. It contains a set of side lengths (half side lengths, actually) for the squares we want to draw, centered in squareImg. They are not the same distance from each other, so we can’t use the range function to generate them.\n\nimport cv2\nimport numpy as np\n\nsquareImg = np.zeros((500, 500, 3), np.uint8)\n\nsquareImg[:,:] = (220, 240, 245)\n\nsquareSizes = [10, 20, 50, 55, 60, 70, 100]\n# TODO: Add a for loop here\n\ncv2.imshow(\"Squares\", squareImg)\ncv2.waitKey()\n\nThis code snippet also includes a comment marked with TODO. TODO statements are used in programming to mark a place where a change needs to be made: adding a feature, etc. We will use them at times to help indicate where in the code we want you to make changes, and what you should do. Remove the TODO comment when you finish implementing and testing the step.\nFirst of all, create a for loop that has squareSizes as its sequence, with a loop variable called hSide (short for “half side”). Using incremental development, start by having the loop just print the value of hSide so you can check if the loop is working correctly before going on to the next step.\nOnce you are sure the for loop is correct, change the body of the loop to a call to cv2.rectangle. We need to give the upper-left and lower-right corners of the rectangle in order to draw it. We want each square to be centered on the midpoint of the image: (250, 250). Therefore, we need to calculate the upper-left corner coordinates, and the lower-right corner coordinates, as offsets from the middle. Figure 2 shows how this works for the first value of hSide: 10. If we subtract hSide from 250 for both x and y coordinates, that will give us the upper-left corner of the square, and if we add hSide to 250 for both x and y, we get the lower-right corner. These are the two points we need to pass to rectangle.\n\n\n\n\n\n\nFigure 2: How to calculate upper-left and lower-right corner coordinates\n\n\n\nUse the color (0, 0, 128) to get a dark red color for the square, and do not draw them filled in.\nYour final output should look like Figure 3.\n\n\n\n\n\n\nFigure 3: Final result\n\n\n\n\n\nAccumulator variables and for loops\nAn accumulator variable is an extra variable, not the loop variable, that collects values across the iterations of a loop. Below is a simple example, where the loop variable counts from 30 to 40, and the accumulator collects the sum of all the values the loop variable takes on.\n\n1total = 0\nfor i in range(30, 41):\n2    total = total + i\nprint(total)\n\n\n1\n\nInitialize accumulator before loop\n\n2\n\nUpdate accumulator inside loop\n\n\n\n\n385\n\n\nNotice the three key features of an accumulator variable:\n\nThe accumulator variable is created and set to an initial value before the loop\nInside the loop, often at the end, we update the value of the accumulator. This usually means combining the old value of the accumulator with a new value.\n\nRead the example below, included in your starter files as accumExamp.py. It uses two accumulator variables to calculate positions for a series of lines. It also uses an in-loop variable that sets the color with a formula based on the loop variable.\nBefore running this program: Read through this program line by line, and figure out what the values of each variable should be during the first pass through the for loop. Discuss with your teammates, and predict what the picture should look like. Then extend that to the other runs of the loop. Only after that, run the program and see if you were right.\n\nimport cv2\n\nimg = cv2.imread(\"SampleImages/landscape1MuchSmaller.jpg\")\n\nxPos = 150\nyPos = 50\nfor i in range(15):\n    bgChanVal = 16 * i + 10\n    cv2.line(img, (xPos, yPos), (xPos + 20, yPos + 100), (bgChanVal, bgChanVal, 0), 3)\n    cv2.imshow(\"Lines\", img)\n    cv2.waitKey()\n    xPos = xPos + 50\n    yPos = yPos + 20\n\nIf you can’t predict what the lines of code will do, try adding print statements so that you can see the values of the variables from one step to the next. Adding explanatory strings to your print statements will help!\nTry this to hand in: Modify the circleLine.py file. The starter script will make a custom light-green blank image, and will then draw a line of circles, each of a different color, spaced out across the image, as shown in Figure 4.\n\nimport cv2\nimport numpy as np\n\nimage = np.zeros((300, 700, 3), np.uint8)\nimage[:,:] = (206, 252, 202)\ncolors = [(0, 0, 255), (0, 255, 255), (0, 255, 0), (255, 255, 0), (255, 0, 0), (255, 0, 255)]\n\n# TODO: Add for loop here to draw six circles as described in activity\n\ncv2.imshow(\"Circles\", image)\ncv2.waitKey()\n\nYou should replace the TODO comment with a for loop that repeats six time with i as its loop variable. Inside the loop:\n\nDefine a variable to hold the ith color in the colors list\nCalculate the center x value according to this formula: \\(x = 100 \\cdot (i + 1)\\)\nDraw a filled-in circle on the image with the calculated x value, and a y value of 150, a radius of 50, and the selected color\n\nFeel free to change the six colors in the colors list if you like: I chose simple, bright colors that are the extremes in value (other than black and white).\nYour program should produce something that looks like Figure 4\n\n\n\n\n\n\nFigure 4: Line of circles expected output\n\n\n\n\n\nSimple movement\nWe can create simple animations by keeping a background image the same, and then drawing and redrawing shapes in different pictures on the same original background. Each time through the loop, we prepare a new frame and display it. We need only two new tools to implement a simple animation: copying images, and having delaying the speed for displaying each frame long enough for us to see it.\nCopying an image\nOnce an image has been read into Python by OpenCV, you can use a copy method to make an exact copy of it. Changes to the copy will not change the original! With this, we can load a background image, and then make a copy of it before drawing. We only draw on the copy, and we only display the copy. The original stays pristine and unchanged, so each time through the loop we can make a fresh copy.\nDelaying rather than stopping\nUp until now, when we display an image, we have called waitKey to stop the program until we hit a key to make it continue. We have not passed any value to waitKey. However, waitKey actually takes an optional input. When given a positive integer, it pauses for that many milliseconds to see if the user is going to hit a key. If they do not, then it continues after the specified pause. You can experiment with different amounts of milliseconds to get movement that appears smooth, but I recommend a value no smaller than 10, and 30 to 50 is a reasonable range.\nTry this to hand in: Your final task for this activity is to draw an ellipse to look like a flying saucer, coming in to land in front of the Grand Teton Mountains. Below is a description of the program you are to create, written in pseudocode. Use the skills you have been practicing up to this point to implement this program (in a new Python file).\n\nImport the cv2 module\nRead in the grandTeton.jpg image and save it in a variable\nRepeat the following 50 times\n\nAssign a new variable to hold a copy of the original image\nCalculate the (x, y) coordinates for the center of the ellipse as: \\(x = 10i+10\\) and \\(y=5i+10\\)\nDraw an ellipse on the new copy, with (x, y) for the centerpoint, and with axes of size 50 and 15, and color (245, 245, 175) (determine the other input values based on the example output below)\nDisplay the copy\nWait for 30-50 milliseconds\n\n(After the loop) Display the image again\nWait, as normal, for the user to hit a key\n\nYour program should produce a series of pictures of the pale blue ellipse moving across the scene. Figure 5 shows a GIF of what the program should produce.\n\n\n\n\n\n\nFigure 5: Frame from UFO animation\n\n\n\n\n\nWhat to hand in\nYou should have multiple Python files for this activity. At the very least, you must have:\n\nA file containing your simple loops using range\nThe flowerScatter.py file, modified as directed\nThe squares.py file, modified as directed\nThe accumExamp.py file, with any experiments you performed\nThe circleLine.py file, modified as directed\nA file containing the flying saucer script\n\nUse commit and push to copy your code to Github to submit this work."
  },
  {
    "objectID": "In-Class-Activities/ICA0-LegoActivity.html",
    "href": "In-Class-Activities/ICA0-LegoActivity.html",
    "title": "ICA 0: Lego Activity",
    "section": "",
    "text": "Goals\n\n\n\n\n\nTo meet and interact with classmates\nTo study the idea of **process* and algorithm writing\n\nYou will be assigned at random to a team of 3-4. When joining your new group, introduce yourselves, and share: * Introduce yourselves, and share: * Name * Where you are from? * Where do you live on campus? * What courses are you taking this fall? * Share a “boring” or unexpected thing you are good at\n\n\n\n\n\n\n\n\nPhase 1\n\n\n\n\n\n\n\nMove to sit with your team\nIntroduce yourselves!\nExamine your Lego model, pass it around\n\nDo not disassemble!\n\nDiscuss shape as a group (what is its shape, what might it be for)\nLearn as much about it as you can\n\nWithout taking it apart\nWithout taking notes\nWithout drawing or taking pictures\n\n\nWhen time is up, return Lego model to instructor!\n\n\n\n\n\n\n\n\n\nPhase 2\n\n\n\n\n\n\n\nBuild a copy of your Lego model from the parts provided\n\nwithout the model\n\nWork as a team, discuss your model When time is up, return Lego parts to instructor and discuss:\nWhat worked for this model?\nWhat was challenging?\nWhat would you need to do better?\n\n\n\n\n\n\n\n\n\n\nPhase 3\n\n\n\n\n\n\n\nExamine your Lego model, again\nDiscuss it with your group\nAs a group, on paper, write instructions for building your model\n\nWithout taking it apart\nWithout drawing or taking pictures\n\n\nWhen time is up, return Lego model\n\n\n\n\n\n\n\n\n\nPhase 4\n\n\n\n\n\n\n\nMove to join your new team\nIntroduce yourselves\nGet instructions and parts from instructor\nBuild the new model\n\nWhen time is up, return parts, and discuss: * What worked and what was challenging? * How useful were the instructions, how could they be made better?"
  },
  {
    "objectID": "In-Class-Activities/ICA0-LegoActivity.html#goals",
    "href": "In-Class-Activities/ICA0-LegoActivity.html#goals",
    "title": "ICA 0: Lego Activity",
    "section": "",
    "text": "To meet and interact with classmates\nTo study the idea of **process* and algorithm writing\n\nYou will be assigned at random to a team of 3-4. When joining your new group, introduce yourselves, and share: * Introduce yourselves, and share: * Name * Where you are from? * Where do you live on campus? * What courses are you taking this fall? * Share a “boring” or unexpected thing you are good at"
  },
  {
    "objectID": "In-Class-Activities/ICA0-LegoActivity.html#phase-1-5-minutes",
    "href": "In-Class-Activities/ICA0-LegoActivity.html#phase-1-5-minutes",
    "title": "ICA 0: Lego Activity",
    "section": "",
    "text": "Move to sit with your team\nIntroduce yourselves!\nExamine your Lego model, pass it around\n\nDo not disassemble!\n\nDiscuss shape as a group (what is its shape, what might it be for)\nLearn as much about it as you can\n\nWithout taking it apart\nWithout taking notes\nWithout drawing or taking pictures\n\n\nWhen time is up, return Lego model to instructor!"
  },
  {
    "objectID": "In-Class-Activities/ICA0-LegoActivity.html#phase-2-5-minutes",
    "href": "In-Class-Activities/ICA0-LegoActivity.html#phase-2-5-minutes",
    "title": "ICA 0: Lego Activity",
    "section": "",
    "text": "Build a copy of your Lego model from the parts provided\n\nwithout the model\n\nWork as a team, discuss your model When time is up, return Lego parts to instructor and discuss:\nWhat worked for this model?\nWhat was challenging?\nWhat would you need to do better?"
  },
  {
    "objectID": "In-Class-Activities/ICA0-LegoActivity.html#phase-3-5-minutes",
    "href": "In-Class-Activities/ICA0-LegoActivity.html#phase-3-5-minutes",
    "title": "ICA 0: Lego Activity",
    "section": "",
    "text": "Examine your Lego model, again\nDiscuss it with your group\nAs a group, on paper, write instructions for building your model\n\nWithout taking it apart\nWithout drawing or taking pictures\n\n\nWhen time is up, return Lego model"
  },
  {
    "objectID": "In-Class-Activities/ICA0-LegoActivity.html#phase-4-5-minutes",
    "href": "In-Class-Activities/ICA0-LegoActivity.html#phase-4-5-minutes",
    "title": "ICA 0: Lego Activity",
    "section": "",
    "text": "Move to join your new team\nIntroduce yourselves\nGet instructions and parts from instructor\nBuild the new model\n\nWhen time is up, return parts, and discuss: * What worked and what was challenging? * How useful were the instructions, how could they be made better?"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "Homework/index.html",
    "href": "Homework/index.html",
    "title": "Comp 194 Homework Assignments – ToC",
    "section": "",
    "text": "Out-of-class homework assignments for Comp 194 are stored in here.\n\n\nHomework assignments\n\nHomework 1\nHomework 2\nHomework 3\nHomework 4\nHomework 5\nHomework 6"
  },
  {
    "objectID": "Readings/Chapter2.html",
    "href": "Readings/Chapter2.html",
    "title": "Chapter 2, Images as Matrices (and Numpy Arrays)",
    "section": "",
    "text": "In this chapter, we will take a closer look at how image representation works with OpenCV and Numpy, and tools from both libraries we can use to work with images. A key point to remember is that, though we can access individual pixel values, we will rarely ever write programs the manually iterate over the rows and columns of an image and read, or change, each individual pixel value. Doing so can be very slow. However, we can leverage the mathematics around vectors and matrices (a central focus of Linear Algebra) to treat images as matrices. This lets us use many highly-optimized algorithms for manipulating matrices, some of which leverage the multicore nature of modern computers.\nThe Numpy module implements N-dimensional arrays, a data structure that represents matrices, and it also provides those optimized algorithms for manipulating matrices. OpenCV sometimes has its own versions of basic matrix algorithms, as well."
  },
  {
    "objectID": "Readings/Chapter2.html#creating-an-array",
    "href": "Readings/Chapter2.html#creating-an-array",
    "title": "Chapter 2, Images as Matrices (and Numpy Arrays)",
    "section": "2.1 Creating an array",
    "text": "2.1 Creating an array\nAs we know, OpenCV will create an array to represent an image read from a file. But here we will examine some tools for creating arrays from scratch. More details about creating Numpy arrays may be found in the Numpy tutorial section Creating Arrays.\nIf we create a list or tuple with the structure we want in our Numpy array, the array or asarray functions can convert that to an array with the same structure. Each function takes one required input, the sequence or array to build the new array from, as well as optional inputs including dtype, which allows us to specify the type of data we want the new array to have. See the Numpy tutorial Data types for an extended discussion of Numpy data types, and how to specify them.\nBelow are some examples of making arrays with different structures with these functions.\n\nlst1 = [5, 6, 4, 3]\nlst2 = [[1, 2, 3], [4, 5, 6]]\nlst3 = [[[9, 8], [7, 6], [5, 4]]]\narr1 = np.array(lst1)\narr2 = np.array(lst2, dtype=np.uint8)\narr3 = np.asarray(lst3)\nprint(\"Array 1 shape and dtype:\", arr1.shape, arr1.dtype)\nprint(arr1)\nprint(\"Array 2 shape and dtype:\", arr2.shape, arr2.dtype)\nprint(arr2)\nprint(\"Array 3 shape and dtype:\", arr3.shape, arr3.dtype)\nprint(arr3)\n\nArray 1 shape and dtype: (4,) int64\n[5 6 4 3]\nArray 2 shape and dtype: (2, 3) uint8\n[[1 2 3]\n [4 5 6]]\nArray 3 shape and dtype: (1, 3, 2) int64\n[[[9 8]\n  [7 6]\n  [5 4]]]\n\n\nWe can also use these functions to copy an array and change the type of the data, etc. The array function always makes a copy of the data, while the asarray function, when given an array as input, may create a new view of the data, but not actually copy it. Thus changes to the original array can show up in the new array. We have seen a similar phenomena, aliasing, with shared data in lists. A Numpy array has a method astype, that can convert the contents of the array from one type to another. As with the asarray function, it may not copy the data, but rather just provide a view of it as a new type. (For an extended discussion of copying versus viewing, see the Numpy tutorial section Copies and view)\n\narr4 = np.array(arr1)\narr5 = np.asarray(arr1)\narr1[0] = 20\nprint(\"Original array:\", arr1)\nprint(\"Copied array:\", arr4)\nprint(\"Viewed array:\", arr5)\narr6 = arr1.astype(np.float32)\nprint(\"astype array:\", arr6)\n\nOriginal array: [20  6  4  3]\nCopied array: [5 6 4 3]\nViewed array: [20  6  4  3]\nastype array: [20.  6.  4.  3.]\n\n\nThere are several functions to create arrays from scratch, by specifying only the size and data type. Each function fills the array with data that follows a particular pattern. We have already seen two of these functions, zeros and ones, but now we will look at them more closely. Additional functions include random.rand, which makes an array filled with random values, eye, which creates an identity matrix for any \\(N\\times N\\) size, and arange, which fills the array with values where start and end are specified.\nThe zeros and ones functions take in a tuple that defines the shape of the new matrix to make. The most common optional input is dtype, where we can specify the type of data to put into the array. The zeros function makes an array of the given size, and fills each cell in the array with 0. The ones is similar, except that it fills each cell in the array with 1.\n\nz1 = np.zeros((5, 5))\nprint(\"z1:\")\nprint(z1)\nz2 = np.zeros((3, 3, 2), dtype=np.uint8)\nprint(\"z2:\")\nprint(z2)\no1 = np.ones((1, 4), dtype=np.float64)\nprint(\"o1:\")\nprint(o1)\n\nz1:\n[[0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0.]]\nz2:\n[[[0 0]\n  [0 0]\n  [0 0]]\n\n [[0 0]\n  [0 0]\n  [0 0]]\n\n [[0 0]\n  [0 0]\n  [0 0]]]\no1:\n[[1. 1. 1. 1.]]"
  },
  {
    "objectID": "Readings/Chapter2.html#arithmetic-on-arrays",
    "href": "Readings/Chapter2.html#arithmetic-on-arrays",
    "title": "Chapter 2, Images as Matrices (and Numpy Arrays)",
    "section": "2.2 Arithmetic on arrays",
    "text": "2.2 Arithmetic on arrays\nNumpy extends the built-in arithmetic operators to work on arrays. The four basic arithmetic operations, addition, subtraction, multiplication, and division, all perform element-wise operations on arrays. That means that it matches up corresponding elements of the arrays, and does the arithmetic on them. The examples below show this process on two arrays with the same shape.\n\na1 = np.array([[1, 2, 1], [4, 5, 6]])\na2 = np.array([[2, 2, 2], [3, 3, 3]])\nprint(\"Addition\")\nprint(a1 + a2)\nprint(\"Subtraction\")\nprint(a1 - a2)\nprint(\"Multiplication\")\nprint(a1 * a2)\nprint(\"Division\")\nprint(a1 / a2)\n\nAddition\n[[3 4 3]\n [7 8 9]]\nSubtraction\n[[-1  0 -1]\n [ 1  2  3]]\nMultiplication\n[[ 2  4  2]\n [12 15 18]]\nDivision\n[[0.5        1.         0.5       ]\n [1.33333333 1.66666667 2.        ]]\n\n\nWe can always apply arithmetic operations when two arrays have the same shape. Numpy also allows us to perform arithmetic between an array and a scalar (an individual number). At each cell in the array, we perform the arithmetic on that cell’s value, and the scalar.\n\nprint(a1 + 4)\nprint(10 * a1)\n\n[[ 5  6  5]\n [ 8  9 10]]\n[[10 20 10]\n [40 50 60]]\n\n\nNumpy also allows arithmetic between two arrays of different shapes, if one can be naturally extended to map onto the other. It can be tricky to determine the rules for when something is extensible, but a simple case is when we have a 2-d array: we can specify a second array the length of a row and the arithmetic operator will extend that across all the rows of the array, and similarly for columns.\n\na1 = np.array([[2, 4], [6, 8], [10, 12]])\na2 = np.array([5, 10])\na3 = np.array([[3], [-3], [2]])\nprint(\"a1 * a2:\")\nprint(a1 * a2)\nprint(\"a1 * a3:\")\nprint(a1 * a3)\n\na1 * a2:\n[[ 10  40]\n [ 30  80]\n [ 50 120]]\na1 * a3:\n[[  6  12]\n [-18 -24]\n [ 20  24]]"
  },
  {
    "objectID": "Readings/Chapter2.html#accessing-and-slicing-arrays",
    "href": "Readings/Chapter2.html#accessing-and-slicing-arrays",
    "title": "Chapter 2, Images as Matrices (and Numpy Arrays)",
    "section": "2.3 Accessing and slicing arrays",
    "text": "2.3 Accessing and slicing arrays\nWe can access and modify individual values in an array, or subarrays of various shapes and sizes, using an extended version of the square bracket notation Python uses for lists and strings, as well as an extended version of slicing. Numpy’s introductory tutorial has a section, Indexing on ndarrays, that goes into more details about accessing and indexing.\nIf we have a one-dimensional Numpy array, holding data in a single row, then accessing its elements or slicing out a subarray looks just like operating on a list.\n\na1 = np.arange(3, 8)\nprint(a1.shape, a1)\nprint(\"Values:\", a1[0], a1[3], a1[-1])\nprint(\"Subarrays:\", a1[0:3], a1[4:], a1[::2])\n\n(5,) [3 4 5 6 7]\nValues: 3 6 7\nSubarrays: [3 4 5] [7] [3 5 7]\n\n\nSuppose we have a two-dimensional array. Its structure matches that of a nested list. With nested lists, a single square bracket returns the whole nested sublist. To access an individual value inside that sublist, we add a second square bracket (see first examples below).\nWith a two-d array, a single square bracket with a single number returns the subarray corresponding to that row. We can add a second square bracket after the first, with a similar effect as with lists, but Numpy also allow us to put both indices inside a single pair of square brackets, separated by commas. This is an easier notation (see second examples below).\n\nlst = [[9, 8], [7, 6]]\nprint(\"List element:\", lst[1], \"  Sublist element:\", lst[1][0])\na2 = np.array(lst)\nprint(\"Array element:\", a2[1], \"  Subarray element:\", a2[1][0], \"  and simpler notation:\", a2[1, 0])\n\nList element: [7, 6]   Sublist element: 7\nArray element: [7 6]   Subarray element: 7   and simpler notation: 7\n\n\nWe can always replace the single number with a slicing operator, where we specify start and end indices, and step size, to select a range of values from an array. Notice that we can use a single colon (:) to indicate all values for a given dimension. Remember that if we leave out start or end then Python assumes it should start at 0 and go to the end of the current dimension. And if we have two colons, the value after the second colon is a step size or number of elements to skip. Before looking closely at the output for the examples below, try to predict the output for the random array shown here and the code below.\n\nrArr = np.random.rand(6, 6) * 100\nrArr = rArr.astype(int)\nprint(\"Random array:\")\nprint(rArr)\n\nRandom array:\n[[10 54 64 51 55  8]\n [60 58 46 52  9 62]\n [39 35 88  0 58 23]\n [53 41 12 11 51 73]\n [61 36 92 85 12 99]\n [47 71 99 83 17 40]]\n\n\n\nprint(\"Selecting just rows 2 through 4:\")\nprint(rArr[2:4])\nprint(\"Selecting all rows of columns 0 and 3:\")\nprint(rArr[:, ::3])\nprint(\"Selecting rows 2 and 3 and columns 2 and 3:\")\nprint(rArr[2:4, 2:4])\nprint(\"Selecting the last value from all rows:\")\nprint(rArr[:, -1])\n\nSelecting just rows 2 through 4:\n[[39 35 88  0 58 23]\n [53 41 12 11 51 73]]\nSelecting all rows of columns 0 and 3:\n[[10 51]\n [60 52]\n [39  0]\n [53 11]\n [61 85]\n [47 83]]\nSelecting rows 2 and 3 and columns 2 and 3:\n[[88  0]\n [12 11]]\nSelecting the last value from all rows:\n[ 8 62 23 73 99 40]\n\n\nWe use slicing like this on images to extract a rectangular region of an image, called a region of interest (ROI). See discussion in a later section."
  },
  {
    "objectID": "Readings/Chapter2.html#using-boolean-arrays",
    "href": "Readings/Chapter2.html#using-boolean-arrays",
    "title": "Chapter 2, Images as Matrices (and Numpy Arrays)",
    "section": "2.4 Using boolean arrays",
    "text": "2.4 Using boolean arrays\nThe last Numpy tools we will look at are boolean arrays. These arrays allow us to apply comparison operations to whole arrays, creating arrays the same shape filled with True and False. We can use Numpy functions any and all to ask whether the resulting array has any true values, or if all are true values.\nMost exciting, we can use boolean arrays as a selection index inside square brackets, to extract just the values from the array where the boolean array has True. (Much more can be found in the Indexing with boolean arrays section of the Numpy quickstart guide.\n\narr = np.array([[5, 3, 6, 2], [9, 1, 6, 8], [4, 2, 1, 7]])\nbArr = arr &gt;= 5\nprint(bArr)\nresult = arr[bArr]\nprint(\"Result:\", result)\n\n[[ True False  True False]\n [ True False  True  True]\n [False False False  True]]\nResult: [5 6 9 6 8 7]"
  },
  {
    "objectID": "Readings/Chapter1.html",
    "href": "Readings/Chapter1.html",
    "title": "Chapter 1, Getting Started with OpenCV",
    "section": "",
    "text": "OpenCV is an add-on module in Python. Modules contain constants and functions that have a special purpose. They are not automatically loaded and available when we start up the Python interpreter. We have to explicitly ask for them to be loaded using the import command. For instance, the command below will load the OpenCV tools.\n\nimport cv2\n\nYou can type the import command into the Python shell, or you can put it in a script file.\nNote: Always put all import statements at the top of your file.\nThere are many useful modules provided by Python, or added by third-party developers. Other modules you might explore include math, random, statistics, sys, and os. A secondary module used by OpenCV is numpy, which provides efficient tools for representing and manipulating multidimensional arrays of numbers.\nWhen you import a module, Python makes a special separate namespace where the tools from that module reside. In order to access them, you must tell Python to look in that namespace by attaching the name of the module, followed by a period. You’ll see examples of this below.\nIn Python, the OpenCV module is called cv2.\nOpenCV has excellent online documentation, and you will need to become familiar with using it (as discussed in Chapter 0).\nTry examples! Throughout this and future sections, you are encouraged to try the code examples along with the reading. To prepare for that, set up a project in PyCharm using the version of Python that has OpenCV installed in it, and move a copy of the SampleImages folder into the project. Put your code files in the top level of the project, alongside the SampleImages folder.\n\n\n\n1import cv2\n\n2img1 = cv2.imread(\"SampleImages/snowLeo1.jpg\")\n3cv2.imshow(\"Leopard 1\", img1)\n4img2 = cv2.imread(\"SampleImages/snowLeo2.jpg\")\ncv2.imshow(\"Leopard 2\", img2)\n5cv2.waitKey(0)\n\n\n1\n\nLoad the OpenCV module\n\n2\n\nRead in the image from snowLeo1.jpg, assign img1 to hold the image\n\n3\n\nDisplay the image in img1 with title Leopard 1\n\n4\n\nRead snowLeo2ljpg into img2 and display it as Leopard 2\n\n5\n\nWait for the user to hit a key before continuing\n\n\n\n\nNote about paths: In Chapter 0 we discussed the importance of understanding paths in order to write programs that work with files. When we read in an image file, we must specify an absolute or relative path that is correct, as well as spelling the filename correctly. For this to work, you must configure your project so that:\n\nThe SampleImages folder is in your project folder\nThe code file you make is in the same project folder as SampleImages (not inside SampleImages itself!)\n\nThe relative path used in the code above starts from the folder where the code file is, and tells the computer how to navigate from there to where the image file is.\nCopy this program and run it to see what happens. You should see two windows pop up, showing the two snow leopard images (they may appear under other windows). To get the program to finish, click on one of the image windows to make it active, and then hit a key on the keyboard. The window should disappear and PyCharm should be done with the program.\nOpenCV uses the string that is the first input to imshow to identify windows: if you use call imshow again with the same string but a new image, the new image will appear in the same window. To see this, change the string for the second imshow above to be \"Leopard 1\". Then rerun the script. You probably will not see the first image, because it is overwritten so quickly by the second one. To slow things down, copy the waitKey line and put it right after the first call to imshow.\n\n\n\nColors we perceive in the real world derive from different frequencies of light emitted or reflected off objects in our world, and filtered through our brain’s perception systems. Color theory is an extremely interesting field of study, with contributions from mathematics, physics, biology, art, photography, psychology, and more.\nInside the computer, we must convert color into a discrete, compact representation: a digital representation. There are dozens of ways of representing color digitally, though a few are most common. Below, we will explore several common color representations used to represent images.\n\n\nThe most common representation of colors for images is the RGB (red, green, blue) format. This is because monitors and projectors typically use RGB to display colors to us. If you have ever looked closely at a projector’s output, or looked at a droplet of water on your phone screen, you can see dots of red, green, and blue light very close together (see Figure 1).\n\n\n\n\n\n\nFigure 1: Closeup view of HD LED TV screen (Wikimedia Commons)\n\n\n\nLong ago, pointillist artists discovered that small dots of color close together can fool the human eye into perceiving a different color altogether. Similarly, photographers from the 19th century figure out that they could simulate color photos by layers three copies of a photo together, one tinted with red, one with green, and one with blue. Only later did scientists come to understand how human color vision works, and why these methods work for us.\nIn human eyes, we have three different color receptors, or cones. Each kind responds to a different range of wavelengths, and responds more or less strongly depending on the wavelength (see Figure 2). If we display red, green, and blue light in close proximity, the human eye can be fooled into perceiving a corresponding wavelength of light.\n\n\n\n\n\n\nFigure 2: Wavelength vs Color-detecting cones (Hyperphysics, GSU)\n\n\n\nIn the RGB color representation, we call the three values of red, green, and blue light channels. We represent colors as a collection of three values, one for each channel. A good metaphor for how RGB works is that we have three sliders as shown in Figure 3, one for each channel, and we can move them independently to select a different amount of light. The result is the actual color we are representing.\n\n\n\n\n\n\nFigure 3: A slider for each channel (Dovesystems Scenemaster)\n\n\n\nThe position of the slider indicates how much of that channel’s light we are mixing. Shades of gray occur when all three channels have the same value. Black is the absence of all light, and white is full power to all three channels.\nSliders that control lights typically vary continuously in the positions they can take. However, inside the computer we need things to be discrete, so one question that arose is: how many different values do we need for each channel to get photorealistic images? If each slider was actually a light switch, it would have just two positions: on and off. We can represent these as 1 and 0. The table below shows all the combinations of the three switches, and the colors they correspond to.\n\n\n\nR\nG\nB\nColor\n\n\n\n\n0\n0\n0\nBlack\n\n\n0\n0\n1\nBlue\n\n\n0\n1\n0\nGreen\n\n\n1\n0\n0\nRed\n\n\n0\n1\n1\nCyan\n\n\n1\n0\n1\nMagenta\n\n\n1\n1\n0\nYellow\n\n\n1\n1\n1\nWhite\n\n\n\nObviously, we want more than just two values per channel, but this representation only requires three bits of information inside the computer.\nSide note on binary representations: All data inside a computer is ultimately represented in binary, as a sequence of ones and zeros, because computers use the presence or absence of electricity in a wire, or the direction of a magnetic field, to represent data. A bit is the smallest unit of information: zero or one, (yes/no, true/false, on/off). Modern computers almost all use a collection of 8 bits as the smallest useful unit of data: this is called a byte (4 bits is called a nibble, computer scientists like puns!). When we are choosing how to represent data, sometimes we must consider how many bytes that data will take up.\nThere is an important relationship between the number of bits in a representation, and how many distinct patterns or values we can represent. If we have \\(k\\) bits in our binary representation, then we can represent \\(2^k\\) distinct values. Above, we had 3 bits per color: there were \\(2^3 = 8\\) binary patterns, corresponding to eight distinct colors.\nRepresenting colors by their frequencies or wavelengths might need an 8-byte floating-point number. Representations based on multiple channels, each holding integers, can be more efficient.\nThe typical representation for RGB channels provides one byte (8 bits) for each channel, for a total of 3 bytes to represent a color. According to the rule above, each channel can represent \\(2^8 = 256\\) distinct values: 00000000, 00000001, 0000010, … 11111110, 11111111. We use nonnegative integer values starting with zero; we call this kind of number an unsigned integer. In the case of color channel values, we use the integers from 0 to 255. The total number of distinct colors we can create with this representation is \\(2^{24} = 16,777,216\\), more than 16 million distinct colors!\nWe represent a color as a collection of three 8-bit unsigned integer values, one for each channel.\nThere are many online “color pickers” that let us generate colors, and shows us the color representations in different formats. Explore the color picker at HTML Color Codes. Because this is designed for choosing web colors, it shows each color in a Hex representation, in RGB, and in HSL. The Hex representation is used on websites and other applications for colors: it is actually the RGB color values, rewritten into hexadecimal (base 16) notation (to see this, click on a color close to black, where the values will be close to zero). Notice that the RGB values are always in the range from 0 to 255.\nHSL stands for “hue, saturation, lightness” and is a very different color representation than RGB. We will not use HSL, but it is closely related to a color representation called HSV, which we will use when using color to segment images or track objects. (See HSL and HSV, Wikipedia for more details about how HSL and HSV relate.)\nOpenCV in Python chooses to represent RGB colors backwards, as BGR. That means that a color is a tuple containing three numbers: blue channel, green channel, red channel. A tuple is like a list, but can’t be modified. The numbers in the tuple must be integers between 0 and 255. For instance, Figure 4 shows three colors and their BGR representations in OpenCV\n\n\n\n\n\n\n\n\n(0, 0, 0) black\n\n\n\n\n\n\n\n(255, 0, 0) blue\n\n\n\n\n\n\n\n(0, 180, 180) green-yellow\n\n\n\n\n\n\nFigure 4: Colors and their representations in OpenCV\n\n\n\n\n\n\nThere are many other color representations that we could use. As mentioned before, one used for color-based algorithms is called HSV (hue, saturation, value). In HSV, the basic color is defined by single channel value, the hue. Hue values are interpreted as degrees around a circle: 0 to 359. The other two channel values are thought of as percentages, often in the range from 0 to 100.\nThe saturation channel describes how “pure” or intense the color is: one way to think of saturation is how mixed with white the color is: high saturation values have little mixture with white, low saturation are strongly mixed with white. The value channel captures the brightness of the image: you can think of it as changing values appear mixed with white or gray. The value defines the color’s brightness, changing the shade of gray that we mix into the saturation: low values cause the hue to be mixed with dark gray or black, high values mix with light gray or white. The colorizer color picker, while more clumsy to use, does include HSV as one of its options (also called HSB). Figure 5 shows the mapping of hue values to degrees in HSV.\n\n\n\n\n\n\nFigure 5: HSV hue values, using the range from 0 to 360\n\n\n\nHSV is useful for color-tracking in images, because the hue changes relatively little when the brightness of the light changes, whereas all three channels in an RGB image change when the brightness changes.\nOpenCV represents HSV values as a tuple of three 8-bit unsigned integers, much like RGB. That means the values are limited to the range from 0 to 255. How does that work when the usual ranges of HSV values are 0-360, 0-100, and 0-100?\n\nThe hue channel in OpenCV uses the range from 0 to 179, dividing the HSV degrees in half. Thus, a midgreen value in Figure 5 above normally has value 120: in OpenCV we use 60 for this hue instead.\nThe saturation and value channels normally runs from 0 to 100. OpenCV rescales them to range from 0 to 255. To convert a “global” saturation level to OpenCV, use this formula: \\(s_{opencv} = \\frac{s_{global}}{100} \\cdot 255\\).\n\nOn beyond HSV\nThere are many additional color representations, each with its own strengths and uses. As one example, the YUV color representation has three channels: YUV. The Y channel contains brightness or “luminance” information, and the U and V channels together describe the color. We use this color representation for balancing the brightness of an image, by converting to this format, modifying the Y channel, and then converting back to BGR for display/use. The YUV Colorspace web page gives some nice visuals showing how this representation works.\n\n\n\n\nGiven a specific color representation, we now have to figure out how to represent a whole image. We want to distinguish between how an image might be represented when stored as a file, and how it might be represented when read into a program. In both cases, multiple representations are possible, though for our purposes we don’t need to know the details of different file representations, and we will focus on OpenCV’s method for representing images.\nWhen an image is stored in a file, the file format often keeps the image’s data in a compressed form, saving space. The exact format and kind of compression used is signaled by the file extension (.jpg, .png, .gif, etc.). OpenCV can work with many file formats, but the extension must match the actual contents for any program to be able to read or display an image. Don’t just change the extension: that will just make the file unreadable. You have to use a program to convert from one representation of an image to another, if needed.\nOnce an image is read into a program to be manipulated, however, the image representation is very different from that in a file, and images are represented the same way, whether they originated in a jpg or png or any other file format. Different programming tools use slightly different representations for images, but all share certain key features:\n\nAn image is a grid of pixels (short for picture elements)\nEach pixel contains a single color\nWe interpret the horizontal dimension of the grid as the x dimension, with 0 at the left, increasing to the right\nWe interpret the vertical dimension of the grid as the y dimension, with 0 at the top, increasing downward\nLocations for specific pixels are given as (x, y) coordinates\n\nFigure 6 shows a tiny, 6 pixel by 6 pixel image, with x and y dimensions and indices given. The blue pixel representing the right eye is at (4, 1).\n\n\n\n\n\n\nFigure 6: Tiny 6x6 image with x and y dimensions and valid x and y indices\n\n\n\nNote that a pixel is not a unit of measurement. While image files often store a mapping between numbers of pixels and distance, such as ppi (pixels per inch), that is not an intrinsic property of the images. A pixel is simply the smallest unit of an image. When the pixels are drawn small enough, we don’t notice the individual pixels, and instead see the whole picture. #fig-showPixels shows the “Mighty Midway” picture from SampleImages, and then a portion of the picture, zoomed in far enough to see the individual pixels. The original picture is 1000 pixels wide by 667 pixels tall.\n\n\n\n\n\n\n\n\nmightyMidway.jpg\n\n\n\n\n\n\n\nZoomed-in view\n\n\n\n\n\n\nFigure 7: The mightyMidway.jpg image, and a section zoomed in to show pixels\n\n\n\nGrayscale versus color images\nThere are three variations on images: color, grayscale, and black-and-white. We have discussed color images and how color might be represented already. Grayscale images contain only shades of gray between black and white. As we noted earlier, shades of gray correspond to the RGB channels holding equal values: (195, 195, 195) is a medium bright shade of gray. Black-and-white images contain only black pixels and white pixels, no shades of gray in between.\nBecause a grayscale image has equal channel values, we only need to represent one copy, the luminance or brightness (for the gray shade above, just one 195 is needed). OpenCV represents grayscale images as a two-dimensional array, or matrix, of numbers. In Figure 8 a small example of a grayscale image is shown on the left, with\nColor images, however, have more data per pixel, and generally use 2-4 numbers to represent each color. In OpenCV, we represent this by using a three-dimensional matrix: the first dimension is x, the second dimension is y, and the third dimension is for the channels. Figure 8 illustrates the structure of an OpenCV color image.\n\n\n\n\n\n\nFigure 8: Grayscale and color image matrix structures\n\n\n\nImages in OpenCV are represented using Numpy arrays: we will return to this subject later when we look more closely at the Numpy module and the tools we may use to manipulate image arrays.\n\n\n\nOpenCV provides a set of tools that allow you to draw shapes on images. We can also make blank images to serve as “canvases” for our drawings. In this section we will explore the different drawing functions OpenCV provides, and you will also learn how to save an image to a file, so you can store the results.\n\n\nIn this section we will introduce the basic drawing commands, and their basic inputs. You can find more commands and more details in the Drawing Functions page of the OpenCV documentation; each function has more optional inputs than are given here.\nIn each example below we will use the same set of variables as is used in the documentation:\n\nimg is a typical OpenCV image, a Numpy array\npt, pt1, and pt2 are all points, tuples containing x and y indices into the image\ncolor is a color, a tuple containing blue, green, and red values\nthickness is line thickness, how wide to draw the lines, and if negative then the shape is drawn “filled-in”\nangle, startAngle, and endAngle are all angles, typically between 0 and 360, though other angles may be permitted\n\nNote: Drawing or making other changes to an image does not automatically update the image displayed previously by a call to imshow. You must call imshow again to see the changes.\nDrawing lines\n\ncv2.line(img, pt1, pt2, color, thickness)\n\nThe line function takes in an image to draw on, two (x, y) coordinate points, input as tuples, and a color (given as a BGR tuple). The thickness input is optional, but is often used to tell how many pixels wide the line should be. If you do not specify thickness the line is drawn as one pixel wide. The function draws a line as specified between the two coordinate points.\nDrawing rectangles\n\ncv2.rectangle(img, pt1, pt2, color, thickness)\n\nThe rectangle function takes in an image to draw on, and two (x, y) coordinate points, as tuples. Typically, we also specify the color tuple and line thickness. The two points specify two opposite corner pixels of the rectangle to draw (for instance, upper-left and lower-right corners). If the line thickness is 1 or greater, then a line rectangle is drawn with the given corner points, line color, and line thickness. If the line thickness is negative then a filled in rectangle with the given corners and color is drawn.\nDrawing circles\n\ncv2.circle(img, pt, radius, color, thickness) \n\nThe circle function takes in the image to draw on, the center point of the circle (a pixel location as an (x, y) tuple), an integer radius for the circle, and a color tuple. Line thickness is optional, and works the same as for rectangles: positive specifies line thickness, negative draws a filled-in circle.\nDrawing ellipses\n\ncv2.ellipse(img, pt, axes, angle, startAngle, endAngle, color, thickness)\n\nDrawing ellipses (ovals) is the most complicated of the functions we will look at, because the function not only draws ellipses but also arcs and partial ellipses, both line and filled. Therefore, we will go into more details about what each input parameter does.\nTo take the easy ones first, img is the image to draw on, pt is the center point as (x, y) coordinates (if you like mathy details, pt is the center point of the circle that circumscribes this ellipse, as ellipses are usually defined by two points). The color and thickness inputs work just as for the other drawing commands.\nFor the remaining inputs, we will illustrate them with a specific example, shown below.\n\nimport cv2\n\nbeachIm = cv2.imread('SampleImages/beachBahamas.jpg')\n1cv2.ellipse(beachIm,\n2            (500, 250),\n3            (70, 150),\n4            45,\n5            0,\n6            360,\n7            (0, 255, 255),\n8            2)\ncv2.imshow(\"Beach\", beachIm)\ncv2.waitKey()\n\n\n1\n\nimg, the value of beachIm\n\n2\n\npt, a tuple holding the (x, y) center point\n\n3\n\naxes, a tuple holding sizes of ellipse’s axes\n\n4\n\nangle, an integer angle, rotated from the horizontal\n\n5\n\nstartAngle, an integer angle, where to start drawing ellipse arc/wedge\n\n6\n\nendAngle, an integer angle, where to stop drawing ellipse arc/wedge\n\n7\n\ncolor, the color for the ellipse\n\n8\n\nthickness, line thickness or to make ellipse filled\n\n\n\n\nThis program produces the ellipse shown in @figure-ellipse0.\n\n\n\n\n\n\nFigure 9: Ellipse drawn by code\n\n\n\nThe axes input specifies the width and height of the ellipse in the form (r1, r2). To interpret these, first think of the ellipse as being unrotated. Then its first axis is horizontal, and the second axis is vertical. The r1 value is one-half the length of the first axis, and r2 is one-half the length of the second axis. Figure 10 show the (x, y) center point, and the length and meaning of the axes tuple (r1, r2).\n\n\n\n\n\n\nFigure 10: Ellipse with center point (x, y) and axes (r1, r2) drawn on\n\n\n\nIn this code example, the total width of the ellipse along its first axis is 140 pixels, and the total height of the ellipse along its second axis is 300 pixels.\nThe angle input specifies how far to rotate the ellipse in the clockwise direction from a start where its first axis is horizontal. Another way to think about it is that angle is the angle between the horizontal and the first axis. You can pass negative angles here, to get counter-clockwise rotations. Figure 11 Shows how angle is determined for our example.\n\n\n\n\n\n\nFigure 11: Ellipse with rotation angle marked\n\n\n\nThe last two inputs to discuss are startAngle and endAngle. We will start with a simple rule: when in doubt, set startAngle to 0 and endAngle to 360. This will draw the full ellipse.\nYou only need to vary startAngle and endAngle if you want to draw just a portion of the outline of the ellipse, or a wedge of the filled-in ellipse. In those cases, you need to understand how they work.\nImagine that the computer, in drawing the ellipse, starts at the end of the first axis on the right side of the ellipse, and draws the ellipse in a clockwise manner, ending back where it started. When drawing a partial ellipse, the computer follows the same path, but holds the (metaphorical) pen above the paper, except where specified by the start and end angles. Between them, startAngle and endAngle specify where on the rim of the ellipse to start drawing the ellipse, and where to end drawing the ellipse.\nEach of these angles takes on a value between 0 and 360, where 0 is the right-side first-axis point, and the others rotate around the ellipse clockwise. !fig-ellipse3 shows the locations for 0, 90, 180, and 270 for our example ellipse.\n\n\n\n\n\n\nFigure 12: Ellipse showing partial drawing angles\n\n\n\n!fig-partialExamples shows nine pictures of an ellipse similar to the one shown above, but drawn as a filled ellipse. Each is labeled with the values for startAngle and endAngle used to create it.\n\n\n\n\n\n\n\n\nstartAngle = 0, endAngle = 360\n\n\n\n\n\n\n\nstartAngle = 0, endAngle = 220\n\n\n\n\n\n\n\nstartAngle = 0, endAngle = 180\n\n\n\n\n\n\n\n\n\nstartAngle = 90, endAngle = 360\n\n\n\n\n\n\n\nstartAngle = 90, endAngle = 220\n\n\n\n\n\n\n\nstartAngle = 90, endAngle = 180\n\n\n\n\n\n\n\n\n\nstartAngle = 135, endAngle = 360\n\n\n\n\n\n\n\nstartAngle = 135, endAngle = 220\n\n\n\n\n\n\n\nstartAngle = 135, endAngle = 180\n\n\n\n\n\n\nFigure 13: Partial ellipses with varying start and end values\n\n\n\nBe prepared to experiment any time you want to use the ellipse function.\nAdding text to images\n\ncv2.putText(img, text, pt, font, fontScale, color, thickness)\n\nOpenCV can draw text on images, though the tools, and fonts, are rather bare-bones. The inputs include the image to draw on, the text to draw, and a point tuple specifying where to draw the text, plus the font, scale of font, text color, and line thickness for the text.\nThe point tuple gives the pixel where the lower-left corner of the text will appear.\nThe font is chosen by selecting from OpenCV’s built-in basic fonts (you are welcome, even encouraged, to explore how to add and access additional fonts on your own). By default, OpenCV includes a subset of the Hershey font family, shown in the table below\n\n\n\n\n\n\n\nFont Name\nDescription\n\n\n\n\ncv2.FONT_HERSHEY_SIMPLEX\nNormal-sized sans-serif font, simple complexity\n\n\ncv2.FONT_HERSHEY_PLAIN\nSmall-sized sans-serif font, simple complexity\n\n\ncv2.FONT_HERSHEY_DUPLEX\nNormal-sized sans-serif font, medium complexity\n\n\ncv2.FONT_HERSHEY_COMPLEX\nNormal-sized serif font, medium complexity\n\n\ncv2.FONT_HERSHEY_TRIPLEX\nNormal-sized serif font, high complexity\n\n\ncv2.FONT_HERSHEY_COMPLEX_SMALL\nSmall-sized version of COMPLEX font\n\n\ncv2.FONT_HERSHEY_SCRIPT_SIMPLEX\nHandwriting font, simple complexity\n\n\ncv2.FONT_HERSHEY_SCRIPT_COMPLEX\nHandwriting font, medium complexity\n\n\n\nThe fontScale input is a floating-point number. It can be set to 1.0 to use the default size. Values greater than 1 will draw the font larger, values between 0.0 and 1.0 will shrink the font, and negative values will draw the text backwards!\n\n\n\nWhen we modify images in Python, the changes are only to the copy of the data that we have loaded into our Python program. They are not saved to the original file we read in. This is probably wise!\nThat said, you might create a beautiful picture and want to save it to a file. You can do that using the imwrite function. Always use a new filename when saving an image to file. Beware! if you use an existing filename in imwrite, you will overwrite the previous contents of that file\n\ncv2.imwrite(filename, image)\n\nYou call imwrite and first give it a path and filename where you want the new image to be saved. Be sure to include the extension, otherwise OpenCV does not know how to format the image data correctly in the file. The second input to imwrite is the image array itself.\n\n\n\nThe script below creates three images, and then illustrates each of the new images from scratch and then illustrates each of the drawing functions; it saves the resulting pictures to two files. It uses two numpy commands: zeros and ones. The zeros function makes an n-dimensional matrix filled entirely with zeros. In this case, we give the dimensions we want (300 rows, 500 columns, 3 channels) and tell it to make the numbers be uint8, the special type we need for 0 to 255 values. The ones function makes a matrix filled with ones. This call has 500 rows, 300 columns, and 3 channels, all filled with uint8. Copy these commands into a script and run it. Note that the imwrite function saves an image to a file. The type of the file is given by the extension on the filename.\n\nimport cv2\n1import numpy as np\n\n2beach = cv2.imread(\"SampleImages/beachBahamas.jpg\")\n3draw1 = np.zeros((300, 500, 3), np.uint8)\n4draw2 = 255 * np.ones((500, 300, 3), np.uint8)\n\n5cv2.circle(beach, (500, 250), 300, (0, 0, 255), -1)\ncv2.circle(beach, (500, 250), 200, (0, 0, 155), -1)\ncv2.circle(beach, (500, 250), 100, (0, 0, 55), -1)\n\n6cv2.rectangle(draw1, (10, 100), (100, 10), (0, 180, 0), -1)\ncv2.ellipse(draw1, (250, 150), (100, 60), 30, 0, 220, (250, 180, 110), -1)\nfont = cv2.FONT_HERSHEY_SIMPLEX\ncv2.putText(draw1, \"Hi, there\", (10, 270), font, 1, (255, 255, 255))\n\n7cv2.line(draw2, (50, 50), (150, 250), (0, 0, 255))\ncv2.circle(draw2, (30, 30), 30, (220, 0, 0), -1)\n\ncv2.imshow(\"Beach\", beach)\ncv2.imshow(\"Black\", draw1)\ncv2.imshow(\"White\", draw2)\n\n8cv2.imwrite(\"blackPic.jpg\", draw1)\ncv2.imwrite(\"whitePic.jpg\", draw2)\n\ncv2.waitKey(0)\n\n\n1\n\nNumpy to create blank images\n\n2\n\nRead in the beach picture\n\n3\n\nCreate a black image 300 pixels tall and 500 pixels wide\n\n4\n\nCreate a white image 300 tall by 500 wide\n\n5\n\nDraw three concentric circles on the beach\n\n6\n\nDraw a rectangle, a partial ellipse, and text on the black image\n\n7\n\nDraw a line and a circle on the white image\n\n8\n\nWrite the new black and white images to files\n\n\n\n\nThe zeros function in Numpy creates an array and fills it with all zeros. We just specify the dimensions of the array (rows, columns, depth), and the type of data to store in the array. Since images use 8-bit unsigned integers to represent color channel values, the special Numpy data type uint8 is what we want. The ones function is similar, except that it creates an array filled with all ones. We can convert the pixels to white by multiplying by 255.\nAfter reading this script, try it out for yourself. Try modifying parts of each command, or add additional commands, until you understand how each function works. Make sure you can draw lines, filled and unfilled rectangles, filled and unfilled circles, filled and unfilled ellipses and arcs, and text, all in different colors."
  },
  {
    "objectID": "Readings/Chapter1.html#reading-and-displaying-images",
    "href": "Readings/Chapter1.html#reading-and-displaying-images",
    "title": "Chapter 1, Getting Started with OpenCV",
    "section": "",
    "text": "1import cv2\n\n2img1 = cv2.imread(\"SampleImages/snowLeo1.jpg\")\n3cv2.imshow(\"Leopard 1\", img1)\n4img2 = cv2.imread(\"SampleImages/snowLeo2.jpg\")\ncv2.imshow(\"Leopard 2\", img2)\n5cv2.waitKey(0)\n\n\n1\n\nLoad the OpenCV module\n\n2\n\nRead in the image from snowLeo1.jpg, assign img1 to hold the image\n\n3\n\nDisplay the image in img1 with title Leopard 1\n\n4\n\nRead snowLeo2ljpg into img2 and display it as Leopard 2\n\n5\n\nWait for the user to hit a key before continuing\n\n\n\n\nNote about paths: In Chapter 0 we discussed the importance of understanding paths in order to write programs that work with files. When we read in an image file, we must specify an absolute or relative path that is correct, as well as spelling the filename correctly. For this to work, you must configure your project so that:\n\nThe SampleImages folder is in your project folder\nThe code file you make is in the same project folder as SampleImages (not inside SampleImages itself!)\n\nThe relative path used in the code above starts from the folder where the code file is, and tells the computer how to navigate from there to where the image file is.\nCopy this program and run it to see what happens. You should see two windows pop up, showing the two snow leopard images (they may appear under other windows). To get the program to finish, click on one of the image windows to make it active, and then hit a key on the keyboard. The window should disappear and PyCharm should be done with the program.\nOpenCV uses the string that is the first input to imshow to identify windows: if you use call imshow again with the same string but a new image, the new image will appear in the same window. To see this, change the string for the second imshow above to be \"Leopard 1\". Then rerun the script. You probably will not see the first image, because it is overwritten so quickly by the second one. To slow things down, copy the waitKey line and put it right after the first call to imshow."
  },
  {
    "objectID": "Readings/Chapter1.html#color-representations",
    "href": "Readings/Chapter1.html#color-representations",
    "title": "Chapter 1, Getting Started with OpenCV",
    "section": "",
    "text": "Colors we perceive in the real world derive from different frequencies of light emitted or reflected off objects in our world, and filtered through our brain’s perception systems. Color theory is an extremely interesting field of study, with contributions from mathematics, physics, biology, art, photography, psychology, and more.\nInside the computer, we must convert color into a discrete, compact representation: a digital representation. There are dozens of ways of representing color digitally, though a few are most common. Below, we will explore several common color representations used to represent images.\n\n\nThe most common representation of colors for images is the RGB (red, green, blue) format. This is because monitors and projectors typically use RGB to display colors to us. If you have ever looked closely at a projector’s output, or looked at a droplet of water on your phone screen, you can see dots of red, green, and blue light very close together (see Figure 1).\n\n\n\n\n\n\nFigure 1: Closeup view of HD LED TV screen (Wikimedia Commons)\n\n\n\nLong ago, pointillist artists discovered that small dots of color close together can fool the human eye into perceiving a different color altogether. Similarly, photographers from the 19th century figure out that they could simulate color photos by layers three copies of a photo together, one tinted with red, one with green, and one with blue. Only later did scientists come to understand how human color vision works, and why these methods work for us.\nIn human eyes, we have three different color receptors, or cones. Each kind responds to a different range of wavelengths, and responds more or less strongly depending on the wavelength (see Figure 2). If we display red, green, and blue light in close proximity, the human eye can be fooled into perceiving a corresponding wavelength of light.\n\n\n\n\n\n\nFigure 2: Wavelength vs Color-detecting cones (Hyperphysics, GSU)\n\n\n\nIn the RGB color representation, we call the three values of red, green, and blue light channels. We represent colors as a collection of three values, one for each channel. A good metaphor for how RGB works is that we have three sliders as shown in Figure 3, one for each channel, and we can move them independently to select a different amount of light. The result is the actual color we are representing.\n\n\n\n\n\n\nFigure 3: A slider for each channel (Dovesystems Scenemaster)\n\n\n\nThe position of the slider indicates how much of that channel’s light we are mixing. Shades of gray occur when all three channels have the same value. Black is the absence of all light, and white is full power to all three channels.\nSliders that control lights typically vary continuously in the positions they can take. However, inside the computer we need things to be discrete, so one question that arose is: how many different values do we need for each channel to get photorealistic images? If each slider was actually a light switch, it would have just two positions: on and off. We can represent these as 1 and 0. The table below shows all the combinations of the three switches, and the colors they correspond to.\n\n\n\nR\nG\nB\nColor\n\n\n\n\n0\n0\n0\nBlack\n\n\n0\n0\n1\nBlue\n\n\n0\n1\n0\nGreen\n\n\n1\n0\n0\nRed\n\n\n0\n1\n1\nCyan\n\n\n1\n0\n1\nMagenta\n\n\n1\n1\n0\nYellow\n\n\n1\n1\n1\nWhite\n\n\n\nObviously, we want more than just two values per channel, but this representation only requires three bits of information inside the computer.\nSide note on binary representations: All data inside a computer is ultimately represented in binary, as a sequence of ones and zeros, because computers use the presence or absence of electricity in a wire, or the direction of a magnetic field, to represent data. A bit is the smallest unit of information: zero or one, (yes/no, true/false, on/off). Modern computers almost all use a collection of 8 bits as the smallest useful unit of data: this is called a byte (4 bits is called a nibble, computer scientists like puns!). When we are choosing how to represent data, sometimes we must consider how many bytes that data will take up.\nThere is an important relationship between the number of bits in a representation, and how many distinct patterns or values we can represent. If we have \\(k\\) bits in our binary representation, then we can represent \\(2^k\\) distinct values. Above, we had 3 bits per color: there were \\(2^3 = 8\\) binary patterns, corresponding to eight distinct colors.\nRepresenting colors by their frequencies or wavelengths might need an 8-byte floating-point number. Representations based on multiple channels, each holding integers, can be more efficient.\nThe typical representation for RGB channels provides one byte (8 bits) for each channel, for a total of 3 bytes to represent a color. According to the rule above, each channel can represent \\(2^8 = 256\\) distinct values: 00000000, 00000001, 0000010, … 11111110, 11111111. We use nonnegative integer values starting with zero; we call this kind of number an unsigned integer. In the case of color channel values, we use the integers from 0 to 255. The total number of distinct colors we can create with this representation is \\(2^{24} = 16,777,216\\), more than 16 million distinct colors!\nWe represent a color as a collection of three 8-bit unsigned integer values, one for each channel.\nThere are many online “color pickers” that let us generate colors, and shows us the color representations in different formats. Explore the color picker at HTML Color Codes. Because this is designed for choosing web colors, it shows each color in a Hex representation, in RGB, and in HSL. The Hex representation is used on websites and other applications for colors: it is actually the RGB color values, rewritten into hexadecimal (base 16) notation (to see this, click on a color close to black, where the values will be close to zero). Notice that the RGB values are always in the range from 0 to 255.\nHSL stands for “hue, saturation, lightness” and is a very different color representation than RGB. We will not use HSL, but it is closely related to a color representation called HSV, which we will use when using color to segment images or track objects. (See HSL and HSV, Wikipedia for more details about how HSL and HSV relate.)\nOpenCV in Python chooses to represent RGB colors backwards, as BGR. That means that a color is a tuple containing three numbers: blue channel, green channel, red channel. A tuple is like a list, but can’t be modified. The numbers in the tuple must be integers between 0 and 255. For instance, Figure 4 shows three colors and their BGR representations in OpenCV\n\n\n\n\n\n\n\n\n(0, 0, 0) black\n\n\n\n\n\n\n\n(255, 0, 0) blue\n\n\n\n\n\n\n\n(0, 180, 180) green-yellow\n\n\n\n\n\n\nFigure 4: Colors and their representations in OpenCV\n\n\n\n\n\n\nThere are many other color representations that we could use. As mentioned before, one used for color-based algorithms is called HSV (hue, saturation, value). In HSV, the basic color is defined by single channel value, the hue. Hue values are interpreted as degrees around a circle: 0 to 359. The other two channel values are thought of as percentages, often in the range from 0 to 100.\nThe saturation channel describes how “pure” or intense the color is: one way to think of saturation is how mixed with white the color is: high saturation values have little mixture with white, low saturation are strongly mixed with white. The value channel captures the brightness of the image: you can think of it as changing values appear mixed with white or gray. The value defines the color’s brightness, changing the shade of gray that we mix into the saturation: low values cause the hue to be mixed with dark gray or black, high values mix with light gray or white. The colorizer color picker, while more clumsy to use, does include HSV as one of its options (also called HSB). Figure 5 shows the mapping of hue values to degrees in HSV.\n\n\n\n\n\n\nFigure 5: HSV hue values, using the range from 0 to 360\n\n\n\nHSV is useful for color-tracking in images, because the hue changes relatively little when the brightness of the light changes, whereas all three channels in an RGB image change when the brightness changes.\nOpenCV represents HSV values as a tuple of three 8-bit unsigned integers, much like RGB. That means the values are limited to the range from 0 to 255. How does that work when the usual ranges of HSV values are 0-360, 0-100, and 0-100?\n\nThe hue channel in OpenCV uses the range from 0 to 179, dividing the HSV degrees in half. Thus, a midgreen value in Figure 5 above normally has value 120: in OpenCV we use 60 for this hue instead.\nThe saturation and value channels normally runs from 0 to 100. OpenCV rescales them to range from 0 to 255. To convert a “global” saturation level to OpenCV, use this formula: \\(s_{opencv} = \\frac{s_{global}}{100} \\cdot 255\\).\n\nOn beyond HSV\nThere are many additional color representations, each with its own strengths and uses. As one example, the YUV color representation has three channels: YUV. The Y channel contains brightness or “luminance” information, and the U and V channels together describe the color. We use this color representation for balancing the brightness of an image, by converting to this format, modifying the Y channel, and then converting back to BGR for display/use. The YUV Colorspace web page gives some nice visuals showing how this representation works."
  },
  {
    "objectID": "Readings/Chapter1.html#image-representation",
    "href": "Readings/Chapter1.html#image-representation",
    "title": "Chapter 1, Getting Started with OpenCV",
    "section": "",
    "text": "Given a specific color representation, we now have to figure out how to represent a whole image. We want to distinguish between how an image might be represented when stored as a file, and how it might be represented when read into a program. In both cases, multiple representations are possible, though for our purposes we don’t need to know the details of different file representations, and we will focus on OpenCV’s method for representing images.\nWhen an image is stored in a file, the file format often keeps the image’s data in a compressed form, saving space. The exact format and kind of compression used is signaled by the file extension (.jpg, .png, .gif, etc.). OpenCV can work with many file formats, but the extension must match the actual contents for any program to be able to read or display an image. Don’t just change the extension: that will just make the file unreadable. You have to use a program to convert from one representation of an image to another, if needed.\nOnce an image is read into a program to be manipulated, however, the image representation is very different from that in a file, and images are represented the same way, whether they originated in a jpg or png or any other file format. Different programming tools use slightly different representations for images, but all share certain key features:\n\nAn image is a grid of pixels (short for picture elements)\nEach pixel contains a single color\nWe interpret the horizontal dimension of the grid as the x dimension, with 0 at the left, increasing to the right\nWe interpret the vertical dimension of the grid as the y dimension, with 0 at the top, increasing downward\nLocations for specific pixels are given as (x, y) coordinates\n\nFigure 6 shows a tiny, 6 pixel by 6 pixel image, with x and y dimensions and indices given. The blue pixel representing the right eye is at (4, 1).\n\n\n\n\n\n\nFigure 6: Tiny 6x6 image with x and y dimensions and valid x and y indices\n\n\n\nNote that a pixel is not a unit of measurement. While image files often store a mapping between numbers of pixels and distance, such as ppi (pixels per inch), that is not an intrinsic property of the images. A pixel is simply the smallest unit of an image. When the pixels are drawn small enough, we don’t notice the individual pixels, and instead see the whole picture. #fig-showPixels shows the “Mighty Midway” picture from SampleImages, and then a portion of the picture, zoomed in far enough to see the individual pixels. The original picture is 1000 pixels wide by 667 pixels tall.\n\n\n\n\n\n\n\n\nmightyMidway.jpg\n\n\n\n\n\n\n\nZoomed-in view\n\n\n\n\n\n\nFigure 7: The mightyMidway.jpg image, and a section zoomed in to show pixels\n\n\n\nGrayscale versus color images\nThere are three variations on images: color, grayscale, and black-and-white. We have discussed color images and how color might be represented already. Grayscale images contain only shades of gray between black and white. As we noted earlier, shades of gray correspond to the RGB channels holding equal values: (195, 195, 195) is a medium bright shade of gray. Black-and-white images contain only black pixels and white pixels, no shades of gray in between.\nBecause a grayscale image has equal channel values, we only need to represent one copy, the luminance or brightness (for the gray shade above, just one 195 is needed). OpenCV represents grayscale images as a two-dimensional array, or matrix, of numbers. In Figure 8 a small example of a grayscale image is shown on the left, with\nColor images, however, have more data per pixel, and generally use 2-4 numbers to represent each color. In OpenCV, we represent this by using a three-dimensional matrix: the first dimension is x, the second dimension is y, and the third dimension is for the channels. Figure 8 illustrates the structure of an OpenCV color image.\n\n\n\n\n\n\nFigure 8: Grayscale and color image matrix structures\n\n\n\nImages in OpenCV are represented using Numpy arrays: we will return to this subject later when we look more closely at the Numpy module and the tools we may use to manipulate image arrays."
  },
  {
    "objectID": "Readings/Chapter1.html#drawing-with-opencv",
    "href": "Readings/Chapter1.html#drawing-with-opencv",
    "title": "Chapter 1, Getting Started with OpenCV",
    "section": "",
    "text": "OpenCV provides a set of tools that allow you to draw shapes on images. We can also make blank images to serve as “canvases” for our drawings. In this section we will explore the different drawing functions OpenCV provides, and you will also learn how to save an image to a file, so you can store the results.\n\n\nIn this section we will introduce the basic drawing commands, and their basic inputs. You can find more commands and more details in the Drawing Functions page of the OpenCV documentation; each function has more optional inputs than are given here.\nIn each example below we will use the same set of variables as is used in the documentation:\n\nimg is a typical OpenCV image, a Numpy array\npt, pt1, and pt2 are all points, tuples containing x and y indices into the image\ncolor is a color, a tuple containing blue, green, and red values\nthickness is line thickness, how wide to draw the lines, and if negative then the shape is drawn “filled-in”\nangle, startAngle, and endAngle are all angles, typically between 0 and 360, though other angles may be permitted\n\nNote: Drawing or making other changes to an image does not automatically update the image displayed previously by a call to imshow. You must call imshow again to see the changes.\nDrawing lines\n\ncv2.line(img, pt1, pt2, color, thickness)\n\nThe line function takes in an image to draw on, two (x, y) coordinate points, input as tuples, and a color (given as a BGR tuple). The thickness input is optional, but is often used to tell how many pixels wide the line should be. If you do not specify thickness the line is drawn as one pixel wide. The function draws a line as specified between the two coordinate points.\nDrawing rectangles\n\ncv2.rectangle(img, pt1, pt2, color, thickness)\n\nThe rectangle function takes in an image to draw on, and two (x, y) coordinate points, as tuples. Typically, we also specify the color tuple and line thickness. The two points specify two opposite corner pixels of the rectangle to draw (for instance, upper-left and lower-right corners). If the line thickness is 1 or greater, then a line rectangle is drawn with the given corner points, line color, and line thickness. If the line thickness is negative then a filled in rectangle with the given corners and color is drawn.\nDrawing circles\n\ncv2.circle(img, pt, radius, color, thickness) \n\nThe circle function takes in the image to draw on, the center point of the circle (a pixel location as an (x, y) tuple), an integer radius for the circle, and a color tuple. Line thickness is optional, and works the same as for rectangles: positive specifies line thickness, negative draws a filled-in circle.\nDrawing ellipses\n\ncv2.ellipse(img, pt, axes, angle, startAngle, endAngle, color, thickness)\n\nDrawing ellipses (ovals) is the most complicated of the functions we will look at, because the function not only draws ellipses but also arcs and partial ellipses, both line and filled. Therefore, we will go into more details about what each input parameter does.\nTo take the easy ones first, img is the image to draw on, pt is the center point as (x, y) coordinates (if you like mathy details, pt is the center point of the circle that circumscribes this ellipse, as ellipses are usually defined by two points). The color and thickness inputs work just as for the other drawing commands.\nFor the remaining inputs, we will illustrate them with a specific example, shown below.\n\nimport cv2\n\nbeachIm = cv2.imread('SampleImages/beachBahamas.jpg')\n1cv2.ellipse(beachIm,\n2            (500, 250),\n3            (70, 150),\n4            45,\n5            0,\n6            360,\n7            (0, 255, 255),\n8            2)\ncv2.imshow(\"Beach\", beachIm)\ncv2.waitKey()\n\n\n1\n\nimg, the value of beachIm\n\n2\n\npt, a tuple holding the (x, y) center point\n\n3\n\naxes, a tuple holding sizes of ellipse’s axes\n\n4\n\nangle, an integer angle, rotated from the horizontal\n\n5\n\nstartAngle, an integer angle, where to start drawing ellipse arc/wedge\n\n6\n\nendAngle, an integer angle, where to stop drawing ellipse arc/wedge\n\n7\n\ncolor, the color for the ellipse\n\n8\n\nthickness, line thickness or to make ellipse filled\n\n\n\n\nThis program produces the ellipse shown in @figure-ellipse0.\n\n\n\n\n\n\nFigure 9: Ellipse drawn by code\n\n\n\nThe axes input specifies the width and height of the ellipse in the form (r1, r2). To interpret these, first think of the ellipse as being unrotated. Then its first axis is horizontal, and the second axis is vertical. The r1 value is one-half the length of the first axis, and r2 is one-half the length of the second axis. Figure 10 show the (x, y) center point, and the length and meaning of the axes tuple (r1, r2).\n\n\n\n\n\n\nFigure 10: Ellipse with center point (x, y) and axes (r1, r2) drawn on\n\n\n\nIn this code example, the total width of the ellipse along its first axis is 140 pixels, and the total height of the ellipse along its second axis is 300 pixels.\nThe angle input specifies how far to rotate the ellipse in the clockwise direction from a start where its first axis is horizontal. Another way to think about it is that angle is the angle between the horizontal and the first axis. You can pass negative angles here, to get counter-clockwise rotations. Figure 11 Shows how angle is determined for our example.\n\n\n\n\n\n\nFigure 11: Ellipse with rotation angle marked\n\n\n\nThe last two inputs to discuss are startAngle and endAngle. We will start with a simple rule: when in doubt, set startAngle to 0 and endAngle to 360. This will draw the full ellipse.\nYou only need to vary startAngle and endAngle if you want to draw just a portion of the outline of the ellipse, or a wedge of the filled-in ellipse. In those cases, you need to understand how they work.\nImagine that the computer, in drawing the ellipse, starts at the end of the first axis on the right side of the ellipse, and draws the ellipse in a clockwise manner, ending back where it started. When drawing a partial ellipse, the computer follows the same path, but holds the (metaphorical) pen above the paper, except where specified by the start and end angles. Between them, startAngle and endAngle specify where on the rim of the ellipse to start drawing the ellipse, and where to end drawing the ellipse.\nEach of these angles takes on a value between 0 and 360, where 0 is the right-side first-axis point, and the others rotate around the ellipse clockwise. !fig-ellipse3 shows the locations for 0, 90, 180, and 270 for our example ellipse.\n\n\n\n\n\n\nFigure 12: Ellipse showing partial drawing angles\n\n\n\n!fig-partialExamples shows nine pictures of an ellipse similar to the one shown above, but drawn as a filled ellipse. Each is labeled with the values for startAngle and endAngle used to create it.\n\n\n\n\n\n\n\n\nstartAngle = 0, endAngle = 360\n\n\n\n\n\n\n\nstartAngle = 0, endAngle = 220\n\n\n\n\n\n\n\nstartAngle = 0, endAngle = 180\n\n\n\n\n\n\n\n\n\nstartAngle = 90, endAngle = 360\n\n\n\n\n\n\n\nstartAngle = 90, endAngle = 220\n\n\n\n\n\n\n\nstartAngle = 90, endAngle = 180\n\n\n\n\n\n\n\n\n\nstartAngle = 135, endAngle = 360\n\n\n\n\n\n\n\nstartAngle = 135, endAngle = 220\n\n\n\n\n\n\n\nstartAngle = 135, endAngle = 180\n\n\n\n\n\n\nFigure 13: Partial ellipses with varying start and end values\n\n\n\nBe prepared to experiment any time you want to use the ellipse function.\nAdding text to images\n\ncv2.putText(img, text, pt, font, fontScale, color, thickness)\n\nOpenCV can draw text on images, though the tools, and fonts, are rather bare-bones. The inputs include the image to draw on, the text to draw, and a point tuple specifying where to draw the text, plus the font, scale of font, text color, and line thickness for the text.\nThe point tuple gives the pixel where the lower-left corner of the text will appear.\nThe font is chosen by selecting from OpenCV’s built-in basic fonts (you are welcome, even encouraged, to explore how to add and access additional fonts on your own). By default, OpenCV includes a subset of the Hershey font family, shown in the table below\n\n\n\n\n\n\n\nFont Name\nDescription\n\n\n\n\ncv2.FONT_HERSHEY_SIMPLEX\nNormal-sized sans-serif font, simple complexity\n\n\ncv2.FONT_HERSHEY_PLAIN\nSmall-sized sans-serif font, simple complexity\n\n\ncv2.FONT_HERSHEY_DUPLEX\nNormal-sized sans-serif font, medium complexity\n\n\ncv2.FONT_HERSHEY_COMPLEX\nNormal-sized serif font, medium complexity\n\n\ncv2.FONT_HERSHEY_TRIPLEX\nNormal-sized serif font, high complexity\n\n\ncv2.FONT_HERSHEY_COMPLEX_SMALL\nSmall-sized version of COMPLEX font\n\n\ncv2.FONT_HERSHEY_SCRIPT_SIMPLEX\nHandwriting font, simple complexity\n\n\ncv2.FONT_HERSHEY_SCRIPT_COMPLEX\nHandwriting font, medium complexity\n\n\n\nThe fontScale input is a floating-point number. It can be set to 1.0 to use the default size. Values greater than 1 will draw the font larger, values between 0.0 and 1.0 will shrink the font, and negative values will draw the text backwards!\n\n\n\nWhen we modify images in Python, the changes are only to the copy of the data that we have loaded into our Python program. They are not saved to the original file we read in. This is probably wise!\nThat said, you might create a beautiful picture and want to save it to a file. You can do that using the imwrite function. Always use a new filename when saving an image to file. Beware! if you use an existing filename in imwrite, you will overwrite the previous contents of that file\n\ncv2.imwrite(filename, image)\n\nYou call imwrite and first give it a path and filename where you want the new image to be saved. Be sure to include the extension, otherwise OpenCV does not know how to format the image data correctly in the file. The second input to imwrite is the image array itself.\n\n\n\nThe script below creates three images, and then illustrates each of the new images from scratch and then illustrates each of the drawing functions; it saves the resulting pictures to two files. It uses two numpy commands: zeros and ones. The zeros function makes an n-dimensional matrix filled entirely with zeros. In this case, we give the dimensions we want (300 rows, 500 columns, 3 channels) and tell it to make the numbers be uint8, the special type we need for 0 to 255 values. The ones function makes a matrix filled with ones. This call has 500 rows, 300 columns, and 3 channels, all filled with uint8. Copy these commands into a script and run it. Note that the imwrite function saves an image to a file. The type of the file is given by the extension on the filename.\n\nimport cv2\n1import numpy as np\n\n2beach = cv2.imread(\"SampleImages/beachBahamas.jpg\")\n3draw1 = np.zeros((300, 500, 3), np.uint8)\n4draw2 = 255 * np.ones((500, 300, 3), np.uint8)\n\n5cv2.circle(beach, (500, 250), 300, (0, 0, 255), -1)\ncv2.circle(beach, (500, 250), 200, (0, 0, 155), -1)\ncv2.circle(beach, (500, 250), 100, (0, 0, 55), -1)\n\n6cv2.rectangle(draw1, (10, 100), (100, 10), (0, 180, 0), -1)\ncv2.ellipse(draw1, (250, 150), (100, 60), 30, 0, 220, (250, 180, 110), -1)\nfont = cv2.FONT_HERSHEY_SIMPLEX\ncv2.putText(draw1, \"Hi, there\", (10, 270), font, 1, (255, 255, 255))\n\n7cv2.line(draw2, (50, 50), (150, 250), (0, 0, 255))\ncv2.circle(draw2, (30, 30), 30, (220, 0, 0), -1)\n\ncv2.imshow(\"Beach\", beach)\ncv2.imshow(\"Black\", draw1)\ncv2.imshow(\"White\", draw2)\n\n8cv2.imwrite(\"blackPic.jpg\", draw1)\ncv2.imwrite(\"whitePic.jpg\", draw2)\n\ncv2.waitKey(0)\n\n\n1\n\nNumpy to create blank images\n\n2\n\nRead in the beach picture\n\n3\n\nCreate a black image 300 pixels tall and 500 pixels wide\n\n4\n\nCreate a white image 300 tall by 500 wide\n\n5\n\nDraw three concentric circles on the beach\n\n6\n\nDraw a rectangle, a partial ellipse, and text on the black image\n\n7\n\nDraw a line and a circle on the white image\n\n8\n\nWrite the new black and white images to files\n\n\n\n\nThe zeros function in Numpy creates an array and fills it with all zeros. We just specify the dimensions of the array (rows, columns, depth), and the type of data to store in the array. Since images use 8-bit unsigned integers to represent color channel values, the special Numpy data type uint8 is what we want. The ones function is similar, except that it creates an array filled with all ones. We can convert the pixels to white by multiplying by 255.\nAfter reading this script, try it out for yourself. Try modifying parts of each command, or add additional commands, until you understand how each function works. Make sure you can draw lines, filled and unfilled rectangles, filled and unfilled circles, filled and unfilled ellipses and arcs, and text, all in different colors."
  },
  {
    "objectID": "Readings/Chapter4.html",
    "href": "Readings/Chapter4.html",
    "title": "Chapter 4, Masks and Thresholds",
    "section": "",
    "text": "In this chapter, we will examine several approaches for transforming images: taking in an image, and producing a new, changed image. First we will examine the process of masking an image, using a black-and-white image to determine which pixels to keep in an image. And then we will look at several methods for building threshold images, which are typically grayscale or black-and-white, and which separate pixels with certain properties from pixels that lack those properties."
  },
  {
    "objectID": "Readings/Chapter4.html#three-channel-versus-one-channel-masks",
    "href": "Readings/Chapter4.html#three-channel-versus-one-channel-masks",
    "title": "Chapter 4, Masks and Thresholds",
    "section": "1.1 Three-channel versus one-channel masks",
    "text": "1.1 Three-channel versus one-channel masks\nThe mask image above was created as a color image, with three channels. If the only colors in a mask are white or black, we don’t really need all three channels. However, when we have a one-channel mask, applying it to the image is a little bit different.\nThe script below demonstrates several ideas:\n\nHow to apply a mask to frames of a video feed\nHow to apply a one-channel mask to a color image\nHow to make a square bounce around a window\n\nWe’ll discuss each of these ideas as they appear in the code below. Be sure to read the annotations on the lines of code before continuing.\n\nvidCap = cv2.VideoCapture(0)\n\n1sqrX = 50\nsqrY = 50\ndeltaX = 5\ndeltaY = 5\nsqSize = 400\n\nwhile True:\n    res, frame = vidCap.read()\n2    (hgt, wid, dep)= frame.shape\n    \n3    # make mask a grayscale image (one channel)\n    maskIm = np.zeros((hgt, wid), np.uint8)\n    cv2.rectangle(maskIm, (sqrX, sqrY), (sqrX + sqSize, sqrY + sqSize), 255, -1)\n    \n4    maskedFrame = cv2.bitwise_and(frame, frame, mask=maskIm)\n    \n5    cv2.imshow(\"Moving Mask\", maskedFrame)\n    x = cv2.waitKey(10)\n    if x &gt; 0:\n        if chr(x) == 'q':\n            break\n    \n6    if (sqrX + sqSize &gt;= wid) or (sqrX &lt;= 0):\n        deltaX = -deltaX\n    if (sqrY + sqSize &gt;= hgt) or (sqrY &lt;= 0):\n        deltaY = -deltaY\n    \n7    sqrX += deltaX\n    sqrY += deltaY\n\nvidCap.release()\n\n\n1\n\nSets up variables to hold the size and position of the mask square, and how fast it will change from one frame to the other\n\n2\n\nGets the shape of the frame into hgt and wid variables, so we can make a one-channel mask\n\n3\n\nCreates the mask and draws a white square on it\n\n4\n\nApplies the mask to the frame from the camera feed (or video file), using the mask input\n\n5\n\nDisplays the result\n\n6\n\nChanges deltaX and/or deltaY if the square gets to any of the four edges of the picture; causes the square to change the direction it moves\n\n7\n\nUpdates the position of the square for the next frame, by adding deltaX to sqrX and deltaY to sqrY\n\n\n\n\nThe first part of the while loop creates the mask with one white square, and applies it to the original image. To understand how one-channel masks can be applied to an image, focus on line 17. We cannot just call bitwise_and and pass it the original frame and the mask, because bitwise_and requires that the two images passed to it are the same shape. However, bitwise_and takes an optional input called mask, which specifies a one-channel mask, which is applied to the result of the bitwise-and operation. So we pass the original frame in for both ordinary inputs (bitwise-and applied to two identical images produces the image itself again). And then the mask gets applied in a separate step. This is cryptic and weird, but it works!\nThe last idea in this code, making a shape bounce around a window, is just for fun, and to emphasize that for each frame in the video feed, we compute and apply a new mask. The key to moving the square is just to change the position of its upper left (x, y) coordinates, which is done at the end of the while loop. To keep the square from just moving out of view, we need to make it bounce back. This sounds daunting, but is actually easy.\n\nIf the right edge of the square reaches or exceeds the right edge of the image, then we change the deltaX value to be its negative (it will have been +5, after this it will be -5)\nIf the left edge of the square reaches or exceeds the left edge of the image, then we change deltaX to be its negative (it will have been -5, –5 = +5)\nSimilar logic for the top and bottom edges\n\nTry this code for yourself. To fully understand this code, you should experiment with changing the accumulator variables (one at a time) that control the position, size, and movement speed of the square. Or change the rectangle to a circle or an ellipse."
  },
  {
    "objectID": "Readings/Chapter4.html#masks-built-from-image-features",
    "href": "Readings/Chapter4.html#masks-built-from-image-features",
    "title": "Chapter 4, Masks and Thresholds",
    "section": "1.2 Masks built from image features",
    "text": "1.2 Masks built from image features\nBesides building masks as we have done here, by drawing white shapes on a black image, we can also generate mask images using other image transformations, so that the pixels that are white fit some pattern or criteria. Later in this chapter, we will look at a common way to create these masks: computing threshold images."
  },
  {
    "objectID": "Readings/Chapter4.html#the-threshold-function",
    "href": "Readings/Chapter4.html#the-threshold-function",
    "title": "Chapter 4, Masks and Thresholds",
    "section": "3.1 The threshold function",
    "text": "3.1 The threshold function\nThe simplest threshold function is called just threshold. It operates on grayscale images, and has multiple modes to choose from. It returns a new grayscale or black and white image.\nThe threshold function takes in four inputs and returns two results. The four inputs include: a source image, a threshold value (between 0 and 255), a maximum value (also between 0 and 255), and a constant that defines which threshold variant to perform. Table 1 shows the five main variants for this function.\n\n\n\nTable 1: Five main threshold modes, which create different results, binary thresholding is most common\n\n\n\n\n\n\n\n\n\nThreshold mode\nMeaning\n\n\n\n\ncv2.THRESH_BINARY\nValues above the threshold are set to the maximum value, values less than or equal to the threshold are set to zero\n\n\ncv2.THRESH_BINARY_INV\nValues above the threshold are set to zero, values less than or equal to the threshold are set to the maximum value\n\n\ncv2.THRESH_TRUNC\nValues above the threshold are set to the threshold value, values less than or equal to the threshold are unchanged\n\n\ncv2.THRESH_TOZERO\nValues above the threshold are left unchanged, values less than or equal to the threshold are set to zero\n\n\ncv2.THRESH_TOZERO_INV\nValues above the threshold are set to zero, values less than or equal to the threshold are left unchanged\n\n\n\n\n\n\nThe threshold function returns two values. The first returned value is the threshold value. This may seem odd, but the function has optional add-ons that use particular algorithms to guess at the most useful threshold value. In those cases, we do want the function to tell us the value the algorithm chose. The second returned value is the threshold image itself.\nThe script below illustrates the threshold function, in all its main variants, on a picture of coins on a red background (found in the Coins folder inside SampleImages). Figure 5 shows the original image, its grayscale counterpart, and then all the five variants.\n\ncoinImg = cv2.imread(\"SampleImages/Coins/coins6.jpg\")\ngrayCoin = cv2.cvtColor(coinImg, cv2.COLOR_BGR2GRAY)\n\ncv2.imshow(\"Original\", coinImg)\ncv2.imshow(\"Gray\", grayCoin)\ncv2.waitKey()\n\nthreshModes = [cv2.THRESH_BINARY, cv2.THRESH_BINARY_INV, cv2.THRESH_TRUNC, cv2.THRESH_TOZERO, cv2.THRESH_TOZERO_INV]\nfor threshMode in threshModes:\n    res, threshIm = cv2.threshold(grayCoin, 128, 255, threshMode)\n    cv2.imshow(\"Threshed\", threshIm)\n    cv2.waitKey()\n\n\n\n\n\n\n\n\n\nOriginal image\n\n\n\n\n\n\n\nGrayscale version\n\n\n\n\n\n\n\n\n\nResult of threshold with THRESH_BINARY mode\n\n\n\n\n\n\n\nResult of threshold with THRESH_BINARY_INV mode\n\n\n\n\n\n\n\n\n\nResult of threshold with THRESH_TRUNC mode\n\n\n\n\n\n\n\nResult of threshold with THRESH_TOZERO mode\n\n\n\n\n\n\n\n\n\nResult of threshold with THRESH_TOZERO_INV mode\n\n\n\n\n\n\nFigure 5: Showing the main variants of the threshold function, all run with threshold value of 128 and max value of 255\n\n\n\nOne issue with thresholdis determining what the best threshold value is. Algorithms exist that can identify good threshold values for you, and two of them are integrated into the threshold function. The OTSU and Triangle algorithms both build a histogram of the brightness values in a grayscale image. The OTSU algorithm looks for a threshold value that minimizes the variance on each side of the threshold in the histogram. The Triangle algorithm draws a line between the maximum histogram and the minimum one, and finds the point along that line that is maximal distance from values in the histogram, and uses that as the threshold value. (For more information about both algorithms, see OTSU’s Wikipedia page, or David Landup’s blog on StackAbuse.com).\nBelow is a variation on the code above that shows how to use OTSU or Triangle, combining it with the binary threshold mode. Figure 6 illustrates the results on the coins pictures of each of these algorithms. Note that when we use these algorithms, threshold ignores the input threshold value, and computes its own. It then returns the computed threshold value as its return value.\n\ncoinImg = cv2.imread(\"SampleImages/Coins/coins6.jpg\")\ngrayCoin = cv2.cvtColor(coinImg, cv2.COLOR_BGR2GRAY)\n\n# Adaptive threshold with OTSU and Triangle algorithms\nadaptMode1 = cv2.THRESH_BINARY + cv2.THRESH_OTSU\nadaptMode2 = cv2.THRESH_BINARY + cv2.THRESH_TRIANGLE\nfor tm in [adaptMode1, adaptMode2]:\n    res, threshIm = cv2.threshold(grayCoin, 128, 255, tm)\n    print(res)\n    cv2.imshow(\"Threshed\", threshIm)\n    cv2.waitKey()\n\n\n\n\n\n\n\n\n\nResult of threshold with THRESH_BINARY + THRESH_OTSU mode, chose threshold value of 161\n\n\n\n\n\n\n\nResult of threshold with THRESH_BINARY + THRESH_TRIANBLE mode, chose threshold value of 105\n\n\n\n\n\n\nFigure 6: Showing the two adaptive modes for the threshold function, usually added to the binary or to-zero threshold modes.\n\n\n\nThink about this: Of all of these approaches, which work best on this picture? Experiment with this code, trying it on the other coin pictures in SampleImages. Does the same version or the same threshold, work for all pictures?"
  },
  {
    "objectID": "Readings/Chapter4.html#adaptive-threshold",
    "href": "Readings/Chapter4.html#adaptive-threshold",
    "title": "Chapter 4, Masks and Thresholds",
    "section": "3.2 Adaptive threshold",
    "text": "3.2 Adaptive threshold\nThe adaptiveThreshold function takes things a step further. Rather than just determining one global threshold value, it throws out the idea of a global threshold value altogether. Instead, it computes an individual threshold value at each small patch in the image (this is really a form of filtering, which is the next main subject in this chapter!).\nThe function does the same operation on every overlapping patch in the image. It computes either a plain average or a weighted average of the brightness values in the patch, and subtracts a constant c that we provide. This value is the threshold value for the center pixel of the patch. thus different parts of the image may have very different threshold values.\nAn input constant selects whether to do a plain average or a Gaussian one. We typically describe an ordinary average as adding up the values in the patch and dividing by the number of values. But we can also think of it as multiplying every value in the patch by one over the number of values (if there are \\(n\\) pixels in a patch, by \\(1/n\\), and then adding up the results. A Gaussian average is also computed by multiplying every value in the patch by a weight value and then adding the results. However, instead of using the same weight at every position, we choose weights so that they (1) add up to 1.0, and (2) form a Gaussian curve (also called a Normal curve, or a bell curve.). Figure 7 depicts a typical two-dimensional Gaussian curve. This weights values at the middle of the patch highest, and those at the edge of the patch lowest, in a systematic way.\n\n\n\n\n\n\nFigure 7: Two-dimensional Gaussian curve\n\n\n\nThe adaptiveThreshold function takes six (6!) inputs, outlined below:\n\nThe grayscale image to be processed\nThe maximum value for the thresholding mode\nThe adaptive effect, one of cv2.ADAPTIVE_THRESH_MEAN_C or cv2.ADAPTIVE_THRESH_GAUSSIAN_C (see discussion above)\nThe threshold mode, same ones as the threshold function takes\nThe size in pixels of the patch to use (use an odd number so that there is always a center pixel)\nThe value of c, a constant that will be subtracted from the average that is computed to produce the threshold value\n\nThe code example below loops over different values for the patch size (called bSize because patches are called blocks), and different values for the c constant. We often have to experiment to find the right combination of these values to get the result we want.\n\nfor bSize in [3, 5, 7, 11]:\n    for c in [2, 5, 10, 20]:\n        adaIm1 = cv2.adaptiveThreshold(grayCoin, \n                                       255, \n                                       cv2.ADAPTIVE_THRESH_MEAN_C, \n                                       cv2.THRESH_BINARY,\n                                       bSize,\n                                       c)\n        adaIm2 = cv2.adaptiveThreshold(grayCoin,\n                                       255, \n                                       cv2.ADAPTIVE_THRESH_GAUSSIAN_C, \n                                       cv2.THRESH_BINARY,\n                                       bSize,\n                                       c)\n        print(bSize, c)\n        cv2.imshow(\"Adaptive Mean_C\", adaIm1)\n        cv2.imshow(\"Adaptive Gauss_C\", adaIm2)\n        cv2.waitKey()\n\n\nNotice how the calls to adaptiveThreshold are formatted, with one input per line. This is a common Python style: if the arguments to a function run too far to the right, rather than just breaking them up wherever, we put one per line, and line them up under the start of the first input.\n\nFigure 8 shows pairs of values, one for the mean, and one for the Gaussian average, for different values of bSize and c.\n\n\n\n\n\n\n\n\nMean, bSize = 3, c = 2\n\n\n\n\n\n\n\nGauss, bSize = 3, c = 2\n\n\n\n\n\n\n\nMean, bSize = 3, c = 5\n\n\n\n\n\n\n\nGauss, bSize = 3, c = 5\n\n\n\n\n\n\n\n\n\nMean, bSize = 7, c == 2\n\n\n\n\n\n\n\nGauss, bSize = 7, c = 2\n\n\n\n\n\n\n\nMean, bSize = 7, c = 5\n\n\n\n\n\n\n\nGauss, bSize = 7, c = 5\n\n\n\n\n\n\n\n\n\nMean, bSize = 11, c = 5\n\n\n\n\n\n\n\nGauss, bSize = 11, c = 5\n\n\n\n\n\n\n\nMean, bSize = 11, c = 10\n\n\n\n\n\n\n\nGauss, bSize = 11, c = 10\n\n\n\n\n\n\nFigure 8: Showing the varying results for adaptiveThreshold given different averaging and values of bSize and x"
  },
  {
    "objectID": "Readings/Chapter4.html#making-a-reference-image-or-roi",
    "href": "Readings/Chapter4.html#making-a-reference-image-or-roi",
    "title": "Chapter 4, Masks and Thresholds",
    "section": "5.1 Making a reference image or ROI",
    "text": "5.1 Making a reference image or ROI\nTo build a histogram that represent the color(s) we want to match, we need a reference image that contains the colors of the object we want to detect, and no other colors. How can we make such a reference image?\nThere are two main methods for making a simple reference image. One just uses your operating system’s tools, and the other works within Python and OpenCV.\nUsing the operating system:\n\nOutside of OpenCV/Python, take a picture of the object in question (On the Mac, you could use Photobooth, on Windows, use the Camera app).\nOpen the image in the system’s default image viewer (Preview on the Mac, Photos on Windows).\nUse the application’s tool to crop the image so all remaining pixels are part of the object (no background or extraneous objects)\nSave the resulting image, and place it where you can load it into your Python program with OpenCV\n\nUsing OpenCV:\n\nDetermine a region of interest that includes as much as possible of the object, and no background or extraneous pixels\nSlice the ROI from the original image\nSave the result to a file with imwrite\n\nThe first step is the tricky one. How do you determine the indices to use for the right ROI? You could use guess and check, but this is also an point where you could learn about the tools in OpenCV for responding to the mouse. The program shown below uses mouse clicks to select the upper left and then lower right corner of a rectangular region. It prints those points. The user can reset the rectangle selection by hitting the space bar.\n\nimport cv2\n\nstartPt = None                                  #1\nendPt = None                                    #1\nselected = False                                #1\n\ndef selectROI(event, x, y, flags, param):\n    \"\"\"This is a mouse callback function. ...\"\"\"      #2\n    global startPt, endPt, selected                   #3\n\n    if event == cv2.EVENT_LBUTTONUP:\n        # If user just clicked and released the left mouse button...\n        if startPt is None:\n            startPt = (x, y)\n        else:\n            endPt = (x, y)\n            selected = True\n\ndef runSelection(mainImg):\n    \"\"\"Takes in an image, and loops while user selects regions.\"\"\"\n    global startPt, endPt, selected\n\n    cv2.namedWindow('Image')\n    cv2.setMouseCallback('Image', selectROI)                 #4\n    while True:\n        workingCopy = mainImg.copy()                         #5\n        if selected:                                         #6\n            print(startPt, endPt)\n            cv2.rectangle(workingCopy, startPt, endPt, (0, 255, 255), 2)\n        cv2.imshow(\"Image\", workingCopy)\n        x = cv2.waitKey(10)\n        if x &gt; 0:\n            if chr(x) == 'q':\n                break\n            elif chr(x) == ' ':                             #7\n                selected = False\n                startPt = None\n                endPt = None\n\nimg = cv2.imread(\"BallFinding/Pink/PinkBG1Mid.jpg\")\nrunSelection(img)\n\n\nSets up global variables to let the callback function communicate with the main program\nThe callback function runs separately from the main program, every mouse event triggers this function to run\nWhen using global variables inside a function, it is good style to declare them explicitly this way\nThis sets up the callback function to respond to mouse events\nWe copy the image so that drawing doesn’t change the original\nSet to True only when both points have been selected\nIf user hits space, then globals are reset\n\nYou can also find this program in selectROI.py with additional comments added.\nFigure 10 shows the original pink ball picture from BallFinding, along with a good ROI selected using the selectROI.py program.\n\n\n\n\n\n\n\n\nOriginal image\n\n\n\n\n\n\n\nROI selected for this image\n\n\n\n\n\n\nFigure 10: Original image, and reference image for pink ball selected from the original."
  },
  {
    "objectID": "Readings/Chapter4.html#building-a-histogram-of-hues-from-reference-image",
    "href": "Readings/Chapter4.html#building-a-histogram-of-hues-from-reference-image",
    "title": "Chapter 4, Masks and Thresholds",
    "section": "5.2 Building a histogram of hues from reference image",
    "text": "5.2 Building a histogram of hues from reference image\nThe next step in the backprojection process is to build a histogram of hue values from the reference image. A histogram is used to count how frequently each range of hues occurs. Rather than having an entry for each possible value, we make bins that hold equal sized sequences of values. For instance, if we made 18 bins for the 180 hue values, then each bin would cover 10 hue values: bin 0 would count values between 0 and 9, bin 1 would count between 10 and 19, and so forth. (See Wikipedia article on Histograms if you don’t remember what a histogram is.)\nBelow is a code example that shows how to take a reference image and construct a histogram from it. You don’t need to understand the show_hist function right now: it takes a histogram (represented as a one-dimensional Numpy array) and it displays the histogram as a bar chart.\n\n\nCode\nimport cv2\nimport numpy as np\n\ndef show_hist(hist):\n    \"\"\"Takes in the histogram, and displays it in the hist window.\"\"\"\n    bin_count = hist.shape[0]\n    bin_w = 24\n    img = np.zeros((256, bin_count * bin_w, 3), np.uint8)\n    for i in range(bin_count):\n        h = int(hist[i])\n        cv2.rectangle(img, (i * bin_w + 2, 255), ((i + 1) * bin_w - 2, 255 - h), (int(180.0 * i / bin_count), 255, 255),\n                      -1)\n    img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)\n    cv2.imshow('hist', img)\n\n\n\nrefImg = cv2.imread(\"referencePic.jpg\")\ncv2.imshow(\"Ref img\", refImg)\n\n1histImage = cv2.cvtColor(refImg, cv2.COLOR_BGR2HSV)\n2hist = cv2.calcHist([histImage], [0], None, [18], [0, 180])\n3cv2.normalize(hist, hist, 0, 255, cv2.NORM_MINMAX)\n4hist = hist.reshape(-1)\n5show_hist(hist)\n\ncv2.waitKey()\n\n\n1\n\nConvert the reference images into HSV format\n\n2\n\nCalculate the histogram on the HSV image, looking only at the 0 channel (hue), with no mask, 18 bins, and values that range between 0 and 180\n\n3\n\nRescale the histogram so that the minimum value is 0 and the maximum is 255\n\n4\n\nChange from a column vector (18 rows and 1 column), to a row vector (1 row, 18 values)\n\n5\n\nDisplay the histogram as an image\n\n\n\n\nThe calcHist function is the most important, and complex, step in this code. It has five required inputs:\n\nFirst, it takes in a list of images, here we pass just one, but we have to pass it as a list containing one image.\nSecond, we specify which channels of the image we want to build the histogram from (in this case just the 0, hue, channel).\nThird, we could pass in a mask, if we wanted to, but we pass in None to indicate we don’t want to apply a mask.\nFourth, we specify the number of bins for the histogram (the function will divide the range of values as evenly as it can across the bins).\nFifth, we specify the range of values, from 0 to 180 in this case.\n\nNormalization, in computer vision, and in computer science more broadly, is the process of rescaling some collection of data so that the data values fall within a specified, canonical range. Here, we want to rescale height of the histogram data so that the maximum height of any bar is 255, and the minimum is 0. This will be needed for the next, and final, step, where we compute the backprojection.\nFigure 11 shows the histogram we would get if we selected a reference image for the ball in the earlier example.\n\n\n\n\n\n\nFigure 11: Histogram for pink reference image"
  },
  {
    "objectID": "Readings/Chapter4.html#computing-the-backprojection",
    "href": "Readings/Chapter4.html#computing-the-backprojection",
    "title": "Chapter 4, Masks and Thresholds",
    "section": "5.3 Computing the backprojection",
    "text": "5.3 Computing the backprojection\nThe backprojection algorithm treats the histogram we calculated as a probability distribution: the height of a bar represents the probability that the hues in that range match the reference image.\nWe apply this idea to our current image: for each pixel, we look at its hue and determine which bin of the histogram it falls into. We then use the value/height of that bin as the value in our backprojection image. The result is a threshold image, although often one with grayscale values as well as black and white. Pixels that match our reference hues are non-zero, with brighter pixels falling into the tallest bin.\n\nbpImg = cv2.calcBackProject([hsvImage], [0], hist, [0, 180], 1)\ncv2.imshow(\"Backproject\", bpImg)\n\nThe calcBackProject function takes in a list of images (they must be in HSV since our histogram is in HSV), a list of the channels to apply the backprojection to (just the hue channel, here), the histogram itself, the range of hue values, and an optional scaling factor, to modify the size of the output image.\nFigure 12 shows the result of computing the backprojection using the histogram from the previous step.\n\n\n\n\n\n\nFigure 12: Backprojection for pink reference image applied to original"
  },
  {
    "objectID": "Documents/index.html",
    "href": "Documents/index.html",
    "title": "Comp 194 Class Notes – Overview",
    "section": "",
    "text": "Here you can find each of the “Class Notes” documents. These are Prof. Fox’s notes for class, used both during class and during pre-recorded videos, along with other resources. These documents can help you to decide what is most important, and provide useful notes for reviewing the material quickly.\nThe notes documents were divided into separate documents for roughly every 3-4 weeks of the semester. This keeps the document from being too long, so they are easier to work with.\n\n\nClass Notes documents\n\nClass notes for weeks 0-3\nClass notes for weeks 4-7\nClass notes for weeks 8-11\nClass notes for weeks 12-15"
  },
  {
    "objectID": "Documents/ClassNotes2.html#monday-september-22",
    "href": "Documents/ClassNotes2.html#monday-september-22",
    "title": "Comp 194 Class Notes - Weeks 4-7",
    "section": "Monday, September 22",
    "text": "Monday, September 22\n\nAnnouncements\n\nStart preparing for Ethics and Sci-Fi 4 (for this Friday)\nCoding quiz today!!\n\nThere will be four questions on the quiz today\nYou will have opportunities to redo the topics of this quiz several more times this semester\nThe quiz will be completed on paper, not on the computer: bring pens or pencils and an eraser\nYou should prepare a handwritten, one page (one side of the paper), page of notes\nSee the study guide for the topics and kinds of questions you might face"
  },
  {
    "objectID": "Documents/ClassNotes2.html#wednesday-september-24",
    "href": "Documents/ClassNotes2.html#wednesday-september-24",
    "title": "Comp 194 Class Notes - Weeks 4-7",
    "section": "Wednesday, September 24",
    "text": "Wednesday, September 24\n\nAnnouncements\n\nWork on Ethics and Sci-Fi 4 for Friday\nLibrary Information Fluency Session TODAY!\n\nMeet in the Library for this session (room TBA)"
  },
  {
    "objectID": "Documents/ClassNotes2.html#friday-september-26",
    "href": "Documents/ClassNotes2.html#friday-september-26",
    "title": "Comp 194 Class Notes - Weeks 4-7",
    "section": "Friday, September 26",
    "text": "Friday, September 26\n\nAnnouncements\n\nStart looking at Homework 2 this weekend… if I have it ready\nBe prepared to discuss Ethics and Sci-Fi 4 today\n\n\n\nToday’s topics\n\nList and string operations\nList and string methods\nTuples\nList comprehensions\n\n\n\nList and string operations\n\nFunctions: len, list, str\nAccessing elements or substrings/lists: lst[3], myName[0:5]\nConcatenation with + or *: \"sun\" + \"flower\"\nLooping over list or string contents\n\n\n\nString methods\nImmutable, a key idea:\n\nStrings are “immutable,” which means “unchangeable.” You can build strings, but you can’t modify them once they are built. You can just build new strings out of an existing string.\nOther data types that are immutable: numbers, tuples, (functions and modules, too, but then they’re weird data anyway)\nThink about string operators and functions we’ve already seen: + and * build new strings, len doesn’t produce a string, and accessing characters or slicing build new strings, too!\n\nString methods\n\nRemember what a method is: it is like a function, but it is attached to a piece of data.\nKeep handy the Python documentation on String Methods.\nGeneral categories of methods\n\nChange capitalization\nChange/set spacing of string (left/right justify, etc.)\nChecking string contents for types of characters\nSearching and replacing in strings\nBreaking strings into pieces\n\n\n\n\nList methods\nKeep handy the Python documentation on List Methods.\n\n\n\n\n\n\n\nExample\nDescription\n\n\n\n\nls = [5, 2, 4, 7, 1, 9, 6]\nSet up the initial list\n\n\nls.append(23)\nAdd a new value at the end\n\n\nls.extend([5, 2, 1])\nAdd new elements at the end\n\n\nls.pop(0)\nRemove the value at given position\n\n\nls.insert(2, 80)\nInsert at given position new value\n\n\nls.remove(9)\nRemove the first occurrence from list\n\n\nls.index(4)\nReturn the index of first occurrence\n\n\nls.count(1)\nCount the number of occurrences\n\n\nls.sort()\nModify list to be sorted\n\n\nls.reverse()\nModify list to be in reverse order\n\n\nls.copy()\nReturns a shallow copy (sublists not copied)\n\n\n\n\n\nAliasing and references\nAliasing refers to a situation when more than one variable name references the same actual data in the computer’s memory. When that happens, the data has its original name, plus an “alias”. Confusion can arise if we don’t realize when using the alias that we are also referring to the original variable. We care about these things because lists are mutable. If a list is shared across multiple variables, then changing the list through one variable makes the other variable ’s value change as well! This is an easy mistake to make when modifying lists. Here is an example:\n\nlstA = ['a', 'b', 'c', 'd']\nlstB = lstA.copy()   # makes a copy of lstA\nlstC = lstA          # makes lstC be an alias of lstA\nprint(\"A:\", lstA)\nprint(\"B:\", lstB)\nprint(\"C:\", lstC)\nlstA[2] = 'zzzz'\nprint(\"A:\", lstA)\nprint(\"B:\", lstB)\nprint(\"C:\", lstC)\n\nA: ['a', 'b', 'c', 'd']\nB: ['a', 'b', 'c', 'd']\nC: ['a', 'b', 'c', 'd']\nA: ['a', 'b', 'zzzz', 'd']\nB: ['a', 'b', 'c', 'd']\nC: ['a', 'b', 'zzzz', 'd']\n\n\n\n\nTuples\n\nBasically, an immutable list\nUsed when returning multiple values from a function\nMore memory efficient than a list\nHas no methods!\n\n\n\nList comprehensions\nA shorthand notation for a for loop that builds one list from the contents of another. It does the same work Abbreviated notation, still does the same work. You can always do what a list comprehension does with loops and accumulator variables\nFirst general form:\n\n[&lt;expr&gt; for &lt;var&gt; in &lt;seq&gt;]\n\nis equivalent to\n\nnewList = []\nfor &lt;var&gt; in &lt;seq&gt;:\n    newVal = &lt;expr&gt;\n    newList += [newVal]\n\nSecond general form:\n\n[&lt;expr&gt; for &lt;var&gt; in &lt;seq&gt; if &lt;boolExpr&gt;]\n\nis equivalent to\n\nnewList = []\nfor &lt;var&gt; in &lt;seq&gt;:\n    if &lt;boolExpr&gt;:\n        newVal = &lt;expr&gt;\n        newList += [newVal]\n\nExamples:\n\nls = [5, 2, 4, 7, 1, 9, 6]       # set up the initial list\nnewls = [2*x for x in ls]\nls3 = [int(s) for s in ['35', '12', '103', '-3']]\nls4 = [x for x in ls if x &lt; 6]"
  },
  {
    "objectID": "Documents/ClassNotes2.html#monday-september-29",
    "href": "Documents/ClassNotes2.html#monday-september-29",
    "title": "Comp 194 Class Notes - Weeks 4-7",
    "section": "Monday, September 29",
    "text": "Monday, September 29\n\nAnnouncements\n\nHomework 2 is due by the end of this week\nBe prepared to discuss Ethics and Sci-Fi 5 this Friday!\n\n\n\nToday’s topics\n\nNumpy operations\nImage arithmetic\n\n\n\nNumber types\n\nPython has one integer type, any size of integer is just called an int\n\nUnderneath, integers really have fixed size, but Python converts between representations for us\n\nPython has one floating-point type: float\n\nMuch like with integers, the representation underneath may change, but we don’t have to worry about it\n\n\nFixed-length numbers: The hardware of the computer implements integers of specific lengths, typically 8 bits, 16 bits, 32 bits, and 64 bits. Flaoting point numbers are either 32 or 64 bits long. It can also distinguish between unsigned integers and signed integers. Unsigned integers are either zero or positive only; signed integers include both positive and negative values.\nNumpy defines numeric types for all these fixed-size numbers. The table below lists the different numeric types in Numpy:\n\n\n\n\nSigned\nUnsigned\nFloat\n\n\n\n\n8 bits\nint8\nuint8\n\n\n\n16 bits\nint16\nuint16\n\n\n\n32 bits\nint32\nuint32\nfloat32\n\n\n64 bits\nint64\nuint64\nfloat64\n\n\n\n\n\nArrays in Numpy\nNumpy arrays: * Are similar to vectors and matrices in mathematics * Are implemented as contiguous blocks of memory, giving efficient, fast access and operations * Hold just one kind of data, its dtype (typically) * Have a fixed number of dimensions (any number) * Have a fixed size, called its shape\n\n\nImages as Numpy arrays\n\nColor images: Three dimensional arrays, with height, width, and depth, depth = channels\nGrayscaxle images: Two-dimensional arrays, height and width, brightness values in each pixel\nNormal images use uint8 for each pixel/channel value\n\nHere are two images of very different sizes. One, we convert to grayscale as well, and print the sizes and data types for each array.\n\nimport cv2\n\nimg1 = cv2.imread(\"SampleImages/GoogleyEye.png\")\nimg2 = cv2.imread(\"SampleImages/landscape1.jpg\")\nimg3 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)\n\nprint(\"Image 1 shape:\", img1.shape, \"and dtype\", img1.dtype) \nprint(\"Image 2 shape:\", img2.shape, \"and dtype\", img2.dtype) \nprint(\"Image 3 shape:\", img3.shape, \"and dtype\", img3.dtype) \n\n\n\nNumpy functions\nNumpy has an incredible number of tools, we will use just a fraction of them.\nNumpy Documentation is excellent: use it!\nFunctions: * np.array converts an input list, array, string, tuple into an array of the same dimensions * np.asarray similar, but doesn’t always copy the data * array.astype an array method, produces a view or copy with a new type * np.zeros creates an array of an input size and type, filled with zeros * np.ones similar, but fills with ones * np.arange, given a starting value, ending value, and step size, builds an array with those values (works on floats!) * np.random.rand, creates an array of a given size and data type, filled with random values in a specified range\n\n\nNo nested loops on arrays (if we can help it)\nRather than writing code that loops over rows and columns of a Numpy matrix, we usually try to perform matrix/vector arithmetic. We can add two arrays together, if they are the same shape. This adds corresponding values together and builds an array of the result. We can do subtraction, multiplication, and division similarly. We can also compute dot product and cross produce, if needed.\nExamples:\n\nimport numpy as np\n\na1 = np.array([[1, 2, 3, 4], [2, 3, 4, 5]])\na2 = np.array([[6, 5, 4, 3], [7, 6, 5, 4]])\nprint(\"a1 + a2:\")\nprint(a1 + a2)\nprint(\"a1 - a2:\")\nprint(a1 - a2)\nprint(\"a1 * a2:\")\nprint(a1 * a2)\nprint(\"3 * a1\")\nprint(3 * a1)\n\na1 + a2:\n[[7 7 7 7]\n [9 9 9 9]]\na1 - a2:\n[[-5 -3 -1  1]\n [-5 -3 -1  1]]\na1 * a2:\n[[ 6 10 12 12]\n [14 18 20 20]]\n3 * a1\n[[ 3  6  9 12]\n [ 6  9 12 15]]\n\n\n\n\nSlicing on arrays\nSlicing on arrays works similarly to slicing on strings or lists. But we can specify multiple dimensions at one time. Slicing weirdness: if the bound on the slice goes beyond the limits of the list, string, or array, Python doesn’t given an error. It just treats that as a “go to the end” marker and returns up to the end of the current dimensions.\n\nprint(a1[1:2, 1:3])\n# Weirdness we haven't discussed\nlst = ['a', 'b', 'c', 'd', 'e']\nprint(a1[1:200, 1:50], lst[2:25])\n\n[[3 4]]\n[[3 4 5]] ['c', 'd', 'e']\n\n\n\n\nBoolean arrays\nWe won’t really need these much, but they are very cool!\n\nboolOne = a2 &gt; 3\nboolTwo = a1 &lt;= 3\nprint(boolOne)\nprint(boolTwo)\nprint(np.logical_and(boolOne, boolTwo))\n\n[[ True  True  True False]\n [ True  True  True  True]]\n[[ True  True  True False]\n [ True  True False False]]\n[[ True  True  True False]\n [ True  True False False]]\n\n\n\n\nImage arithmetic\nSome typical uses for image arithmetic\n\nBrighten or darken an image by adding to channel values\nSimple changes to specific channels\nCombining two image parts\nBlending images\n\nExample 1: Boost the green\n#| eval: false\nimg = cv2.imread(\"SampleImages/grandTetons.jpg\")\nboostIm = img.copy()\nboostIm[:, :, 1] = cv2.add(boostIm[:, :, 1], 25)\nExample 2: Blending images\n#| eval: false\nimg1 = cv2.imread(\"SampleImages/mightyMidway.jpg\")\nimg2 = cv2.imread(\"SampleImages/antiqueTractors.jpg\")\n\n# Find the smallest dimensions across both images\n(h1, w1, d1) = img1.shape\n(h2, w2, d2) = img2.shape\nwid = min(w1, w2)\nhgt = min(h1, h2)\n\n# Crop the two images to the sizes they share\nnewImg1 = img1[:hgt, :wid]\nnewImg2 = img2[:hgt, :wid]\n\n# Blend the resulting images\nblendIm = cv2.addWeighted(newImg1, 0.5, newImg2, 0.5, 0)\ncv2.imshow(\"Blended\", blendIm)\ncv2.waitKey()"
  },
  {
    "objectID": "Documents/ClassNotes2.html#wednesday-october-1",
    "href": "Documents/ClassNotes2.html#wednesday-october-1",
    "title": "Comp 194 Class Notes - Weeks 4-7",
    "section": "Wednesday, October 1",
    "text": "Wednesday, October 1\n\nAnnouncements\n\nHomework 2 is due by the end of this week\nBe prepared to discuss Ethics and Sci-Fi 5 this Friday!\n\n\n\nToday’s topics\n\nSplitting and merging channels\nRegions of interest\n\n\n\nThe split and merge functions\nWe can pull images apart using Numpy commands, but sometimes OpenCV’s are easier to remember.\nThe split function takes in a color image, and returns a tuple of its channels as separate arrays The merge function takes in a tuple of channels, and combines them together.\nThe code example below creates various negative versions of an image. In film cameras, the film stores a negative version of the image, where light parts are dark, and vice versa. This is turned into correct colors or brightness during film process.\nWe can create negatives by reversing the values in one or all channels of an image. So if a pixel had the value 0 originally it will become 255, if it had the value 10, it will become 245, and if it had the value 200, it would become\nThis might seem difficult to compute, but actually it is very simple. If we subtract the image array from 255, it gives us this negative effect.\nThe code example below demonstrates both negative images, and the split and merge functions.\n\nFirst it reads in a colorful mountain picture\nIt converts it to grayscale and produces the negative of the grayscale (understanding negatives is easier with grayscale images)\nIt also converts all three channels to be a negative and displays it\nFinally, it splits the image into three channels, and shows the effect of converting just one channel at a time to a negative\n\n\nimport cv2\n\n# Read original image\nimg = cv2.imread(\"SampleImages/landscape1MuchSmaller.jpg\")\ncv2.imshow(\"orig\", img)\n\n# Grayscale, and gray negative\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\ngrayNeg = 255 - gray\ncv2.imshow(\"Gray original\", gray)\ncv2.imshow(\"Negative gray\", grayNeg)\ncv2.waitKey()\n\n# Overall negative\nimg2 = 255 - img\ncv2.imshow(\"OverallNegative\", img2)\ncv2.waitKey()\n\n(bc, gc, rc) = cv2.split(img)\n\nnegGC = 255 - gc\nnegBC = 255 - bc\nnegRC = 255 - rc\n\n# Only blue channel negative\nnewIm1 = cv2.merge((negBC, gc, rc))\ncv2.imshow(\"newBlue\", newIm1)\ncv2.waitKey()\n\n# Only green channel negative\nnewIm2 = cv2.merge((bc, negGC, rc))\ncv2.imshow(\"newGreen\", newIm2)\ncv2.waitKey()\n\n# Only red channel negative\nnewIm3 = cv2.merge((bc, gc, negRC))\ncv2.imshow(\"newRed\", newIm3)\ncv2.waitKey()\n\n\n\nRegions of interest\nA region of interest is just a rectangular section of an image that we want to isolate and work with.\nWe can make regions of interest using Numpy’s slicing operator. But we must remember that by default we get a view to the original data, and not a copy of the data. Changes made to the ROI usually show in the original image.\n\nmushIm = cv2.imread(\"SampleImages/mushrooms.jpg\")\n\ncv2.imshow(\"Mushrooms\", mushIm)\n\n# Two regions of interest centered on mushroom tops\nroi1 = mushIm[135:230, 50:170]\nroi2 = mushIm[120:215, 255:390]\n\ncv2.imshow(\"roi1\", roi1)\ncv2.imshow(\"roi2\", roi2)\ncv2.waitKey()\n\nNotice that with slicing we put the row range first, and then the column range. If we wanted to draw a rectangle around the region on the image, we would swap the order of the indices to give the upper left and lower right points (as in the code below).\n\ncv2.rectangle(mushIm, (50, 135), (170, 230), (0, 255, 255), 2)\ncv2.rectangle(mushIm, (255, 120), (390, 215), (0, 255, 255), 2)\ncv2.imshow(\"Marked\", mushIm)\ncv2.waitKey()"
  },
  {
    "objectID": "Documents/ClassNotes2.html#friday-october-3",
    "href": "Documents/ClassNotes2.html#friday-october-3",
    "title": "Comp 194 Class Notes - Weeks 4-7",
    "section": "Friday, October 3",
    "text": "Friday, October 3\n\nAnnouncements\n\nHomework 2 is due today!\nBe prepared to discuss Ethics and Sci-Fi 5 today!\n\n\n\nToday’s topics\n\nWhile loops\nWorking with the web-cam\n\n\n\nWhile loops\nIndefinite looping is when the loop continues for an unknown number of repetitions. The number of repetitions depends on a boolean test: the loop continues until the test becomes False.\nWhile loops are a more “primitive” kind of loop, more simple, leaving more responsibility on the programmer. As the programmer, you are responsible for setting up and updating the loop variable as well as any ordinary accumulator variables.\nBelow is a version of the Numpy arange function, but for lists. Given a starting value, and ending value, and a step size, all floating-point numbers, it produces a list containing the sequence of values starting with the starting value and increasing by step size each time, up to but not including the end point.\n\ndef myARange(start, end, step):\n    ansList = []                         # accumulator initialize\n    currValue = start                    # loop variable initialize\n    while (currValue &lt; end):             # loop test\n        ansList.append(currValue)        # update accumulator\n        currValue = currValue + step     # update loop variable\n    return ansList\n\n\n\nUsing a web-cam\nProcessing frames from a live webcam works the same as processing saved video files (.avi or .mp4 formats). Videos are just sequences of images, but we have to talk to the operating system for permission to connect with the camera or to get the frames from a saved video.\nOpenCV provides a VideoCapture object that knows how to connect to cameras or video files. We first create an instance of a VideoCapture object, and then use its read method to get the images from the video.\n\nVideoCapture has one required input: either the number of the webcam on your system, or a string that gives the path to a saved video file. The built-in webcam is (usually) number zero.\n\nTo see the frames of the video in real-time, we need to change how we use waitKey and use more of its capabilities.\nNotes about waitkey:\n\nwaitKey is responsible for actually displaying the windows with images\nwaitKey takes in a number, if 0, then it pauses indefinitely to wait for the user to hit a key, if the input is a positive integer, it pauses only for that many milliseconds and then returns and lets the program continue\nwaitKey returns a number that indicates the user’s input: -1 if they didn’t input anything, and the numeric code for the key the entered, otherwise.\n\n\nvidCap = cv2.VideoCapture(0)\n\nwhile True:\n    gotFrame, img = vidCap.read()\n    if not gotFrame:\n        print(\"Got no frame\")\n        break\n    cv2.imshow(\"Webcam\", img)\n    x = cv2.waitKey(10)\n    if x &gt; 0:\n        if chr(x) == 'q':\n            break"
  },
  {
    "objectID": "Documents/ClassNotes2.html#monday-october-6",
    "href": "Documents/ClassNotes2.html#monday-october-6",
    "title": "Comp 194 Class Notes - Weeks 4-7",
    "section": "Monday, October 6",
    "text": "Monday, October 6\n\nAnnouncements\n\nStart looking at Homework 3 by the end of this week, due Wednesday next week\nBe prepared to discuss Ethics and Sci-Fi 6 this Friday\nHealth promotions session today\n\n\n\nToday’s topics\n\nMaking threshold images\nMasking images\nThreshold images as masks"
  },
  {
    "objectID": "Documents/ClassNotes2.html#wednesday-october-8",
    "href": "Documents/ClassNotes2.html#wednesday-october-8",
    "title": "Comp 194 Class Notes - Weeks 4-7",
    "section": "Wednesday, October 8",
    "text": "Wednesday, October 8\n\nAnnouncements\n\nStart on Homework 3 very soon, due Wednesday next week\nBe prepared to discuss Ethics and Sci-Fi 6 this Friday\n\n\n\nToday’s topics\n\nGeometric transformations in general\nResizing\nTranslation\nRotation\nWarping\nPerspective warping"
  },
  {
    "objectID": "Documents/ClassNotes2.html#friday-october-10",
    "href": "Documents/ClassNotes2.html#friday-october-10",
    "title": "Comp 194 Class Notes - Weeks 4-7",
    "section": "Friday, October 10",
    "text": "Friday, October 10\n\nAnnouncements\n\nHomework 3 by the end of this week, due Wednesday next week\nBe prepared to discuss Ethics and Sci-Fi 6 today!\n\n\n\nToday’s topics\n\nImage filters\nMorphological filters\n\nErosion and dilation\nOpening and closing\nBlack hat and top hat\nGradient\n\nConvolutional filters\n\nBlurring\nEdge detection"
  },
  {
    "objectID": "Documents/ClassNotes2.html#monday-october-13",
    "href": "Documents/ClassNotes2.html#monday-october-13",
    "title": "Comp 194 Class Notes - Weeks 4-7",
    "section": "Monday, October 13",
    "text": "Monday, October 13\n\nAnnouncements\n\nNo Ethics and Sci-Fi this week (due to Fall Break)\nCoding quiz Wednesday!!\n\n\n\nToday’s topics\n\nFinding Contours\nManipulating contours"
  },
  {
    "objectID": "Documents/ClassNotes2.html#wednesday-october-15",
    "href": "Documents/ClassNotes2.html#wednesday-october-15",
    "title": "Comp 194 Class Notes - Weeks 4-7",
    "section": "Wednesday, October 15",
    "text": "Wednesday, October 15\n\nAnnouncements\n\nNo Ethics and Sci-Fi this week (due to Fall Break)\nCoding quiz today!!\n\nThere will be four new questions on the quiz today, plus new questions on the four topics from quiz 1\nYou will have opportunities to redo the topics of this quiz several more times this semester\nThe quiz will be completed on paper, not on the computer: bring pens or pencils and an eraser\nYou should prepare a handwritten, one page (one side of the paper), page of notes\nSee the study guide for the topics and kinds of questions you might face"
  },
  {
    "objectID": "Documents/ClassNotes2.html#friday-october-17",
    "href": "Documents/ClassNotes2.html#friday-october-17",
    "title": "Comp 194 Class Notes - Weeks 4-7",
    "section": "Friday, October 17",
    "text": "Friday, October 17\nFALL BREAK!!"
  },
  {
    "objectID": "Homework/Homework2.html#your-job-write-randomcrop",
    "href": "Homework/Homework2.html#your-job-write-randomcrop",
    "title": "Homework 2",
    "section": "Your job: write randomCrop",
    "text": "Your job: write randomCrop\nYour task is to add the helper function, randomCrop, to this program. The randomCrop function has a much easier task. It takes in three input arguments: an image to crop, and the width and height that the resulting image should have. It should choose a valid region of interest (ROI) of the given size, and then it should return the ROI image.\nBelow is a code sample showing how we might call randomCrop separately to test it, and in Figure 2 are four random results from this call.\n\ncropIm = randomCrop(im1, 250, 250)\n\n\n\n\n\n\n\n\n\nRun 1\n\n\n\n\n\n\n\nRun 2\n\n\n\n\n\n\n\n\n\nRun 3\n\n\n\n\n\n\n\nRun 4\n\n\n\n\n\n\nFigure 2: Random crops of the landscape1.jpg image, returning 250 by 250 pixel images.\n\n\n\nHere is an algorithm for what randomCrop needs to do, written in high-level pseudocode:\nAlgorithm randomCrop(image, wid, hgt)\n1. Get the dimensions of the image, particularly imWid and imHgt, its width and height\n12. Calculate the maximum x value that will ensure the crop width won't go beyond imWid\n3. Calculate the maximum y value that will ensure the crop height won't go beyond imHgt\n24. Generate a random integer between 0 and the max x value\n5. Generate a random integer between 0 and the max y value\n6. Let cropped = a slicing of image starting with random x and random y, with wid and hgt from inputs\n7. Return cropped\n\n1\n\nThis is the tricky part!\n\n2\n\nThese will be the left and upper edge of the ROI, the starting x and y values\n\n\nSteps 2 and 3 in the algorithm take a little bit of thought. We want to make sure that the crop is (1) the right size, and (2) fits entirely within the original image. How can we do that?\n\nIf we pick a good index x1 for the left edge of the crop region, then the right edge will just be x1 + wid\nSimilarly, if we pick a good index y1 for the top edge of the crop region, then the bottom edge will be y1 + hgt\nWhat range of values are “good” indices? That depends on the relative sizes of the image and the input wid or hgt\n\nYou may assume that wid will be less than the width of the original image\nYou may assume that hgt will be less than the height of the original image\nGiven that, 0 is the smallest “good” index for both width and height\nTo determine the formula for the max x value and max y value, run the runCropPositions.py program and watch the animation it draws. It shows an example image and crop size, and demonstrates the range of good x indices for that example. (Ask for help if you can’t figure out how to calculate the max)\n\n\nComplete the randomCrop function, and test it both with the sample calls in the hw2Code.py file (and others that you add), and also with the hw2Checker.py file, which contains two testing functions for this problem."
  },
  {
    "objectID": "Homework/Homework2.html#step-1-examine-findminmax",
    "href": "Homework/Homework2.html#step-1-examine-findminmax",
    "title": "Homework 2",
    "section": "Step 1: Examine findMinMax",
    "text": "Step 1: Examine findMinMax\nLook at the definition of findMinMax in hw2Code.py. It first sorts the list, and then access the first and last values.\nWe are going to keep the first two lines of the function: the one that defines n to be the length of the list, and the one that sorts the list.\nInstead of the first and last elements, however, we need to find the middle element(s)."
  },
  {
    "objectID": "Homework/Homework2.html#step-2-set-up-findmedian",
    "href": "Homework/Homework2.html#step-2-set-up-findmedian",
    "title": "Homework 2",
    "section": "Step 2: Set up findMedian",
    "text": "Step 2: Set up findMedian\nCopy the function definition for findMinMax, and change its name to findMedian. Remove the final line (the one that returned the first and last)."
  },
  {
    "objectID": "Homework/Homework2.html#step-3-split-into-two-cases-even-versus-odd-length",
    "href": "Homework/Homework2.html#step-3-split-into-two-cases-even-versus-odd-length",
    "title": "Homework 2",
    "section": "Step 3: Split into two cases: even versus odd length",
    "text": "Step 3: Split into two cases: even versus odd length\nAdd an if statement to the function definition, right after the line that sorts the list. In the if statement, one case should be for odd-length lists, and the other for even-length lists.\n(To use incremental development, add a print statement to each case as a placeholder, and print a message identifying which case it is. Then see if it prints the right message for sample lists.)"
  },
  {
    "objectID": "Homework/Homework2.html#step-4-find-the-middle-element-of",
    "href": "Homework/Homework2.html#step-4-find-the-middle-element-of",
    "title": "Homework 2",
    "section": "Step 4: Find the middle element of",
    "text": "Step 4: Find the middle element of"
  },
  {
    "objectID": "Homework/Homework2.html#step-4-find-the-middle-element-of-the-odd-length-list",
    "href": "Homework/Homework2.html#step-4-find-the-middle-element-of-the-odd-length-list",
    "title": "Homework 2",
    "section": "Step 4: Find the middle element of the odd-length list",
    "text": "Step 4: Find the middle element of the odd-length list\nStart with the easier case: we need to figure out which position in the list is the middle one. Start by looking at ?@fig-midVal for some examples of different odd-length lists, and which position is the middle one."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Comp 194 Web Materials",
    "section": "",
    "text": "This website contains materials written using Quarto for the Comp 194, Introduction to Computer Science through Vision, course. Materials are organized into three pieces:\n\nDocuments include class notes and other main course documents\nReadings include assigned class readings about computer vision, written by Prof. Fox\nIn-Class Activities include all activities we will work on in class\nHomework Assignments include all out-of-class programming assignments"
  }
]